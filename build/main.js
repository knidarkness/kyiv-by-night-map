(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __reExport = (target, module, copyDefault, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toESM = (module, isNodeMode) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", !isNodeMode && module && module.__esModule ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js"(exports, module) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);
          for (var key in from) {
            if (hasOwnProperty2.call(from, key)) {
              to[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // node_modules/concaveman/node_modules/rbush/rbush.min.js
  var require_rbush_min = __commonJS({
    "node_modules/concaveman/node_modules/rbush/rbush.min.js"(exports, module) {
      !function(t, i) {
        typeof exports == "object" && typeof module != "undefined" ? module.exports = i() : typeof define == "function" && define.amd ? define(i) : (t = t || self).RBush = i();
      }(exports, function() {
        "use strict";
        function t(t2, r2, e3, a2, h2) {
          !function t3(n2, r3, e4, a3, h3) {
            for (; a3 > e4; ) {
              if (a3 - e4 > 600) {
                var o2 = a3 - e4 + 1, s2 = r3 - e4 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u2 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m2 = Math.max(e4, Math.floor(r3 - s2 * f2 / o2 + u2)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u2));
                t3(n2, r3, m2, c2, h3);
              }
              var p2 = n2[r3], d2 = e4, x2 = a3;
              for (i(n2, e4, r3), h3(n2[a3], p2) > 0 && i(n2, e4, a3); d2 < x2; ) {
                for (i(n2, d2, x2), d2++, x2--; h3(n2[d2], p2) < 0; )
                  d2++;
                for (; h3(n2[x2], p2) > 0; )
                  x2--;
              }
              h3(n2[e4], p2) === 0 ? i(n2, e4, x2) : i(n2, ++x2, a3), x2 <= r3 && (e4 = x2 + 1), r3 <= x2 && (a3 = x2 - 1);
            }
          }(t2, r2, e3 || 0, a2 || t2.length - 1, h2 || n);
        }
        function i(t2, i2, n2) {
          var r2 = t2[i2];
          t2[i2] = t2[n2], t2[n2] = r2;
        }
        function n(t2, i2) {
          return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
        }
        var r = function(t2) {
          t2 === void 0 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
        };
        function e(t2, i2, n2) {
          if (!n2)
            return i2.indexOf(t2);
          for (var r2 = 0; r2 < i2.length; r2++)
            if (n2(t2, i2[r2]))
              return r2;
          return -1;
        }
        function a(t2, i2) {
          h(t2, 0, t2.children.length, i2, t2);
        }
        function h(t2, i2, n2, r2, e3) {
          e3 || (e3 = p(null)), e3.minX = 1 / 0, e3.minY = 1 / 0, e3.maxX = -1 / 0, e3.maxY = -1 / 0;
          for (var a2 = i2; a2 < n2; a2++) {
            var h2 = t2.children[a2];
            o(e3, t2.leaf ? r2(h2) : h2);
          }
          return e3;
        }
        function o(t2, i2) {
          return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
        }
        function s(t2, i2) {
          return t2.minX - i2.minX;
        }
        function l(t2, i2) {
          return t2.minY - i2.minY;
        }
        function f(t2) {
          return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
        }
        function u(t2) {
          return t2.maxX - t2.minX + (t2.maxY - t2.minY);
        }
        function m(t2, i2) {
          return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
        }
        function c(t2, i2) {
          return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
        }
        function p(t2) {
          return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        }
        function d(i2, n2, r2, e3, a2) {
          for (var h2 = [n2, r2]; h2.length; )
            if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e3)) {
              var o2 = n2 + Math.ceil((r2 - n2) / e3 / 2) * e3;
              t(i2, o2, n2, r2, a2), h2.push(n2, o2, o2, r2);
            }
        }
        return r.prototype.all = function() {
          return this._all(this.data, []);
        }, r.prototype.search = function(t2) {
          var i2 = this.data, n2 = [];
          if (!c(t2, i2))
            return n2;
          for (var r2 = this.toBBox, e3 = []; i2; ) {
            for (var a2 = 0; a2 < i2.children.length; a2++) {
              var h2 = i2.children[a2], o2 = i2.leaf ? r2(h2) : h2;
              c(t2, o2) && (i2.leaf ? n2.push(h2) : m(t2, o2) ? this._all(h2, n2) : e3.push(h2));
            }
            i2 = e3.pop();
          }
          return n2;
        }, r.prototype.collides = function(t2) {
          var i2 = this.data;
          if (!c(t2, i2))
            return false;
          for (var n2 = []; i2; ) {
            for (var r2 = 0; r2 < i2.children.length; r2++) {
              var e3 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e3) : e3;
              if (c(t2, a2)) {
                if (i2.leaf || m(t2, a2))
                  return true;
                n2.push(e3);
              }
            }
            i2 = n2.pop();
          }
          return false;
        }, r.prototype.load = function(t2) {
          if (!t2 || !t2.length)
            return this;
          if (t2.length < this._minEntries) {
            for (var i2 = 0; i2 < t2.length; i2++)
              this.insert(t2[i2]);
            return this;
          }
          var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
          if (this.data.children.length)
            if (this.data.height === n2.height)
              this._splitRoot(this.data, n2);
            else {
              if (this.data.height < n2.height) {
                var r2 = this.data;
                this.data = n2, n2 = r2;
              }
              this._insert(n2, this.data.height - n2.height - 1, true);
            }
          else
            this.data = n2;
          return this;
        }, r.prototype.insert = function(t2) {
          return t2 && this._insert(t2, this.data.height - 1), this;
        }, r.prototype.clear = function() {
          return this.data = p([]), this;
        }, r.prototype.remove = function(t2, i2) {
          if (!t2)
            return this;
          for (var n2, r2, a2, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
            if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h2.leaf) {
              var f2 = e(t2, h2.children, i2);
              if (f2 !== -1)
                return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
            }
            a2 || h2.leaf || !m(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a2 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
          }
          return this;
        }, r.prototype.toBBox = function(t2) {
          return t2;
        }, r.prototype.compareMinX = function(t2, i2) {
          return t2.minX - i2.minX;
        }, r.prototype.compareMinY = function(t2, i2) {
          return t2.minY - i2.minY;
        }, r.prototype.toJSON = function() {
          return this.data;
        }, r.prototype.fromJSON = function(t2) {
          return this.data = t2, this;
        }, r.prototype._all = function(t2, i2) {
          for (var n2 = []; t2; )
            t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
          return i2;
        }, r.prototype._build = function(t2, i2, n2, r2) {
          var e3, h2 = n2 - i2 + 1, o2 = this._maxEntries;
          if (h2 <= o2)
            return a(e3 = p(t2.slice(i2, n2 + 1)), this.toBBox), e3;
          r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e3 = p([])).leaf = false, e3.height = r2;
          var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
          d(t2, i2, n2, l2, this.compareMinX);
          for (var f2 = i2; f2 <= n2; f2 += l2) {
            var u2 = Math.min(f2 + l2 - 1, n2);
            d(t2, f2, u2, s2, this.compareMinY);
            for (var m2 = f2; m2 <= u2; m2 += s2) {
              var c2 = Math.min(m2 + s2 - 1, u2);
              e3.children.push(this._build(t2, m2, c2, r2 - 1));
            }
          }
          return a(e3, this.toBBox), e3;
        }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
          for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
            for (var e3 = 1 / 0, a2 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
              var s2 = i2.children[o2], l2 = f(s2), u2 = (m2 = t2, c2 = s2, (Math.max(c2.maxX, m2.maxX) - Math.min(c2.minX, m2.minX)) * (Math.max(c2.maxY, m2.maxY) - Math.min(c2.minY, m2.minY)) - l2);
              u2 < a2 ? (a2 = u2, e3 = l2 < e3 ? l2 : e3, h2 = s2) : u2 === a2 && l2 < e3 && (e3 = l2, h2 = s2);
            }
            i2 = h2 || i2.children[0];
          }
          var m2, c2;
          return i2;
        }, r.prototype._insert = function(t2, i2, n2) {
          var r2 = n2 ? t2 : this.toBBox(t2), e3 = [], a2 = this._chooseSubtree(r2, this.data, i2, e3);
          for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e3[i2].children.length > this._maxEntries; )
            this._split(e3, i2), i2--;
          this._adjustParentBBoxes(r2, e3, i2);
        }, r.prototype._split = function(t2, i2) {
          var n2 = t2[i2], r2 = n2.children.length, e3 = this._minEntries;
          this._chooseSplitAxis(n2, e3, r2);
          var h2 = this._chooseSplitIndex(n2, e3, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
          o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
        }, r.prototype._splitRoot = function(t2, i2) {
          this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
        }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
          for (var r2, e3, a2, o2, s2, l2, u2, m2 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
            var d2 = h(t2, 0, p2, this.toBBox), x2 = h(t2, p2, n2, this.toBBox), v = (e3 = d2, a2 = x2, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, o2 = Math.max(e3.minX, a2.minX), s2 = Math.max(e3.minY, a2.minY), l2 = Math.min(e3.maxX, a2.maxX), u2 = Math.min(e3.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u2 - s2)), M = f(d2) + f(x2);
            v < m2 ? (m2 = v, r2 = p2, c2 = M < c2 ? M : c2) : v === m2 && M < c2 && (c2 = M, r2 = p2);
          }
          return r2 || n2 - i2;
        }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
          var r2 = t2.leaf ? this.compareMinX : s, e3 = t2.leaf ? this.compareMinY : l;
          this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e3) && t2.children.sort(r2);
        }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
          t2.children.sort(r2);
          for (var e3 = this.toBBox, a2 = h(t2, 0, i2, e3), s2 = h(t2, n2 - i2, n2, e3), l2 = u(a2) + u(s2), f2 = i2; f2 < n2 - i2; f2++) {
            var m2 = t2.children[f2];
            o(a2, t2.leaf ? e3(m2) : m2), l2 += u(a2);
          }
          for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
            var p2 = t2.children[c2];
            o(s2, t2.leaf ? e3(p2) : p2), l2 += u(s2);
          }
          return l2;
        }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
          for (var r2 = n2; r2 >= 0; r2--)
            o(i2[r2], t2);
        }, r.prototype._condense = function(t2) {
          for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--)
            t2[i2].children.length === 0 ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
        }, r;
      });
    }
  });

  // node_modules/tinyqueue/tinyqueue.js
  var require_tinyqueue = __commonJS({
    "node_modules/tinyqueue/tinyqueue.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = global || self, global.TinyQueue = factory());
      })(exports, function() {
        "use strict";
        var TinyQueue = function TinyQueue2(data, compare) {
          if (data === void 0)
            data = [];
          if (compare === void 0)
            compare = defaultCompare;
          this.data = data;
          this.length = this.data.length;
          this.compare = compare;
          if (this.length > 0) {
            for (var i = (this.length >> 1) - 1; i >= 0; i--) {
              this._down(i);
            }
          }
        };
        TinyQueue.prototype.push = function push(item) {
          this.data.push(item);
          this.length++;
          this._up(this.length - 1);
        };
        TinyQueue.prototype.pop = function pop() {
          if (this.length === 0) {
            return void 0;
          }
          var top = this.data[0];
          var bottom = this.data.pop();
          this.length--;
          if (this.length > 0) {
            this.data[0] = bottom;
            this._down(0);
          }
          return top;
        };
        TinyQueue.prototype.peek = function peek() {
          return this.data[0];
        };
        TinyQueue.prototype._up = function _up(pos) {
          var ref = this;
          var data = ref.data;
          var compare = ref.compare;
          var item = data[pos];
          while (pos > 0) {
            var parent = pos - 1 >> 1;
            var current = data[parent];
            if (compare(item, current) >= 0) {
              break;
            }
            data[pos] = current;
            pos = parent;
          }
          data[pos] = item;
        };
        TinyQueue.prototype._down = function _down(pos) {
          var ref = this;
          var data = ref.data;
          var compare = ref.compare;
          var halfLength = this.length >> 1;
          var item = data[pos];
          while (pos < halfLength) {
            var left = (pos << 1) + 1;
            var best = data[left];
            var right = left + 1;
            if (right < this.length && compare(data[right], best) < 0) {
              left = right;
              best = data[right];
            }
            if (compare(best, item) >= 0) {
              break;
            }
            data[pos] = best;
            pos = left;
          }
          data[pos] = item;
        };
        function defaultCompare(a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }
        return TinyQueue;
      });
    }
  });

  // node_modules/point-in-polygon/flat.js
  var require_flat = __commonJS({
    "node_modules/point-in-polygon/flat.js"(exports, module) {
      module.exports = function pointInPolygonFlat(point2, vs, start, end) {
        var x2 = point2[0], y2 = point2[1];
        var inside = false;
        if (start === void 0)
          start = 0;
        if (end === void 0)
          end = vs.length;
        var len = (end - start) / 2;
        for (var i = 0, j = len - 1; i < len; j = i++) {
          var xi = vs[start + i * 2 + 0], yi = vs[start + i * 2 + 1];
          var xj = vs[start + j * 2 + 0], yj = vs[start + j * 2 + 1];
          var intersect2 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
          if (intersect2)
            inside = !inside;
        }
        return inside;
      };
    }
  });

  // node_modules/point-in-polygon/nested.js
  var require_nested = __commonJS({
    "node_modules/point-in-polygon/nested.js"(exports, module) {
      module.exports = function pointInPolygonNested(point2, vs, start, end) {
        var x2 = point2[0], y2 = point2[1];
        var inside = false;
        if (start === void 0)
          start = 0;
        if (end === void 0)
          end = vs.length;
        var len = end - start;
        for (var i = 0, j = len - 1; i < len; j = i++) {
          var xi = vs[i + start][0], yi = vs[i + start][1];
          var xj = vs[j + start][0], yj = vs[j + start][1];
          var intersect2 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
          if (intersect2)
            inside = !inside;
        }
        return inside;
      };
    }
  });

  // node_modules/point-in-polygon/index.js
  var require_point_in_polygon = __commonJS({
    "node_modules/point-in-polygon/index.js"(exports, module) {
      var pointInPolygonFlat = require_flat();
      var pointInPolygonNested = require_nested();
      module.exports = function pointInPolygon(point2, vs, start, end) {
        if (vs.length > 0 && Array.isArray(vs[0])) {
          return pointInPolygonNested(point2, vs, start, end);
        } else {
          return pointInPolygonFlat(point2, vs, start, end);
        }
      };
      module.exports.nested = pointInPolygonNested;
      module.exports.flat = pointInPolygonFlat;
    }
  });

  // node_modules/robust-predicates/umd/orient2d.min.js
  var require_orient2d_min = __commonJS({
    "node_modules/robust-predicates/umd/orient2d.min.js"(exports, module) {
      !function(t, e) {
        typeof exports == "object" && typeof module != "undefined" ? e(exports) : typeof define == "function" && define.amd ? define(["exports"], e) : e((t = t || self).predicates = {});
      }(exports, function(t) {
        "use strict";
        const e = 134217729, n = 33306690738754706e-32;
        function r(t2, e3, n2, r2, o2) {
          let f2, i2, u2, c2, s2 = e3[0], a2 = r2[0], d2 = 0, l2 = 0;
          a2 > s2 == a2 > -s2 ? (f2 = s2, s2 = e3[++d2]) : (f2 = a2, a2 = r2[++l2]);
          let p = 0;
          if (d2 < t2 && l2 < n2)
            for (a2 > s2 == a2 > -s2 ? (u2 = f2 - ((i2 = s2 + f2) - s2), s2 = e3[++d2]) : (u2 = f2 - ((i2 = a2 + f2) - a2), a2 = r2[++l2]), f2 = i2, u2 !== 0 && (o2[p++] = u2); d2 < t2 && l2 < n2; )
              a2 > s2 == a2 > -s2 ? (u2 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e3[++d2]) : (u2 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2]), f2 = i2, u2 !== 0 && (o2[p++] = u2);
          for (; d2 < t2; )
            u2 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e3[++d2], f2 = i2, u2 !== 0 && (o2[p++] = u2);
          for (; l2 < n2; )
            u2 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2], f2 = i2, u2 !== 0 && (o2[p++] = u2);
          return f2 === 0 && p !== 0 || (o2[p++] = f2), p;
        }
        function o(t2) {
          return new Float64Array(t2);
        }
        const f = 33306690738754716e-32, i = 22204460492503146e-32, u = 11093356479670487e-47, c = o(4), s = o(8), a = o(12), d = o(16), l = o(4);
        t.orient2d = function(t2, o2, p, b, y2, h) {
          const M = (o2 - h) * (p - y2), x2 = (t2 - y2) * (b - h), j = M - x2;
          if (M === 0 || x2 === 0 || M > 0 != x2 > 0)
            return j;
          const m = Math.abs(M + x2);
          return Math.abs(j) >= f * m ? j : -function(t3, o3, f2, p2, b2, y3, h2) {
            let M2, x3, j2, m2, _, v, w, A, F, O, P, g, k, q, z, B2, C, D;
            const E = t3 - b2, G = f2 - b2, H = o3 - y3, I = p2 - y3;
            _ = (z = (A = E - (w = (v = e * E) - (v - E))) * (O = I - (F = (v = e * I) - (v - I))) - ((q = E * I) - w * F - A * F - w * O)) - (P = z - (C = (A = H - (w = (v = e * H) - (v - H))) * (O = G - (F = (v = e * G) - (v - G))) - ((B2 = H * G) - w * F - A * F - w * O))), c[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), c[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, c[2] = g - (D - _) + (P - _), c[3] = D;
            let J = function(t4, e3) {
              let n2 = e3[0];
              for (let r2 = 1; r2 < t4; r2++)
                n2 += e3[r2];
              return n2;
            }(4, c), K = i * h2;
            if (J >= K || -J >= K)
              return J;
            if (M2 = t3 - (E + (_ = t3 - E)) + (_ - b2), j2 = f2 - (G + (_ = f2 - G)) + (_ - b2), x3 = o3 - (H + (_ = o3 - H)) + (_ - y3), m2 = p2 - (I + (_ = p2 - I)) + (_ - y3), M2 === 0 && x3 === 0 && j2 === 0 && m2 === 0)
              return J;
            if (K = u * h2 + n * Math.abs(J), (J += E * m2 + I * M2 - (H * j2 + G * x3)) >= K || -J >= K)
              return J;
            _ = (z = (A = M2 - (w = (v = e * M2) - (v - M2))) * (O = I - (F = (v = e * I) - (v - I))) - ((q = M2 * I) - w * F - A * F - w * O)) - (P = z - (C = (A = x3 - (w = (v = e * x3) - (v - x3))) * (O = G - (F = (v = e * G) - (v - G))) - ((B2 = x3 * G) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
            const L2 = r(4, c, 4, l, s);
            _ = (z = (A = E - (w = (v = e * E) - (v - E))) * (O = m2 - (F = (v = e * m2) - (v - m2))) - ((q = E * m2) - w * F - A * F - w * O)) - (P = z - (C = (A = H - (w = (v = e * H) - (v - H))) * (O = j2 - (F = (v = e * j2) - (v - j2))) - ((B2 = H * j2) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
            const N = r(L2, s, 4, l, a);
            _ = (z = (A = M2 - (w = (v = e * M2) - (v - M2))) * (O = m2 - (F = (v = e * m2) - (v - m2))) - ((q = M2 * m2) - w * F - A * F - w * O)) - (P = z - (C = (A = x3 - (w = (v = e * x3) - (v - x3))) * (O = j2 - (F = (v = e * j2) - (v - j2))) - ((B2 = x3 * j2) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
            const Q = r(N, a, 4, l, d);
            return d[Q - 1];
          }(t2, o2, p, b, y2, h, m);
        }, t.orient2dfast = function(t2, e3, n2, r2, o2, f2) {
          return (e3 - f2) * (n2 - o2) - (t2 - o2) * (r2 - f2);
        }, Object.defineProperty(t, "__esModule", { value: true });
      });
    }
  });

  // node_modules/concaveman/index.js
  var require_concaveman = __commonJS({
    "node_modules/concaveman/index.js"(exports, module) {
      "use strict";
      var RBush = require_rbush_min();
      var Queue = require_tinyqueue();
      var pointInPolygon = require_point_in_polygon();
      var orient = require_orient2d_min().orient2d;
      if (Queue.default) {
        Queue = Queue.default;
      }
      module.exports = concaveman2;
      module.exports.default = concaveman2;
      function concaveman2(points, concavity, lengthThreshold) {
        concavity = Math.max(0, concavity === void 0 ? 2 : concavity);
        lengthThreshold = lengthThreshold || 0;
        var hull = fastConvexHull(points);
        var tree = new RBush(16);
        tree.toBBox = function(a2) {
          return {
            minX: a2[0],
            minY: a2[1],
            maxX: a2[0],
            maxY: a2[1]
          };
        };
        tree.compareMinX = function(a2, b2) {
          return a2[0] - b2[0];
        };
        tree.compareMinY = function(a2, b2) {
          return a2[1] - b2[1];
        };
        tree.load(points);
        var queue = [];
        for (var i = 0, last; i < hull.length; i++) {
          var p = hull[i];
          tree.remove(p);
          last = insertNode(p, last);
          queue.push(last);
        }
        var segTree = new RBush(16);
        for (i = 0; i < queue.length; i++)
          segTree.insert(updateBBox(queue[i]));
        var sqConcavity = concavity * concavity;
        var sqLenThreshold = lengthThreshold * lengthThreshold;
        while (queue.length) {
          var node = queue.shift();
          var a = node.p;
          var b = node.next.p;
          var sqLen = getSqDist(a, b);
          if (sqLen < sqLenThreshold)
            continue;
          var maxSqLen = sqLen / sqConcavity;
          p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);
          if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {
            queue.push(node);
            queue.push(insertNode(p, node));
            tree.remove(p);
            segTree.remove(node);
            segTree.insert(updateBBox(node));
            segTree.insert(updateBBox(node.next));
          }
        }
        node = last;
        var concave = [];
        do {
          concave.push(node.p);
          node = node.next;
        } while (node !== last);
        concave.push(node.p);
        return concave;
      }
      function findCandidate(tree, a, b, c, d, maxDist, segTree) {
        var queue = new Queue([], compareDist);
        var node = tree.data;
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);
            if (dist > maxDist)
              continue;
            queue.push({
              node: child,
              dist
            });
          }
          while (queue.length && !queue.peek().node.children) {
            var item = queue.pop();
            var p = item.node;
            var d0 = sqSegDist(p, a, b);
            var d1 = sqSegDist(p, c, d);
            if (item.dist < d0 && item.dist < d1 && noIntersections(b, p, segTree) && noIntersections(c, p, segTree))
              return p;
          }
          node = queue.pop();
          if (node)
            node = node.node;
        }
        return null;
      }
      function compareDist(a, b) {
        return a.dist - b.dist;
      }
      function sqSegBoxDist(a, b, bbox2) {
        if (inside(a, bbox2) || inside(b, bbox2))
          return 0;
        var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox2.minX, bbox2.minY, bbox2.maxX, bbox2.minY);
        if (d1 === 0)
          return 0;
        var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox2.minX, bbox2.minY, bbox2.minX, bbox2.maxY);
        if (d2 === 0)
          return 0;
        var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox2.maxX, bbox2.minY, bbox2.maxX, bbox2.maxY);
        if (d3 === 0)
          return 0;
        var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox2.minX, bbox2.maxY, bbox2.maxX, bbox2.maxY);
        if (d4 === 0)
          return 0;
        return Math.min(d1, d2, d3, d4);
      }
      function inside(a, bbox2) {
        return a[0] >= bbox2.minX && a[0] <= bbox2.maxX && a[1] >= bbox2.minY && a[1] <= bbox2.maxY;
      }
      function noIntersections(a, b, segTree) {
        var minX = Math.min(a[0], b[0]);
        var minY = Math.min(a[1], b[1]);
        var maxX = Math.max(a[0], b[0]);
        var maxY = Math.max(a[1], b[1]);
        var edges2 = segTree.search({ minX, minY, maxX, maxY });
        for (var i = 0; i < edges2.length; i++) {
          if (intersects(edges2[i].p, edges2[i].next.p, a, b))
            return false;
        }
        return true;
      }
      function cross(p1, p2, p3) {
        return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
      }
      function intersects(p1, q1, p2, q2) {
        return p1 !== q2 && q1 !== p2 && cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 && cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;
      }
      function updateBBox(node) {
        var p1 = node.p;
        var p2 = node.next.p;
        node.minX = Math.min(p1[0], p2[0]);
        node.minY = Math.min(p1[1], p2[1]);
        node.maxX = Math.max(p1[0], p2[0]);
        node.maxY = Math.max(p1[1], p2[1]);
        return node;
      }
      function fastConvexHull(points) {
        var left = points[0];
        var top = points[0];
        var right = points[0];
        var bottom = points[0];
        for (var i = 0; i < points.length; i++) {
          var p = points[i];
          if (p[0] < left[0])
            left = p;
          if (p[0] > right[0])
            right = p;
          if (p[1] < top[1])
            top = p;
          if (p[1] > bottom[1])
            bottom = p;
        }
        var cull = [left, top, right, bottom];
        var filtered = cull.slice();
        for (i = 0; i < points.length; i++) {
          if (!pointInPolygon(points[i], cull))
            filtered.push(points[i]);
        }
        return convexHull(filtered);
      }
      function insertNode(p, prev) {
        var node = {
          p,
          prev: null,
          next: null,
          minX: 0,
          minY: 0,
          maxX: 0,
          maxY: 0
        };
        if (!prev) {
          node.prev = node;
          node.next = node;
        } else {
          node.next = prev.next;
          node.prev = prev;
          prev.next.prev = node;
          prev.next = node;
        }
        return node;
      }
      function getSqDist(p1, p2) {
        var dx = p1[0] - p2[0], dy = p1[1] - p2[1];
        return dx * dx + dy * dy;
      }
      function sqSegDist(p, p1, p2) {
        var x2 = p1[0], y2 = p1[1], dx = p2[0] - x2, dy = p2[1] - y2;
        if (dx !== 0 || dy !== 0) {
          var t = ((p[0] - x2) * dx + (p[1] - y2) * dy) / (dx * dx + dy * dy);
          if (t > 1) {
            x2 = p2[0];
            y2 = p2[1];
          } else if (t > 0) {
            x2 += dx * t;
            y2 += dy * t;
          }
        }
        dx = p[0] - x2;
        dy = p[1] - y2;
        return dx * dx + dy * dy;
      }
      function sqSegSegDist(x02, y0, x12, y1, x2, y2, x3, y3) {
        var ux = x12 - x02;
        var uy = y1 - y0;
        var vx = x3 - x2;
        var vy = y3 - y2;
        var wx = x02 - x2;
        var wy = y0 - y2;
        var a = ux * ux + uy * uy;
        var b = ux * vx + uy * vy;
        var c = vx * vx + vy * vy;
        var d = ux * wx + uy * wy;
        var e = vx * wx + vy * wy;
        var D = a * c - b * b;
        var sc, sN, tc, tN;
        var sD = D;
        var tD = D;
        if (D === 0) {
          sN = 0;
          sD = 1;
          tN = e;
          tD = c;
        } else {
          sN = b * e - c * d;
          tN = a * e - b * d;
          if (sN < 0) {
            sN = 0;
            tN = e;
            tD = c;
          } else if (sN > sD) {
            sN = sD;
            tN = e + b;
            tD = c;
          }
        }
        if (tN < 0) {
          tN = 0;
          if (-d < 0)
            sN = 0;
          else if (-d > a)
            sN = sD;
          else {
            sN = -d;
            sD = a;
          }
        } else if (tN > tD) {
          tN = tD;
          if (-d + b < 0)
            sN = 0;
          else if (-d + b > a)
            sN = sD;
          else {
            sN = -d + b;
            sD = a;
          }
        }
        sc = sN === 0 ? 0 : sN / sD;
        tc = tN === 0 ? 0 : tN / tD;
        var cx = (1 - sc) * x02 + sc * x12;
        var cy = (1 - sc) * y0 + sc * y1;
        var cx2 = (1 - tc) * x2 + tc * x3;
        var cy2 = (1 - tc) * y2 + tc * y3;
        var dx = cx2 - cx;
        var dy = cy2 - cy;
        return dx * dx + dy * dy;
      }
      function compareByX(a, b) {
        return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
      }
      function convexHull(points) {
        points.sort(compareByX);
        var lower = [];
        for (var i = 0; i < points.length; i++) {
          while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
            lower.pop();
          }
          lower.push(points[i]);
        }
        var upper = [];
        for (var ii = points.length - 1; ii >= 0; ii--) {
          while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {
            upper.pop();
          }
          upper.push(points[ii]);
        }
        upper.pop();
        lower.pop();
        return lower.concat(upper);
      }
    }
  });

  // node_modules/quickselect/quickselect.js
  var require_quickselect = __commonJS({
    "node_modules/quickselect/quickselect.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.quickselect = factory();
      })(exports, function() {
        "use strict";
        function quickselect(arr, k, left, right, compare) {
          quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
        }
        function quickselectStep(arr, k, left, right, compare) {
          while (right > left) {
            if (right - left > 600) {
              var n = right - left + 1;
              var m = k - left + 1;
              var z = Math.log(n);
              var s = 0.5 * Math.exp(2 * z / 3);
              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
              quickselectStep(arr, k, newLeft, newRight, compare);
            }
            var t = arr[k];
            var i = left;
            var j = right;
            swap(arr, left, k);
            if (compare(arr[right], t) > 0)
              swap(arr, left, right);
            while (i < j) {
              swap(arr, i, j);
              i++;
              j--;
              while (compare(arr[i], t) < 0)
                i++;
              while (compare(arr[j], t) > 0)
                j--;
            }
            if (compare(arr[left], t) === 0)
              swap(arr, left, j);
            else {
              j++;
              swap(arr, j, right);
            }
            if (j <= k)
              left = j + 1;
            if (k <= j)
              right = j - 1;
          }
        }
        function swap(arr, i, j) {
          var tmp = arr[i];
          arr[i] = arr[j];
          arr[j] = tmp;
        }
        function defaultCompare(a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }
        return quickselect;
      });
    }
  });

  // node_modules/rbush/index.js
  var require_rbush = __commonJS({
    "node_modules/rbush/index.js"(exports, module) {
      "use strict";
      module.exports = rbush6;
      module.exports.default = rbush6;
      var quickselect = require_quickselect();
      function rbush6(maxEntries, format) {
        if (!(this instanceof rbush6))
          return new rbush6(maxEntries, format);
        this._maxEntries = Math.max(4, maxEntries || 9);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        if (format) {
          this._initFormat(format);
        }
        this.clear();
      }
      rbush6.prototype = {
        all: function() {
          return this._all(this.data, []);
        },
        search: function(bbox2) {
          var node = this.data, result = [], toBBox = this.toBBox;
          if (!intersects(bbox2, node))
            return result;
          var nodesToSearch = [], i, len, child, childBBox;
          while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              childBBox = node.leaf ? toBBox(child) : child;
              if (intersects(bbox2, childBBox)) {
                if (node.leaf)
                  result.push(child);
                else if (contains(bbox2, childBBox))
                  this._all(child, result);
                else
                  nodesToSearch.push(child);
              }
            }
            node = nodesToSearch.pop();
          }
          return result;
        },
        collides: function(bbox2) {
          var node = this.data, toBBox = this.toBBox;
          if (!intersects(bbox2, node))
            return false;
          var nodesToSearch = [], i, len, child, childBBox;
          while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              childBBox = node.leaf ? toBBox(child) : child;
              if (intersects(bbox2, childBBox)) {
                if (node.leaf || contains(bbox2, childBBox))
                  return true;
                nodesToSearch.push(child);
              }
            }
            node = nodesToSearch.pop();
          }
          return false;
        },
        load: function(data) {
          if (!(data && data.length))
            return this;
          if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
              this.insert(data[i]);
            }
            return this;
          }
          var node = this._build(data.slice(), 0, data.length - 1, 0);
          if (!this.data.children.length) {
            this.data = node;
          } else if (this.data.height === node.height) {
            this._splitRoot(this.data, node);
          } else {
            if (this.data.height < node.height) {
              var tmpNode = this.data;
              this.data = node;
              node = tmpNode;
            }
            this._insert(node, this.data.height - node.height - 1, true);
          }
          return this;
        },
        insert: function(item) {
          if (item)
            this._insert(item, this.data.height - 1);
          return this;
        },
        clear: function() {
          this.data = createNode([]);
          return this;
        },
        remove: function(item, equalsFn) {
          if (!item)
            return this;
          var node = this.data, bbox2 = this.toBBox(item), path = [], indexes = [], i, parent, index, goingUp;
          while (node || path.length) {
            if (!node) {
              node = path.pop();
              parent = path[path.length - 1];
              i = indexes.pop();
              goingUp = true;
            }
            if (node.leaf) {
              index = findItem(item, node.children, equalsFn);
              if (index !== -1) {
                node.children.splice(index, 1);
                path.push(node);
                this._condense(path);
                return this;
              }
            }
            if (!goingUp && !node.leaf && contains(node, bbox2)) {
              path.push(node);
              indexes.push(i);
              i = 0;
              parent = node;
              node = node.children[0];
            } else if (parent) {
              i++;
              node = parent.children[i];
              goingUp = false;
            } else
              node = null;
          }
          return this;
        },
        toBBox: function(item) {
          return item;
        },
        compareMinX: compareNodeMinX,
        compareMinY: compareNodeMinY,
        toJSON: function() {
          return this.data;
        },
        fromJSON: function(data) {
          this.data = data;
          return this;
        },
        _all: function(node, result) {
          var nodesToSearch = [];
          while (node) {
            if (node.leaf)
              result.push.apply(result, node.children);
            else
              nodesToSearch.push.apply(nodesToSearch, node.children);
            node = nodesToSearch.pop();
          }
          return result;
        },
        _build: function(items, left, right, height) {
          var N = right - left + 1, M = this._maxEntries, node;
          if (N <= M) {
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
          }
          if (!height) {
            height = Math.ceil(Math.log(N) / Math.log(M));
            M = Math.ceil(N / Math.pow(M, height - 1));
          }
          node = createNode([]);
          node.leaf = false;
          node.height = height;
          var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
          multiSelect(items, left, right, N1, this.compareMinX);
          for (i = left; i <= right; i += N1) {
            right2 = Math.min(i + N1 - 1, right);
            multiSelect(items, i, right2, N2, this.compareMinY);
            for (j = i; j <= right2; j += N2) {
              right3 = Math.min(j + N2 - 1, right2);
              node.children.push(this._build(items, j, right3, height - 1));
            }
          }
          calcBBox(node, this.toBBox);
          return node;
        },
        _chooseSubtree: function(bbox2, node, level, path) {
          var i, len, child, targetNode, area2, enlargement, minArea, minEnlargement;
          while (true) {
            path.push(node);
            if (node.leaf || path.length - 1 === level)
              break;
            minArea = minEnlargement = Infinity;
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              area2 = bboxArea(child);
              enlargement = enlargedArea(bbox2, child) - area2;
              if (enlargement < minEnlargement) {
                minEnlargement = enlargement;
                minArea = area2 < minArea ? area2 : minArea;
                targetNode = child;
              } else if (enlargement === minEnlargement) {
                if (area2 < minArea) {
                  minArea = area2;
                  targetNode = child;
                }
              }
            }
            node = targetNode || node.children[0];
          }
          return node;
        },
        _insert: function(item, level, isNode) {
          var toBBox = this.toBBox, bbox2 = isNode ? item : toBBox(item), insertPath = [];
          var node = this._chooseSubtree(bbox2, this.data, level, insertPath);
          node.children.push(item);
          extend(node, bbox2);
          while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
              this._split(insertPath, level);
              level--;
            } else
              break;
          }
          this._adjustParentBBoxes(bbox2, insertPath, level);
        },
        _split: function(insertPath, level) {
          var node = insertPath[level], M = node.children.length, m = this._minEntries;
          this._chooseSplitAxis(node, m, M);
          var splitIndex = this._chooseSplitIndex(node, m, M);
          var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
          newNode.height = node.height;
          newNode.leaf = node.leaf;
          calcBBox(node, this.toBBox);
          calcBBox(newNode, this.toBBox);
          if (level)
            insertPath[level - 1].children.push(newNode);
          else
            this._splitRoot(node, newNode);
        },
        _splitRoot: function(node, newNode) {
          this.data = createNode([node, newNode]);
          this.data.height = node.height + 1;
          this.data.leaf = false;
          calcBBox(this.data, this.toBBox);
        },
        _chooseSplitIndex: function(node, m, M) {
          var i, bbox1, bbox2, overlap, area2, minOverlap, minArea, index;
          minOverlap = minArea = Infinity;
          for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);
            overlap = intersectionArea(bbox1, bbox2);
            area2 = bboxArea(bbox1) + bboxArea(bbox2);
            if (overlap < minOverlap) {
              minOverlap = overlap;
              index = i;
              minArea = area2 < minArea ? area2 : minArea;
            } else if (overlap === minOverlap) {
              if (area2 < minArea) {
                minArea = area2;
                index = i;
              }
            }
          }
          return index;
        },
        _chooseSplitAxis: function(node, m, M) {
          var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);
          if (xMargin < yMargin)
            node.children.sort(compareMinX);
        },
        _allDistMargin: function(node, m, M, compare) {
          node.children.sort(compare);
          var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
          for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
          }
          for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
          }
          return margin;
        },
        _adjustParentBBoxes: function(bbox2, path, level) {
          for (var i = level; i >= 0; i--) {
            extend(path[i], bbox2);
          }
        },
        _condense: function(path) {
          for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
              if (i > 0) {
                siblings = path[i - 1].children;
                siblings.splice(siblings.indexOf(path[i]), 1);
              } else
                this.clear();
            } else
              calcBBox(path[i], this.toBBox);
          }
        },
        _initFormat: function(format) {
          var compareArr = ["return a", " - b", ";"];
          this.compareMinX = new Function("a", "b", compareArr.join(format[0]));
          this.compareMinY = new Function("a", "b", compareArr.join(format[1]));
          this.toBBox = new Function("a", "return {minX: a" + format[0] + ", minY: a" + format[1] + ", maxX: a" + format[2] + ", maxY: a" + format[3] + "};");
        }
      };
      function findItem(item, items, equalsFn) {
        if (!equalsFn)
          return items.indexOf(item);
        for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i]))
            return i;
        }
        return -1;
      }
      function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
      }
      function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode)
          destNode = createNode(null);
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
        for (var i = k, child; i < p; i++) {
          child = node.children[i];
          extend(destNode, node.leaf ? toBBox(child) : child);
        }
        return destNode;
      }
      function extend(a, b) {
        a.minX = Math.min(a.minX, b.minX);
        a.minY = Math.min(a.minY, b.minY);
        a.maxX = Math.max(a.maxX, b.maxX);
        a.maxY = Math.max(a.maxY, b.maxY);
        return a;
      }
      function compareNodeMinX(a, b) {
        return a.minX - b.minX;
      }
      function compareNodeMinY(a, b) {
        return a.minY - b.minY;
      }
      function bboxArea(a) {
        return (a.maxX - a.minX) * (a.maxY - a.minY);
      }
      function bboxMargin(a) {
        return a.maxX - a.minX + (a.maxY - a.minY);
      }
      function enlargedArea(a, b) {
        return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
      }
      function intersectionArea(a, b) {
        var minX = Math.max(a.minX, b.minX), minY = Math.max(a.minY, b.minY), maxX = Math.min(a.maxX, b.maxX), maxY = Math.min(a.maxY, b.maxY);
        return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
      }
      function contains(a, b) {
        return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
      }
      function intersects(a, b) {
        return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
      }
      function createNode(children) {
        return {
          children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      function multiSelect(arr, left, right, n, compare) {
        var stack = [left, right], mid;
        while (stack.length) {
          right = stack.pop();
          left = stack.pop();
          if (right - left <= n)
            continue;
          mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare);
          stack.push(left, mid, mid, right);
        }
      }
    }
  });

  // node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "node_modules/earcut/src/earcut.js"(exports, module) {
      "use strict";
      module.exports = earcut2;
      module.exports.default = earcut2;
      function earcut2(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x2, y2, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i = dim; i < outerLen; i += dim) {
            x2 = data[i];
            y2 = data[i + 1];
            if (x2 < minX)
              minX = x2;
            if (y2 < minY)
              minY = y2;
            if (x2 > maxX)
              maxX = x2;
            if (y2 > maxY)
              maxY = y2;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
      }
      function linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === signedArea(data, start, end, dim) > 0) {
          for (i = start; i < end; i += dim)
            last = insertNode(i, data[i], data[i + 1], last);
        } else {
          for (i = end - dim; i >= start; i -= dim)
            last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        var p = start, again;
        do {
          again = false;
          if (!p.steiner && (equals(p, p.next) || area2(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next)
              break;
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area2(a, b, c) >= 0)
          return false;
        var p = ear.next.next;
        while (p !== ear.prev) {
          if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
            return false;
          p = p.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area2(a, b, c) >= 0)
          return false;
        var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
        var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        while (p && p.z >= minZ && n && n.z <= maxZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
          if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        while (p && p.z >= minZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
        }
        while (n && n.z <= maxZ) {
          if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
          var a = p.prev, b = p.next.next;
          if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            removeNode(p);
            removeNode(p.next);
            p = start = b;
          }
          p = p.next;
        } while (p !== start);
        return filterPoints(p);
      }
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        var a = start;
        do {
          var b = a.next.next;
          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
              var c = splitPolygon(a, b);
              a = filterPoints(a, a.next);
              c = filterPoints(c, c.next);
              earcutLinked(a, triangles, dim, minX, minY, invSize);
              earcutLinked(c, triangles, dim, minX, minY, invSize);
              return;
            }
            b = b.next;
          }
          a = a.next;
        } while (a !== start);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i = 0; i < queue.length; i++) {
          outerNode = eliminateHole(queue[i], outerNode);
          outerNode = filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
      }
      function compareX(a, b) {
        return a.x - b.x;
      }
      function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon(bridge, hole);
        var filteredBridge = filterPoints(bridge, bridge.next);
        filterPoints(bridgeReverse, bridgeReverse.next);
        return outerNode === bridge ? filteredBridge : outerNode;
      }
      function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        do {
          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x2 = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x2 <= hx && x2 > qx) {
              qx = x2;
              if (x2 === hx) {
                if (hy === p.y)
                  return p;
                if (hy === p.next.y)
                  return p.next;
              }
              m = p.x < p.next.x ? p : p.next;
            }
          }
          p = p.next;
        } while (p !== outerNode);
        if (!m)
          return null;
        if (hx === qx)
          return m;
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan2;
        p = m;
        do {
          if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan2 = Math.abs(hy - p.y) / (hx - p.x);
            if (locallyInside(p, hole) && (tan2 < tanMin || tan2 === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
              m = p;
              tanMin = tan2;
            }
          }
          p = p.next;
        } while (p !== stop);
        return m;
      }
      function sectorContainsSector(m, p) {
        return area2(m.prev, m, p.prev) < 0 && area2(p.next, m, m.next) < 0;
      }
      function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
          if (p.z === null)
            p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }
      function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e;
              else
                list = e;
              e.prevZ = tail;
              tail = e;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x2, y2, minX, minY, invSize) {
        x2 = 32767 * (x2 - minX) * invSize;
        y2 = 32767 * (y2 - minY) * invSize;
        x2 = (x2 | x2 << 8) & 16711935;
        x2 = (x2 | x2 << 4) & 252645135;
        x2 = (x2 | x2 << 2) & 858993459;
        x2 = (x2 | x2 << 1) & 1431655765;
        y2 = (y2 | y2 << 8) & 16711935;
        y2 = (y2 | y2 << 4) & 252645135;
        y2 = (y2 | y2 << 2) & 858993459;
        y2 = (y2 | y2 << 1) & 1431655765;
        return x2 | y2 << 1;
      }
      function getLeftmost(start) {
        var p = start, leftmost = start;
        do {
          if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
            leftmost = p;
          p = p.next;
        } while (p !== start);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
      }
      function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area2(a.prev, a, b.prev) || area2(a, b.prev, b)) || equals(a, b) && area2(a.prev, a, a.next) > 0 && area2(b.prev, b, b.next) > 0);
      }
      function area2(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        var o1 = sign2(area2(p1, q1, p2));
        var o2 = sign2(area2(p1, q1, q2));
        var o3 = sign2(area2(p2, q2, p1));
        var o4 = sign2(area2(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
      }
      function sign2(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a, b) {
        var p = a;
        do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
            return true;
          p = p.next;
        } while (p !== a);
        return false;
      }
      function locallyInside(a, b) {
        return area2(a.prev, a, a.next) < 0 ? area2(a, b, a.next) >= 0 && area2(a, a.prev, b) >= 0 : area2(a, b, a.prev) < 0 || area2(a, a.next, b) < 0;
      }
      function middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
          if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
            inside = !inside;
          p = p.next;
        } while (p !== a);
        return inside;
      }
      function splitPolygon(a, b) {
        var a2 = new Node2(a.i, a.x, a.y), b2 = new Node2(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode(i, x2, y2, last) {
        var p = new Node2(i, x2, y2);
        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }
      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
          p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
          p.nextZ.prevZ = p.prevZ;
      }
      function Node2(i, x2, y2) {
        this.i = i;
        this.x = x2;
        this.y = y2;
        this.prev = null;
        this.next = null;
        this.z = null;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut2.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea2 = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea2 -= Math.abs(signedArea(data, start, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
          var a = triangles[i] * dim;
          var b = triangles[i + 1] * dim;
          var c = triangles[i + 2] * dim;
          trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
        }
        return polygonArea2 === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea2) / polygonArea2);
      };
      function signedArea(data, start, end, dim) {
        var sum2 = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
          sum2 += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
          j = i;
        }
        return sum2;
      }
      earcut2.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i = 0; i < data.length; i++) {
          for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++)
              result.vertices.push(data[i][j][d]);
          }
          if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // node_modules/geojson-rbush/node_modules/rbush/rbush.min.js
  var require_rbush_min2 = __commonJS({
    "node_modules/geojson-rbush/node_modules/rbush/rbush.min.js"(exports, module) {
      !function(t, i) {
        typeof exports == "object" && typeof module != "undefined" ? module.exports = i() : typeof define == "function" && define.amd ? define(i) : (t = t || self).RBush = i();
      }(exports, function() {
        "use strict";
        function t(t2, r2, e3, a2, h2) {
          !function t3(n2, r3, e4, a3, h3) {
            for (; a3 > e4; ) {
              if (a3 - e4 > 600) {
                var o2 = a3 - e4 + 1, s2 = r3 - e4 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u2 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m2 = Math.max(e4, Math.floor(r3 - s2 * f2 / o2 + u2)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u2));
                t3(n2, r3, m2, c2, h3);
              }
              var p2 = n2[r3], d2 = e4, x2 = a3;
              for (i(n2, e4, r3), h3(n2[a3], p2) > 0 && i(n2, e4, a3); d2 < x2; ) {
                for (i(n2, d2, x2), d2++, x2--; h3(n2[d2], p2) < 0; )
                  d2++;
                for (; h3(n2[x2], p2) > 0; )
                  x2--;
              }
              h3(n2[e4], p2) === 0 ? i(n2, e4, x2) : i(n2, ++x2, a3), x2 <= r3 && (e4 = x2 + 1), r3 <= x2 && (a3 = x2 - 1);
            }
          }(t2, r2, e3 || 0, a2 || t2.length - 1, h2 || n);
        }
        function i(t2, i2, n2) {
          var r2 = t2[i2];
          t2[i2] = t2[n2], t2[n2] = r2;
        }
        function n(t2, i2) {
          return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
        }
        var r = function(t2) {
          t2 === void 0 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
        };
        function e(t2, i2, n2) {
          if (!n2)
            return i2.indexOf(t2);
          for (var r2 = 0; r2 < i2.length; r2++)
            if (n2(t2, i2[r2]))
              return r2;
          return -1;
        }
        function a(t2, i2) {
          h(t2, 0, t2.children.length, i2, t2);
        }
        function h(t2, i2, n2, r2, e3) {
          e3 || (e3 = p(null)), e3.minX = 1 / 0, e3.minY = 1 / 0, e3.maxX = -1 / 0, e3.maxY = -1 / 0;
          for (var a2 = i2; a2 < n2; a2++) {
            var h2 = t2.children[a2];
            o(e3, t2.leaf ? r2(h2) : h2);
          }
          return e3;
        }
        function o(t2, i2) {
          return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
        }
        function s(t2, i2) {
          return t2.minX - i2.minX;
        }
        function l(t2, i2) {
          return t2.minY - i2.minY;
        }
        function f(t2) {
          return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
        }
        function u(t2) {
          return t2.maxX - t2.minX + (t2.maxY - t2.minY);
        }
        function m(t2, i2) {
          return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
        }
        function c(t2, i2) {
          return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
        }
        function p(t2) {
          return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        }
        function d(i2, n2, r2, e3, a2) {
          for (var h2 = [n2, r2]; h2.length; )
            if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e3)) {
              var o2 = n2 + Math.ceil((r2 - n2) / e3 / 2) * e3;
              t(i2, o2, n2, r2, a2), h2.push(n2, o2, o2, r2);
            }
        }
        return r.prototype.all = function() {
          return this._all(this.data, []);
        }, r.prototype.search = function(t2) {
          var i2 = this.data, n2 = [];
          if (!c(t2, i2))
            return n2;
          for (var r2 = this.toBBox, e3 = []; i2; ) {
            for (var a2 = 0; a2 < i2.children.length; a2++) {
              var h2 = i2.children[a2], o2 = i2.leaf ? r2(h2) : h2;
              c(t2, o2) && (i2.leaf ? n2.push(h2) : m(t2, o2) ? this._all(h2, n2) : e3.push(h2));
            }
            i2 = e3.pop();
          }
          return n2;
        }, r.prototype.collides = function(t2) {
          var i2 = this.data;
          if (!c(t2, i2))
            return false;
          for (var n2 = []; i2; ) {
            for (var r2 = 0; r2 < i2.children.length; r2++) {
              var e3 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e3) : e3;
              if (c(t2, a2)) {
                if (i2.leaf || m(t2, a2))
                  return true;
                n2.push(e3);
              }
            }
            i2 = n2.pop();
          }
          return false;
        }, r.prototype.load = function(t2) {
          if (!t2 || !t2.length)
            return this;
          if (t2.length < this._minEntries) {
            for (var i2 = 0; i2 < t2.length; i2++)
              this.insert(t2[i2]);
            return this;
          }
          var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
          if (this.data.children.length)
            if (this.data.height === n2.height)
              this._splitRoot(this.data, n2);
            else {
              if (this.data.height < n2.height) {
                var r2 = this.data;
                this.data = n2, n2 = r2;
              }
              this._insert(n2, this.data.height - n2.height - 1, true);
            }
          else
            this.data = n2;
          return this;
        }, r.prototype.insert = function(t2) {
          return t2 && this._insert(t2, this.data.height - 1), this;
        }, r.prototype.clear = function() {
          return this.data = p([]), this;
        }, r.prototype.remove = function(t2, i2) {
          if (!t2)
            return this;
          for (var n2, r2, a2, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
            if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h2.leaf) {
              var f2 = e(t2, h2.children, i2);
              if (f2 !== -1)
                return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
            }
            a2 || h2.leaf || !m(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a2 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
          }
          return this;
        }, r.prototype.toBBox = function(t2) {
          return t2;
        }, r.prototype.compareMinX = function(t2, i2) {
          return t2.minX - i2.minX;
        }, r.prototype.compareMinY = function(t2, i2) {
          return t2.minY - i2.minY;
        }, r.prototype.toJSON = function() {
          return this.data;
        }, r.prototype.fromJSON = function(t2) {
          return this.data = t2, this;
        }, r.prototype._all = function(t2, i2) {
          for (var n2 = []; t2; )
            t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
          return i2;
        }, r.prototype._build = function(t2, i2, n2, r2) {
          var e3, h2 = n2 - i2 + 1, o2 = this._maxEntries;
          if (h2 <= o2)
            return a(e3 = p(t2.slice(i2, n2 + 1)), this.toBBox), e3;
          r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e3 = p([])).leaf = false, e3.height = r2;
          var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
          d(t2, i2, n2, l2, this.compareMinX);
          for (var f2 = i2; f2 <= n2; f2 += l2) {
            var u2 = Math.min(f2 + l2 - 1, n2);
            d(t2, f2, u2, s2, this.compareMinY);
            for (var m2 = f2; m2 <= u2; m2 += s2) {
              var c2 = Math.min(m2 + s2 - 1, u2);
              e3.children.push(this._build(t2, m2, c2, r2 - 1));
            }
          }
          return a(e3, this.toBBox), e3;
        }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
          for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
            for (var e3 = 1 / 0, a2 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
              var s2 = i2.children[o2], l2 = f(s2), u2 = (m2 = t2, c2 = s2, (Math.max(c2.maxX, m2.maxX) - Math.min(c2.minX, m2.minX)) * (Math.max(c2.maxY, m2.maxY) - Math.min(c2.minY, m2.minY)) - l2);
              u2 < a2 ? (a2 = u2, e3 = l2 < e3 ? l2 : e3, h2 = s2) : u2 === a2 && l2 < e3 && (e3 = l2, h2 = s2);
            }
            i2 = h2 || i2.children[0];
          }
          var m2, c2;
          return i2;
        }, r.prototype._insert = function(t2, i2, n2) {
          var r2 = n2 ? t2 : this.toBBox(t2), e3 = [], a2 = this._chooseSubtree(r2, this.data, i2, e3);
          for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e3[i2].children.length > this._maxEntries; )
            this._split(e3, i2), i2--;
          this._adjustParentBBoxes(r2, e3, i2);
        }, r.prototype._split = function(t2, i2) {
          var n2 = t2[i2], r2 = n2.children.length, e3 = this._minEntries;
          this._chooseSplitAxis(n2, e3, r2);
          var h2 = this._chooseSplitIndex(n2, e3, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
          o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
        }, r.prototype._splitRoot = function(t2, i2) {
          this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
        }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
          for (var r2, e3, a2, o2, s2, l2, u2, m2 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
            var d2 = h(t2, 0, p2, this.toBBox), x2 = h(t2, p2, n2, this.toBBox), v = (e3 = d2, a2 = x2, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, o2 = Math.max(e3.minX, a2.minX), s2 = Math.max(e3.minY, a2.minY), l2 = Math.min(e3.maxX, a2.maxX), u2 = Math.min(e3.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u2 - s2)), M = f(d2) + f(x2);
            v < m2 ? (m2 = v, r2 = p2, c2 = M < c2 ? M : c2) : v === m2 && M < c2 && (c2 = M, r2 = p2);
          }
          return r2 || n2 - i2;
        }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
          var r2 = t2.leaf ? this.compareMinX : s, e3 = t2.leaf ? this.compareMinY : l;
          this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e3) && t2.children.sort(r2);
        }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
          t2.children.sort(r2);
          for (var e3 = this.toBBox, a2 = h(t2, 0, i2, e3), s2 = h(t2, n2 - i2, n2, e3), l2 = u(a2) + u(s2), f2 = i2; f2 < n2 - i2; f2++) {
            var m2 = t2.children[f2];
            o(a2, t2.leaf ? e3(m2) : m2), l2 += u(a2);
          }
          for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
            var p2 = t2.children[c2];
            o(s2, t2.leaf ? e3(p2) : p2), l2 += u(s2);
          }
          return l2;
        }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
          for (var r2 = n2; r2 >= 0; r2--)
            o(i2[r2], t2);
        }, r.prototype._condense = function(t2) {
          for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--)
            t2[i2].children.length === 0 ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
        }, r;
      });
    }
  });

  // node_modules/@turf/helpers/dist/js/index.js
  var require_js = __commonJS({
    "node_modules/@turf/helpers/dist/js/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.earthRadius = 63710088e-1;
      exports.factors = {
        centimeters: exports.earthRadius * 100,
        centimetres: exports.earthRadius * 100,
        degrees: exports.earthRadius / 111325,
        feet: exports.earthRadius * 3.28084,
        inches: exports.earthRadius * 39.37,
        kilometers: exports.earthRadius / 1e3,
        kilometres: exports.earthRadius / 1e3,
        meters: exports.earthRadius,
        metres: exports.earthRadius,
        miles: exports.earthRadius / 1609.344,
        millimeters: exports.earthRadius * 1e3,
        millimetres: exports.earthRadius * 1e3,
        nauticalmiles: exports.earthRadius / 1852,
        radians: 1,
        yards: exports.earthRadius * 1.0936
      };
      exports.unitsFactors = {
        centimeters: 100,
        centimetres: 100,
        degrees: 1 / 111325,
        feet: 3.28084,
        inches: 39.37,
        kilometers: 1 / 1e3,
        kilometres: 1 / 1e3,
        meters: 1,
        metres: 1,
        miles: 1 / 1609.344,
        millimeters: 1e3,
        millimetres: 1e3,
        nauticalmiles: 1 / 1852,
        radians: 1 / exports.earthRadius,
        yards: 1.0936133
      };
      exports.areaFactors = {
        acres: 247105e-9,
        centimeters: 1e4,
        centimetres: 1e4,
        feet: 10.763910417,
        hectares: 1e-4,
        inches: 1550.003100006,
        kilometers: 1e-6,
        kilometres: 1e-6,
        meters: 1,
        metres: 1,
        miles: 386e-9,
        millimeters: 1e6,
        millimetres: 1e6,
        yards: 1.195990046
      };
      function feature2(geom, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var feat = { type: "Feature" };
        if (options.id === 0 || options.id) {
          feat.id = options.id;
        }
        if (options.bbox) {
          feat.bbox = options.bbox;
        }
        feat.properties = properties || {};
        feat.geometry = geom;
        return feat;
      }
      exports.feature = feature2;
      function geometry(type, coordinates, _options) {
        if (_options === void 0) {
          _options = {};
        }
        switch (type) {
          case "Point":
            return point2(coordinates).geometry;
          case "LineString":
            return lineString2(coordinates).geometry;
          case "Polygon":
            return polygon2(coordinates).geometry;
          case "MultiPoint":
            return multiPoint2(coordinates).geometry;
          case "MultiLineString":
            return multiLineString2(coordinates).geometry;
          case "MultiPolygon":
            return multiPolygon2(coordinates).geometry;
          default:
            throw new Error(type + " is invalid");
        }
      }
      exports.geometry = geometry;
      function point2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        if (!coordinates) {
          throw new Error("coordinates is required");
        }
        if (!Array.isArray(coordinates)) {
          throw new Error("coordinates must be an Array");
        }
        if (coordinates.length < 2) {
          throw new Error("coordinates must be at least 2 numbers long");
        }
        if (!isNumber2(coordinates[0]) || !isNumber2(coordinates[1])) {
          throw new Error("coordinates must contain numbers");
        }
        var geom = {
          type: "Point",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.point = point2;
      function points(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        return featureCollection2(coordinates.map(function(coords) {
          return point2(coords, properties);
        }), options);
      }
      exports.points = points;
      function polygon2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
          var ring = coordinates_1[_i];
          if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
          }
          for (var j = 0; j < ring[ring.length - 1].length; j++) {
            if (ring[ring.length - 1][j] !== ring[0][j]) {
              throw new Error("First and last Position are not equivalent.");
            }
          }
        }
        var geom = {
          type: "Polygon",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.polygon = polygon2;
      function polygons(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        return featureCollection2(coordinates.map(function(coords) {
          return polygon2(coords, properties);
        }), options);
      }
      exports.polygons = polygons;
      function lineString2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        if (coordinates.length < 2) {
          throw new Error("coordinates must be an array of two or more positions");
        }
        var geom = {
          type: "LineString",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.lineString = lineString2;
      function lineStrings(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        return featureCollection2(coordinates.map(function(coords) {
          return lineString2(coords, properties);
        }), options);
      }
      exports.lineStrings = lineStrings;
      function featureCollection2(features, options) {
        if (options === void 0) {
          options = {};
        }
        var fc = { type: "FeatureCollection" };
        if (options.id) {
          fc.id = options.id;
        }
        if (options.bbox) {
          fc.bbox = options.bbox;
        }
        fc.features = features;
        return fc;
      }
      exports.featureCollection = featureCollection2;
      function multiLineString2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "MultiLineString",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.multiLineString = multiLineString2;
      function multiPoint2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "MultiPoint",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.multiPoint = multiPoint2;
      function multiPolygon2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "MultiPolygon",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.multiPolygon = multiPolygon2;
      function geometryCollection2(geometries, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "GeometryCollection",
          geometries
        };
        return feature2(geom, properties, options);
      }
      exports.geometryCollection = geometryCollection2;
      function round(num, precision) {
        if (precision === void 0) {
          precision = 0;
        }
        if (precision && !(precision >= 0)) {
          throw new Error("precision must be a positive number");
        }
        var multiplier = Math.pow(10, precision || 0);
        return Math.round(num * multiplier) / multiplier;
      }
      exports.round = round;
      function radiansToLength2(radians2, units) {
        if (units === void 0) {
          units = "kilometers";
        }
        var factor = exports.factors[units];
        if (!factor) {
          throw new Error(units + " units is invalid");
        }
        return radians2 * factor;
      }
      exports.radiansToLength = radiansToLength2;
      function lengthToRadians2(distance, units) {
        if (units === void 0) {
          units = "kilometers";
        }
        var factor = exports.factors[units];
        if (!factor) {
          throw new Error(units + " units is invalid");
        }
        return distance / factor;
      }
      exports.lengthToRadians = lengthToRadians2;
      function lengthToDegrees2(distance, units) {
        return radiansToDegrees2(lengthToRadians2(distance, units));
      }
      exports.lengthToDegrees = lengthToDegrees2;
      function bearingToAzimuth2(bearing2) {
        var angle = bearing2 % 360;
        if (angle < 0) {
          angle += 360;
        }
        return angle;
      }
      exports.bearingToAzimuth = bearingToAzimuth2;
      function radiansToDegrees2(radians2) {
        var degrees2 = radians2 % (2 * Math.PI);
        return degrees2 * 180 / Math.PI;
      }
      exports.radiansToDegrees = radiansToDegrees2;
      function degreesToRadians2(degrees2) {
        var radians2 = degrees2 % 360;
        return radians2 * Math.PI / 180;
      }
      exports.degreesToRadians = degreesToRadians2;
      function convertLength2(length2, originalUnit, finalUnit) {
        if (originalUnit === void 0) {
          originalUnit = "kilometers";
        }
        if (finalUnit === void 0) {
          finalUnit = "kilometers";
        }
        if (!(length2 >= 0)) {
          throw new Error("length must be a positive number");
        }
        return radiansToLength2(lengthToRadians2(length2, originalUnit), finalUnit);
      }
      exports.convertLength = convertLength2;
      function convertArea(area2, originalUnit, finalUnit) {
        if (originalUnit === void 0) {
          originalUnit = "meters";
        }
        if (finalUnit === void 0) {
          finalUnit = "kilometers";
        }
        if (!(area2 >= 0)) {
          throw new Error("area must be a positive number");
        }
        var startFactor = exports.areaFactors[originalUnit];
        if (!startFactor) {
          throw new Error("invalid original units");
        }
        var finalFactor = exports.areaFactors[finalUnit];
        if (!finalFactor) {
          throw new Error("invalid final units");
        }
        return area2 / startFactor * finalFactor;
      }
      exports.convertArea = convertArea;
      function isNumber2(num) {
        return !isNaN(num) && num !== null && !Array.isArray(num);
      }
      exports.isNumber = isNumber2;
      function isObject2(input) {
        return !!input && input.constructor === Object;
      }
      exports.isObject = isObject2;
      function validateBBox(bbox2) {
        if (!bbox2) {
          throw new Error("bbox is required");
        }
        if (!Array.isArray(bbox2)) {
          throw new Error("bbox must be an Array");
        }
        if (bbox2.length !== 4 && bbox2.length !== 6) {
          throw new Error("bbox must be an Array of 4 or 6 numbers");
        }
        bbox2.forEach(function(num) {
          if (!isNumber2(num)) {
            throw new Error("bbox must only contain numbers");
          }
        });
      }
      exports.validateBBox = validateBBox;
      function validateId(id) {
        if (!id) {
          throw new Error("id is required");
        }
        if (["string", "number"].indexOf(typeof id) === -1) {
          throw new Error("id must be a number or a string");
        }
      }
      exports.validateId = validateId;
    }
  });

  // node_modules/@turf/meta/dist/js/index.js
  var require_js2 = __commonJS({
    "node_modules/@turf/meta/dist/js/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var helpers = require_js();
      function coordEach2(geojson, callback, excludeWrapCoord) {
        if (geojson === null)
          return;
        var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
        for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
          geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
          for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
            var multiFeatureIndex = 0;
            var geometryIndex = 0;
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
            if (geometry === null)
              continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;
            wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
            switch (geomType) {
              case null:
                break;
              case "Point":
                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)
                  return false;
                coordIndex++;
                multiFeatureIndex++;
                break;
              case "LineString":
              case "MultiPoint":
                for (j = 0; j < coords.length; j++) {
                  if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)
                    return false;
                  coordIndex++;
                  if (geomType === "MultiPoint")
                    multiFeatureIndex++;
                }
                if (geomType === "LineString")
                  multiFeatureIndex++;
                break;
              case "Polygon":
              case "MultiLineString":
                for (j = 0; j < coords.length; j++) {
                  for (k = 0; k < coords[j].length - wrapShrink; k++) {
                    if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)
                      return false;
                    coordIndex++;
                  }
                  if (geomType === "MultiLineString")
                    multiFeatureIndex++;
                  if (geomType === "Polygon")
                    geometryIndex++;
                }
                if (geomType === "Polygon")
                  multiFeatureIndex++;
                break;
              case "MultiPolygon":
                for (j = 0; j < coords.length; j++) {
                  geometryIndex = 0;
                  for (k = 0; k < coords[j].length; k++) {
                    for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                      if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)
                        return false;
                      coordIndex++;
                    }
                    geometryIndex++;
                  }
                  multiFeatureIndex++;
                }
                break;
              case "GeometryCollection":
                for (j = 0; j < geometry.geometries.length; j++)
                  if (coordEach2(geometry.geometries[j], callback, excludeWrapCoord) === false)
                    return false;
                break;
              default:
                throw new Error("Unknown Geometry Type");
            }
          }
        }
      }
      function coordReduce2(geojson, callback, initialValue, excludeWrapCoord) {
        var previousValue = initialValue;
        coordEach2(geojson, function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
          if (coordIndex === 0 && initialValue === void 0)
            previousValue = currentCoord;
          else
            previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
        }, excludeWrapCoord);
        return previousValue;
      }
      function propEach(geojson, callback) {
        var i;
        switch (geojson.type) {
          case "FeatureCollection":
            for (i = 0; i < geojson.features.length; i++) {
              if (callback(geojson.features[i].properties, i) === false)
                break;
            }
            break;
          case "Feature":
            callback(geojson.properties, 0);
            break;
        }
      }
      function propReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        propEach(geojson, function(currentProperties, featureIndex) {
          if (featureIndex === 0 && initialValue === void 0)
            previousValue = currentProperties;
          else
            previousValue = callback(previousValue, currentProperties, featureIndex);
        });
        return previousValue;
      }
      function featureEach2(geojson, callback) {
        if (geojson.type === "Feature") {
          callback(geojson, 0);
        } else if (geojson.type === "FeatureCollection") {
          for (var i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i], i) === false)
              break;
          }
        }
      }
      function featureReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        featureEach2(geojson, function(currentFeature, featureIndex) {
          if (featureIndex === 0 && initialValue === void 0)
            previousValue = currentFeature;
          else
            previousValue = callback(previousValue, currentFeature, featureIndex);
        });
        return previousValue;
      }
      function coordAll2(geojson) {
        var coords = [];
        coordEach2(geojson, function(coord) {
          coords.push(coord);
        });
        return coords;
      }
      function geomEach2(geojson, callback) {
        var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
        for (i = 0; i < stop; i++) {
          geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
          featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
          featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
          featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
          for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
            if (geometry === null) {
              if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false)
                return false;
              continue;
            }
            switch (geometry.type) {
              case "Point":
              case "LineString":
              case "MultiPoint":
              case "Polygon":
              case "MultiLineString":
              case "MultiPolygon": {
                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false)
                  return false;
                break;
              }
              case "GeometryCollection": {
                for (j = 0; j < geometry.geometries.length; j++) {
                  if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false)
                    return false;
                }
                break;
              }
              default:
                throw new Error("Unknown Geometry Type");
            }
          }
          featureIndex++;
        }
      }
      function geomReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        geomEach2(geojson, function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
          if (featureIndex === 0 && initialValue === void 0)
            previousValue = currentGeometry;
          else
            previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
        });
        return previousValue;
      }
      function flattenEach2(geojson, callback) {
        geomEach2(geojson, function(geometry, featureIndex, properties, bbox2, id) {
          var type = geometry === null ? null : geometry.type;
          switch (type) {
            case null:
            case "Point":
            case "LineString":
            case "Polygon":
              if (callback(helpers.feature(geometry, properties, { bbox: bbox2, id }), featureIndex, 0) === false)
                return false;
              return;
          }
          var geomType;
          switch (type) {
            case "MultiPoint":
              geomType = "Point";
              break;
            case "MultiLineString":
              geomType = "LineString";
              break;
            case "MultiPolygon":
              geomType = "Polygon";
              break;
          }
          for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
            var coordinate = geometry.coordinates[multiFeatureIndex];
            var geom = {
              type: geomType,
              coordinates: coordinate
            };
            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false)
              return false;
          }
        });
      }
      function flattenReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        flattenEach2(geojson, function(currentFeature, featureIndex, multiFeatureIndex) {
          if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)
            previousValue = currentFeature;
          else
            previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
        });
        return previousValue;
      }
      function segmentEach2(geojson, callback) {
        flattenEach2(geojson, function(feature2, featureIndex, multiFeatureIndex) {
          var segmentIndex = 0;
          if (!feature2.geometry)
            return;
          var type = feature2.geometry.type;
          if (type === "Point" || type === "MultiPoint")
            return;
          var previousCoords;
          var previousFeatureIndex = 0;
          var previousMultiIndex = 0;
          var prevGeomIndex = 0;
          if (coordEach2(feature2, function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
            if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
              previousCoords = currentCoord;
              previousFeatureIndex = featureIndex;
              previousMultiIndex = multiPartIndexCoord;
              prevGeomIndex = geometryIndex;
              segmentIndex = 0;
              return;
            }
            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature2.properties);
            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false)
              return false;
            segmentIndex++;
            previousCoords = currentCoord;
          }) === false)
            return false;
        });
      }
      function segmentReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        var started = false;
        segmentEach2(geojson, function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
          if (started === false && initialValue === void 0)
            previousValue = currentSegment;
          else
            previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
          started = true;
        });
        return previousValue;
      }
      function lineEach(geojson, callback) {
        if (!geojson)
          throw new Error("geojson is required");
        flattenEach2(geojson, function(feature2, featureIndex, multiFeatureIndex) {
          if (feature2.geometry === null)
            return;
          var type = feature2.geometry.type;
          var coords = feature2.geometry.coordinates;
          switch (type) {
            case "LineString":
              if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)
                return false;
              break;
            case "Polygon":
              for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
                if (callback(helpers.lineString(coords[geometryIndex], feature2.properties), featureIndex, multiFeatureIndex, geometryIndex) === false)
                  return false;
              }
              break;
          }
        });
      }
      function lineReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        lineEach(geojson, function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
          if (featureIndex === 0 && initialValue === void 0)
            previousValue = currentLine;
          else
            previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
        });
        return previousValue;
      }
      function findSegment(geojson, options) {
        options = options || {};
        if (!helpers.isObject(options))
          throw new Error("options is invalid");
        var featureIndex = options.featureIndex || 0;
        var multiFeatureIndex = options.multiFeatureIndex || 0;
        var geometryIndex = options.geometryIndex || 0;
        var segmentIndex = options.segmentIndex || 0;
        var properties = options.properties;
        var geometry;
        switch (geojson.type) {
          case "FeatureCollection":
            if (featureIndex < 0)
              featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
          case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            geometry = geojson;
            break;
          default:
            throw new Error("geojson is invalid");
        }
        if (geometry === null)
          return null;
        var coords = geometry.coordinates;
        switch (geometry.type) {
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
            if (segmentIndex < 0)
              segmentIndex = coords.length + segmentIndex - 1;
            return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);
          case "Polygon":
            if (geometryIndex < 0)
              geometryIndex = coords.length + geometryIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
            return helpers.lineString([
              coords[geometryIndex][segmentIndex],
              coords[geometryIndex][segmentIndex + 1]
            ], properties, options);
          case "MultiLineString":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
            return helpers.lineString([
              coords[multiFeatureIndex][segmentIndex],
              coords[multiFeatureIndex][segmentIndex + 1]
            ], properties, options);
          case "MultiPolygon":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0)
              geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
            return helpers.lineString([
              coords[multiFeatureIndex][geometryIndex][segmentIndex],
              coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]
            ], properties, options);
        }
        throw new Error("geojson is invalid");
      }
      function findPoint(geojson, options) {
        options = options || {};
        if (!helpers.isObject(options))
          throw new Error("options is invalid");
        var featureIndex = options.featureIndex || 0;
        var multiFeatureIndex = options.multiFeatureIndex || 0;
        var geometryIndex = options.geometryIndex || 0;
        var coordIndex = options.coordIndex || 0;
        var properties = options.properties;
        var geometry;
        switch (geojson.type) {
          case "FeatureCollection":
            if (featureIndex < 0)
              featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
          case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            geometry = geojson;
            break;
          default:
            throw new Error("geojson is invalid");
        }
        if (geometry === null)
          return null;
        var coords = geometry.coordinates;
        switch (geometry.type) {
          case "Point":
            return helpers.point(coords, properties, options);
          case "MultiPoint":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            return helpers.point(coords[multiFeatureIndex], properties, options);
          case "LineString":
            if (coordIndex < 0)
              coordIndex = coords.length + coordIndex;
            return helpers.point(coords[coordIndex], properties, options);
          case "Polygon":
            if (geometryIndex < 0)
              geometryIndex = coords.length + geometryIndex;
            if (coordIndex < 0)
              coordIndex = coords[geometryIndex].length + coordIndex;
            return helpers.point(coords[geometryIndex][coordIndex], properties, options);
          case "MultiLineString":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (coordIndex < 0)
              coordIndex = coords[multiFeatureIndex].length + coordIndex;
            return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);
          case "MultiPolygon":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0)
              geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (coordIndex < 0)
              coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
            return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
        }
        throw new Error("geojson is invalid");
      }
      exports.coordAll = coordAll2;
      exports.coordEach = coordEach2;
      exports.coordReduce = coordReduce2;
      exports.featureEach = featureEach2;
      exports.featureReduce = featureReduce2;
      exports.findPoint = findPoint;
      exports.findSegment = findSegment;
      exports.flattenEach = flattenEach2;
      exports.flattenReduce = flattenReduce;
      exports.geomEach = geomEach2;
      exports.geomReduce = geomReduce2;
      exports.lineEach = lineEach;
      exports.lineReduce = lineReduce2;
      exports.propEach = propEach;
      exports.propReduce = propReduce;
      exports.segmentEach = segmentEach2;
      exports.segmentReduce = segmentReduce2;
    }
  });

  // node_modules/@turf/bbox/dist/js/index.js
  var require_js3 = __commonJS({
    "node_modules/@turf/bbox/dist/js/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var meta_1 = require_js2();
      function bbox2(geojson) {
        var result = [Infinity, Infinity, -Infinity, -Infinity];
        meta_1.coordEach(geojson, function(coord) {
          if (result[0] > coord[0]) {
            result[0] = coord[0];
          }
          if (result[1] > coord[1]) {
            result[1] = coord[1];
          }
          if (result[2] < coord[0]) {
            result[2] = coord[0];
          }
          if (result[3] < coord[1]) {
            result[3] = coord[1];
          }
        });
        return result;
      }
      bbox2["default"] = bbox2;
      exports.default = bbox2;
    }
  });

  // node_modules/geojson-rbush/index.js
  var require_geojson_rbush = __commonJS({
    "node_modules/geojson-rbush/index.js"(exports, module) {
      var rbush6 = require_rbush_min2();
      var helpers = require_js();
      var meta = require_js2();
      var turfBBox = require_js3().default;
      var featureEach2 = meta.featureEach;
      var coordEach2 = meta.coordEach;
      var polygon2 = helpers.polygon;
      var featureCollection2 = helpers.featureCollection;
      function geojsonRbush(maxEntries) {
        var tree = new rbush6(maxEntries);
        tree.insert = function(feature2) {
          if (feature2.type !== "Feature")
            throw new Error("invalid feature");
          feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
          return rbush6.prototype.insert.call(this, feature2);
        };
        tree.load = function(features) {
          var load = [];
          if (Array.isArray(features)) {
            features.forEach(function(feature2) {
              if (feature2.type !== "Feature")
                throw new Error("invalid features");
              feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
              load.push(feature2);
            });
          } else {
            featureEach2(features, function(feature2) {
              if (feature2.type !== "Feature")
                throw new Error("invalid features");
              feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
              load.push(feature2);
            });
          }
          return rbush6.prototype.load.call(this, load);
        };
        tree.remove = function(feature2, equals) {
          if (feature2.type !== "Feature")
            throw new Error("invalid feature");
          feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
          return rbush6.prototype.remove.call(this, feature2, equals);
        };
        tree.clear = function() {
          return rbush6.prototype.clear.call(this);
        };
        tree.search = function(geojson) {
          var features = rbush6.prototype.search.call(this, this.toBBox(geojson));
          return featureCollection2(features);
        };
        tree.collides = function(geojson) {
          return rbush6.prototype.collides.call(this, this.toBBox(geojson));
        };
        tree.all = function() {
          var features = rbush6.prototype.all.call(this);
          return featureCollection2(features);
        };
        tree.toJSON = function() {
          return rbush6.prototype.toJSON.call(this);
        };
        tree.fromJSON = function(json) {
          return rbush6.prototype.fromJSON.call(this, json);
        };
        tree.toBBox = function(geojson) {
          var bbox2;
          if (geojson.bbox)
            bbox2 = geojson.bbox;
          else if (Array.isArray(geojson) && geojson.length === 4)
            bbox2 = geojson;
          else if (Array.isArray(geojson) && geojson.length === 6)
            bbox2 = [geojson[0], geojson[1], geojson[3], geojson[4]];
          else if (geojson.type === "Feature")
            bbox2 = turfBBox(geojson);
          else if (geojson.type === "FeatureCollection")
            bbox2 = turfBBox(geojson);
          else
            throw new Error("invalid geojson");
          return {
            minX: bbox2[0],
            minY: bbox2[1],
            maxX: bbox2[2],
            maxY: bbox2[3]
          };
        };
        return tree;
      }
      module.exports = geojsonRbush;
      module.exports.default = geojsonRbush;
    }
  });

  // node_modules/object-keys/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/object-keys/isArguments.js"(exports, module) {
      "use strict";
      var toStr = Object.prototype.toString;
      module.exports = function isArguments(value) {
        var str = toStr.call(value);
        var isArgs = str === "[object Arguments]";
        if (!isArgs) {
          isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
        }
        return isArgs;
      };
    }
  });

  // node_modules/object-keys/implementation.js
  var require_implementation = __commonJS({
    "node_modules/object-keys/implementation.js"(exports, module) {
      "use strict";
      var keysShim;
      if (!Object.keys) {
        has = Object.prototype.hasOwnProperty;
        toStr = Object.prototype.toString;
        isArgs = require_isArguments();
        isEnumerable = Object.prototype.propertyIsEnumerable;
        hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
        hasProtoEnumBug = isEnumerable.call(function() {
        }, "prototype");
        dontEnums = [
          "toString",
          "toLocaleString",
          "valueOf",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "constructor"
        ];
        equalsConstructorPrototype = function(o) {
          var ctor = o.constructor;
          return ctor && ctor.prototype === o;
        };
        excludedKeys = {
          $applicationCache: true,
          $console: true,
          $external: true,
          $frame: true,
          $frameElement: true,
          $frames: true,
          $innerHeight: true,
          $innerWidth: true,
          $onmozfullscreenchange: true,
          $onmozfullscreenerror: true,
          $outerHeight: true,
          $outerWidth: true,
          $pageXOffset: true,
          $pageYOffset: true,
          $parent: true,
          $scrollLeft: true,
          $scrollTop: true,
          $scrollX: true,
          $scrollY: true,
          $self: true,
          $webkitIndexedDB: true,
          $webkitStorageInfo: true,
          $window: true
        };
        hasAutomationEqualityBug = function() {
          if (typeof window === "undefined") {
            return false;
          }
          for (var k in window) {
            try {
              if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
                try {
                  equalsConstructorPrototype(window[k]);
                } catch (e) {
                  return true;
                }
              }
            } catch (e) {
              return true;
            }
          }
          return false;
        }();
        equalsConstructorPrototypeIfNotBuggy = function(o) {
          if (typeof window === "undefined" || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(o);
          }
          try {
            return equalsConstructorPrototype(o);
          } catch (e) {
            return false;
          }
        };
        keysShim = function keys(object2) {
          var isObject2 = object2 !== null && typeof object2 === "object";
          var isFunction = toStr.call(object2) === "[object Function]";
          var isArguments = isArgs(object2);
          var isString = isObject2 && toStr.call(object2) === "[object String]";
          var theKeys = [];
          if (!isObject2 && !isFunction && !isArguments) {
            throw new TypeError("Object.keys called on a non-object");
          }
          var skipProto = hasProtoEnumBug && isFunction;
          if (isString && object2.length > 0 && !has.call(object2, 0)) {
            for (var i = 0; i < object2.length; ++i) {
              theKeys.push(String(i));
            }
          }
          if (isArguments && object2.length > 0) {
            for (var j = 0; j < object2.length; ++j) {
              theKeys.push(String(j));
            }
          } else {
            for (var name in object2) {
              if (!(skipProto && name === "prototype") && has.call(object2, name)) {
                theKeys.push(String(name));
              }
            }
          }
          if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object2);
            for (var k = 0; k < dontEnums.length; ++k) {
              if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object2, dontEnums[k])) {
                theKeys.push(dontEnums[k]);
              }
            }
          }
          return theKeys;
        };
      }
      var has;
      var toStr;
      var isArgs;
      var isEnumerable;
      var hasDontEnumBug;
      var hasProtoEnumBug;
      var dontEnums;
      var equalsConstructorPrototype;
      var excludedKeys;
      var hasAutomationEqualityBug;
      var equalsConstructorPrototypeIfNotBuggy;
      module.exports = keysShim;
    }
  });

  // node_modules/object-keys/index.js
  var require_object_keys = __commonJS({
    "node_modules/object-keys/index.js"(exports, module) {
      "use strict";
      var slice2 = Array.prototype.slice;
      var isArgs = require_isArguments();
      var origKeys = Object.keys;
      var keysShim = origKeys ? function keys(o) {
        return origKeys(o);
      } : require_implementation();
      var originalKeys = Object.keys;
      keysShim.shim = function shimObjectKeys() {
        if (Object.keys) {
          var keysWorksWithArguments = function() {
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
          }(1, 2);
          if (!keysWorksWithArguments) {
            Object.keys = function keys(object2) {
              if (isArgs(object2)) {
                return originalKeys(slice2.call(object2));
              }
              return originalKeys(object2);
            };
          }
        } else {
          Object.keys = keysShim;
        }
        return Object.keys || keysShim;
      };
      module.exports = keysShim;
    }
  });

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/has-symbols/shams.js"(exports, module) {
      "use strict";
      module.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "node_modules/has-tostringtag/shams.js"(exports, module) {
      "use strict";
      var hasSymbols = require_shams();
      module.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/has-symbols/index.js"(exports, module) {
      "use strict";
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/function-bind/implementation.js
  var require_implementation2 = __commonJS({
    "node_modules/function-bind/implementation.js"(exports, module) {
      "use strict";
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice2 = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = "[object Function]";
      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice2.call(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(this, args.concat(slice2.call(arguments)));
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(that, args.concat(slice2.call(arguments)));
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs.push("$" + i);
        }
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/function-bind/index.js"(exports, module) {
      "use strict";
      var implementation = require_implementation2();
      module.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/has/src/index.js
  var require_src = __commonJS({
    "node_modules/has/src/index.js"(exports, module) {
      "use strict";
      var bind = require_function_bind();
      module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "node_modules/get-intrinsic/index.js"(exports, module) {
      "use strict";
      var undefined2;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var getProto = Object.getPrototypeOf || function(x2) {
        return x2.__proto__;
      };
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn = require_src();
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "node_modules/call-bind/index.js"(exports, module) {
      "use strict";
      var bind = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = null;
        }
      }
      module.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module.exports, "apply", { value: applyBind });
      } else {
        module.exports.apply = applyBind;
      }
    }
  });

  // node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "node_modules/call-bind/callBound.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "node_modules/is-arguments/index.js"(exports, module) {
      "use strict";
      var hasToStringTag = require_shams2()();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // node_modules/define-properties/index.js
  var require_define_properties = __commonJS({
    "node_modules/define-properties/index.js"(exports, module) {
      "use strict";
      var keys = require_object_keys();
      var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
      var toStr = Object.prototype.toString;
      var concat = Array.prototype.concat;
      var origDefineProperty = Object.defineProperty;
      var isFunction = function(fn) {
        return typeof fn === "function" && toStr.call(fn) === "[object Function]";
      };
      var arePropertyDescriptorsSupported = function() {
        var obj = {};
        try {
          origDefineProperty(obj, "x", { enumerable: false, value: obj });
          for (var _ in obj) {
            return false;
          }
          return obj.x === obj;
        } catch (e) {
          return false;
        }
      };
      var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();
      var defineProperty = function(object2, name, value, predicate) {
        if (name in object2 && (!isFunction(predicate) || !predicate())) {
          return;
        }
        if (supportsDescriptors) {
          origDefineProperty(object2, name, {
            configurable: true,
            enumerable: false,
            value,
            writable: true
          });
        } else {
          object2[name] = value;
        }
      };
      var defineProperties = function(object2, map2) {
        var predicates = arguments.length > 2 ? arguments[2] : {};
        var props = keys(map2);
        if (hasSymbols) {
          props = concat.call(props, Object.getOwnPropertySymbols(map2));
        }
        for (var i = 0; i < props.length; i += 1) {
          defineProperty(object2, props[i], map2[props[i]], predicates[props[i]]);
        }
      };
      defineProperties.supportsDescriptors = !!supportsDescriptors;
      module.exports = defineProperties;
    }
  });

  // node_modules/object-is/implementation.js
  var require_implementation3 = __commonJS({
    "node_modules/object-is/implementation.js"(exports, module) {
      "use strict";
      var numberIsNaN = function(value) {
        return value !== value;
      };
      module.exports = function is(a, b) {
        if (a === 0 && b === 0) {
          return 1 / a === 1 / b;
        }
        if (a === b) {
          return true;
        }
        if (numberIsNaN(a) && numberIsNaN(b)) {
          return true;
        }
        return false;
      };
    }
  });

  // node_modules/object-is/polyfill.js
  var require_polyfill = __commonJS({
    "node_modules/object-is/polyfill.js"(exports, module) {
      "use strict";
      var implementation = require_implementation3();
      module.exports = function getPolyfill() {
        return typeof Object.is === "function" ? Object.is : implementation;
      };
    }
  });

  // node_modules/object-is/shim.js
  var require_shim = __commonJS({
    "node_modules/object-is/shim.js"(exports, module) {
      "use strict";
      var getPolyfill = require_polyfill();
      var define2 = require_define_properties();
      module.exports = function shimObjectIs() {
        var polyfill = getPolyfill();
        define2(Object, { is: polyfill }, {
          is: function testObjectIs() {
            return Object.is !== polyfill;
          }
        });
        return polyfill;
      };
    }
  });

  // node_modules/object-is/index.js
  var require_object_is = __commonJS({
    "node_modules/object-is/index.js"(exports, module) {
      "use strict";
      var define2 = require_define_properties();
      var callBind = require_call_bind();
      var implementation = require_implementation3();
      var getPolyfill = require_polyfill();
      var shim = require_shim();
      var polyfill = callBind(getPolyfill(), Object);
      define2(polyfill, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = polyfill;
    }
  });

  // node_modules/is-regex/index.js
  var require_is_regex = __commonJS({
    "node_modules/is-regex/index.js"(exports, module) {
      "use strict";
      var callBound = require_callBound();
      var hasToStringTag = require_shams2()();
      var has;
      var $exec;
      var isRegexMarker;
      var badStringifier;
      if (hasToStringTag) {
        has = callBound("Object.prototype.hasOwnProperty");
        $exec = callBound("RegExp.prototype.exec");
        isRegexMarker = {};
        throwRegexMarker = function() {
          throw isRegexMarker;
        };
        badStringifier = {
          toString: throwRegexMarker,
          valueOf: throwRegexMarker
        };
        if (typeof Symbol.toPrimitive === "symbol") {
          badStringifier[Symbol.toPrimitive] = throwRegexMarker;
        }
      }
      var throwRegexMarker;
      var $toString = callBound("Object.prototype.toString");
      var gOPD = Object.getOwnPropertyDescriptor;
      var regexClass = "[object RegExp]";
      module.exports = hasToStringTag ? function isRegex(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        var descriptor = gOPD(value, "lastIndex");
        var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
        if (!hasLastIndexDataProperty) {
          return false;
        }
        try {
          $exec(value, badStringifier);
        } catch (e) {
          return e === isRegexMarker;
        }
      } : function isRegex(value) {
        if (!value || typeof value !== "object" && typeof value !== "function") {
          return false;
        }
        return $toString(value) === regexClass;
      };
    }
  });

  // node_modules/regexp.prototype.flags/implementation.js
  var require_implementation4 = __commonJS({
    "node_modules/regexp.prototype.flags/implementation.js"(exports, module) {
      "use strict";
      var $Object = Object;
      var $TypeError = TypeError;
      module.exports = function flags() {
        if (this != null && this !== $Object(this)) {
          throw new $TypeError("RegExp.prototype.flags getter called on non-object");
        }
        var result = "";
        if (this.hasIndices) {
          result += "d";
        }
        if (this.global) {
          result += "g";
        }
        if (this.ignoreCase) {
          result += "i";
        }
        if (this.multiline) {
          result += "m";
        }
        if (this.dotAll) {
          result += "s";
        }
        if (this.unicode) {
          result += "u";
        }
        if (this.sticky) {
          result += "y";
        }
        return result;
      };
    }
  });

  // node_modules/regexp.prototype.flags/polyfill.js
  var require_polyfill2 = __commonJS({
    "node_modules/regexp.prototype.flags/polyfill.js"(exports, module) {
      "use strict";
      var implementation = require_implementation4();
      var supportsDescriptors = require_define_properties().supportsDescriptors;
      var $gOPD = Object.getOwnPropertyDescriptor;
      module.exports = function getPolyfill() {
        if (supportsDescriptors && /a/mig.flags === "gim") {
          var descriptor = $gOPD(RegExp.prototype, "flags");
          if (descriptor && typeof descriptor.get === "function" && typeof /a/.dotAll === "boolean") {
            return descriptor.get;
          }
        }
        return implementation;
      };
    }
  });

  // node_modules/regexp.prototype.flags/shim.js
  var require_shim2 = __commonJS({
    "node_modules/regexp.prototype.flags/shim.js"(exports, module) {
      "use strict";
      var supportsDescriptors = require_define_properties().supportsDescriptors;
      var getPolyfill = require_polyfill2();
      var gOPD = Object.getOwnPropertyDescriptor;
      var defineProperty = Object.defineProperty;
      var TypeErr = TypeError;
      var getProto = Object.getPrototypeOf;
      var regex = /a/;
      module.exports = function shimFlags() {
        if (!supportsDescriptors || !getProto) {
          throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
        }
        var polyfill = getPolyfill();
        var proto = getProto(regex);
        var descriptor = gOPD(proto, "flags");
        if (!descriptor || descriptor.get !== polyfill) {
          defineProperty(proto, "flags", {
            configurable: true,
            enumerable: false,
            get: polyfill
          });
        }
        return polyfill;
      };
    }
  });

  // node_modules/regexp.prototype.flags/index.js
  var require_regexp_prototype = __commonJS({
    "node_modules/regexp.prototype.flags/index.js"(exports, module) {
      "use strict";
      var define2 = require_define_properties();
      var callBind = require_call_bind();
      var implementation = require_implementation4();
      var getPolyfill = require_polyfill2();
      var shim = require_shim2();
      var flagsBound = callBind(getPolyfill());
      define2(flagsBound, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = flagsBound;
    }
  });

  // node_modules/is-date-object/index.js
  var require_is_date_object = __commonJS({
    "node_modules/is-date-object/index.js"(exports, module) {
      "use strict";
      var getDay = Date.prototype.getDay;
      var tryDateObject = function tryDateGetDayCall(value) {
        try {
          getDay.call(value);
          return true;
        } catch (e) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var dateClass = "[object Date]";
      var hasToStringTag = require_shams2()();
      module.exports = function isDateObject(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
      };
    }
  });

  // node_modules/deep-equal/index.js
  var require_deep_equal = __commonJS({
    "node_modules/deep-equal/index.js"(exports, module) {
      var objectKeys = require_object_keys();
      var isArguments = require_is_arguments();
      var is = require_object_is();
      var isRegex = require_is_regex();
      var flags = require_regexp_prototype();
      var isDate = require_is_date_object();
      var getTime = Date.prototype.getTime;
      function deepEqual(actual, expected, options) {
        var opts = options || {};
        if (opts.strict ? is(actual, expected) : actual === expected) {
          return true;
        }
        if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
          return opts.strict ? is(actual, expected) : actual == expected;
        }
        return objEquiv(actual, expected, opts);
      }
      function isUndefinedOrNull(value) {
        return value === null || value === void 0;
      }
      function isBuffer(x2) {
        if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number") {
          return false;
        }
        if (typeof x2.copy !== "function" || typeof x2.slice !== "function") {
          return false;
        }
        if (x2.length > 0 && typeof x2[0] !== "number") {
          return false;
        }
        return true;
      }
      function objEquiv(a, b, opts) {
        var i, key;
        if (typeof a !== typeof b) {
          return false;
        }
        if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) {
          return false;
        }
        if (a.prototype !== b.prototype) {
          return false;
        }
        if (isArguments(a) !== isArguments(b)) {
          return false;
        }
        var aIsRegex = isRegex(a);
        var bIsRegex = isRegex(b);
        if (aIsRegex !== bIsRegex) {
          return false;
        }
        if (aIsRegex || bIsRegex) {
          return a.source === b.source && flags(a) === flags(b);
        }
        if (isDate(a) && isDate(b)) {
          return getTime.call(a) === getTime.call(b);
        }
        var aIsBuffer = isBuffer(a);
        var bIsBuffer = isBuffer(b);
        if (aIsBuffer !== bIsBuffer) {
          return false;
        }
        if (aIsBuffer || bIsBuffer) {
          if (a.length !== b.length) {
            return false;
          }
          for (i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) {
              return false;
            }
          }
          return true;
        }
        if (typeof a !== typeof b) {
          return false;
        }
        try {
          var ka = objectKeys(a);
          var kb = objectKeys(b);
        } catch (e) {
          return false;
        }
        if (ka.length !== kb.length) {
          return false;
        }
        ka.sort();
        kb.sort();
        for (i = ka.length - 1; i >= 0; i--) {
          if (ka[i] != kb[i]) {
            return false;
          }
        }
        for (i = ka.length - 1; i >= 0; i--) {
          key = ka[i];
          if (!deepEqual(a[key], b[key], opts)) {
            return false;
          }
        }
        return true;
      }
      module.exports = deepEqual;
    }
  });

  // node_modules/geojson-equality/index.js
  var require_geojson_equality = __commonJS({
    "node_modules/geojson-equality/index.js"(exports, module) {
      var deepEqual = require_deep_equal();
      var Equality = function(opt) {
        this.precision = opt && opt.precision ? opt.precision : 17;
        this.direction = opt && opt.direction ? opt.direction : false;
        this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;
        this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;
      };
      Equality.prototype.compare = function(g1, g2) {
        if (g1.type !== g2.type || !sameLength(g1, g2))
          return false;
        switch (g1.type) {
          case "Point":
            return this.compareCoord(g1.coordinates, g2.coordinates);
            break;
          case "LineString":
            return this.compareLine(g1.coordinates, g2.coordinates, 0, false);
            break;
          case "Polygon":
            return this.comparePolygon(g1, g2);
            break;
          case "Feature":
            return this.compareFeature(g1, g2);
          default:
            if (g1.type.indexOf("Multi") === 0) {
              var context = this;
              var g1s = explode(g1);
              var g2s = explode(g2);
              return g1s.every(function(g1part) {
                return this.some(function(g2part) {
                  return context.compare(g1part, g2part);
                });
              }, g2s);
            }
        }
        return false;
      };
      function explode(g) {
        return g.coordinates.map(function(part) {
          return {
            type: g.type.replace("Multi", ""),
            coordinates: part
          };
        });
      }
      function sameLength(g1, g2) {
        return g1.hasOwnProperty("coordinates") ? g1.coordinates.length === g2.coordinates.length : g1.length === g2.length;
      }
      Equality.prototype.compareCoord = function(c1, c2) {
        if (c1.length !== c2.length) {
          return false;
        }
        for (var i = 0; i < c1.length; i++) {
          if (c1[i].toFixed(this.precision) !== c2[i].toFixed(this.precision)) {
            return false;
          }
        }
        return true;
      };
      Equality.prototype.compareLine = function(path1, path2, ind, isPoly) {
        if (!sameLength(path1, path2))
          return false;
        var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);
        var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);
        if (isPoly && !this.compareCoord(p1[0], p2[0])) {
          p2 = this.fixStartIndex(p2, p1);
          if (!p2)
            return;
        }
        var sameDirection = this.compareCoord(p1[ind], p2[ind]);
        if (this.direction || sameDirection) {
          return this.comparePath(p1, p2);
        } else {
          if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {
            return this.comparePath(p1.slice().reverse(), p2);
          }
          return false;
        }
      };
      Equality.prototype.fixStartIndex = function(sourcePath, targetPath) {
        var correctPath, ind = -1;
        for (var i = 0; i < sourcePath.length; i++) {
          if (this.compareCoord(sourcePath[i], targetPath[0])) {
            ind = i;
            break;
          }
        }
        if (ind >= 0) {
          correctPath = [].concat(sourcePath.slice(ind, sourcePath.length), sourcePath.slice(1, ind + 1));
        }
        return correctPath;
      };
      Equality.prototype.comparePath = function(p1, p2) {
        var cont = this;
        return p1.every(function(c, i) {
          return cont.compareCoord(c, this[i]);
        }, p2);
      };
      Equality.prototype.comparePolygon = function(g1, g2) {
        if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {
          var holes1 = g1.coordinates.slice(1, g1.coordinates.length);
          var holes2 = g2.coordinates.slice(1, g2.coordinates.length);
          var cont = this;
          return holes1.every(function(h1) {
            return this.some(function(h2) {
              return cont.compareLine(h1, h2, 1, true);
            });
          }, holes2);
        } else {
          return false;
        }
      };
      Equality.prototype.compareFeature = function(g1, g2) {
        if (g1.id !== g2.id || !this.objectComparator(g1.properties, g2.properties) || !this.compareBBox(g1, g2)) {
          return false;
        }
        return this.compare(g1.geometry, g2.geometry);
      };
      Equality.prototype.compareBBox = function(g1, g2) {
        if (!g1.bbox && !g2.bbox || g1.bbox && g2.bbox && this.compareCoord(g1.bbox, g2.bbox)) {
          return true;
        }
        return false;
      };
      Equality.prototype.removePseudo = function(path) {
        return path;
      };
      function objectComparator(obj1, obj2) {
        return deepEqual(obj1, obj2, { strict: true });
      }
      module.exports = Equality;
    }
  });

  // node_modules/density-clustering/lib/DBSCAN.js
  var require_DBSCAN = __commonJS({
    "node_modules/density-clustering/lib/DBSCAN.js"(exports, module) {
      function DBSCAN(dataset, epsilon4, minPts, distanceFunction) {
        this.dataset = [];
        this.epsilon = 1;
        this.minPts = 2;
        this.distance = this._euclideanDistance;
        this.clusters = [];
        this.noise = [];
        this._visited = [];
        this._assigned = [];
        this._datasetLength = 0;
        this._init(dataset, epsilon4, minPts, distanceFunction);
      }
      DBSCAN.prototype.run = function(dataset, epsilon4, minPts, distanceFunction) {
        this._init(dataset, epsilon4, minPts, distanceFunction);
        for (var pointId = 0; pointId < this._datasetLength; pointId++) {
          if (this._visited[pointId] !== 1) {
            this._visited[pointId] = 1;
            var neighbors = this._regionQuery(pointId);
            if (neighbors.length < this.minPts) {
              this.noise.push(pointId);
            } else {
              var clusterId = this.clusters.length;
              this.clusters.push([]);
              this._addToCluster(pointId, clusterId);
              this._expandCluster(clusterId, neighbors);
            }
          }
        }
        return this.clusters;
      };
      DBSCAN.prototype._init = function(dataset, epsilon4, minPts, distance) {
        if (dataset) {
          if (!(dataset instanceof Array)) {
            throw Error("Dataset must be of type array, " + typeof dataset + " given");
          }
          this.dataset = dataset;
          this.clusters = [];
          this.noise = [];
          this._datasetLength = dataset.length;
          this._visited = new Array(this._datasetLength);
          this._assigned = new Array(this._datasetLength);
        }
        if (epsilon4) {
          this.epsilon = epsilon4;
        }
        if (minPts) {
          this.minPts = minPts;
        }
        if (distance) {
          this.distance = distance;
        }
      };
      DBSCAN.prototype._expandCluster = function(clusterId, neighbors) {
        for (var i = 0; i < neighbors.length; i++) {
          var pointId2 = neighbors[i];
          if (this._visited[pointId2] !== 1) {
            this._visited[pointId2] = 1;
            var neighbors2 = this._regionQuery(pointId2);
            if (neighbors2.length >= this.minPts) {
              neighbors = this._mergeArrays(neighbors, neighbors2);
            }
          }
          if (this._assigned[pointId2] !== 1) {
            this._addToCluster(pointId2, clusterId);
          }
        }
      };
      DBSCAN.prototype._addToCluster = function(pointId, clusterId) {
        this.clusters[clusterId].push(pointId);
        this._assigned[pointId] = 1;
      };
      DBSCAN.prototype._regionQuery = function(pointId) {
        var neighbors = [];
        for (var id = 0; id < this._datasetLength; id++) {
          var dist = this.distance(this.dataset[pointId], this.dataset[id]);
          if (dist < this.epsilon) {
            neighbors.push(id);
          }
        }
        return neighbors;
      };
      DBSCAN.prototype._mergeArrays = function(a, b) {
        var len = b.length;
        for (var i = 0; i < len; i++) {
          var P = b[i];
          if (a.indexOf(P) < 0) {
            a.push(P);
          }
        }
        return a;
      };
      DBSCAN.prototype._euclideanDistance = function(p, q) {
        var sum2 = 0;
        var i = Math.min(p.length, q.length);
        while (i--) {
          sum2 += (p[i] - q[i]) * (p[i] - q[i]);
        }
        return Math.sqrt(sum2);
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = DBSCAN;
      }
    }
  });

  // node_modules/density-clustering/lib/KMEANS.js
  var require_KMEANS = __commonJS({
    "node_modules/density-clustering/lib/KMEANS.js"(exports, module) {
      function KMEANS(dataset, k, distance) {
        this.k = 3;
        this.dataset = [];
        this.assignments = [];
        this.centroids = [];
        this.init(dataset, k, distance);
      }
      KMEANS.prototype.init = function(dataset, k, distance) {
        this.assignments = [];
        this.centroids = [];
        if (typeof dataset !== "undefined") {
          this.dataset = dataset;
        }
        if (typeof k !== "undefined") {
          this.k = k;
        }
        if (typeof distance !== "undefined") {
          this.distance = distance;
        }
      };
      KMEANS.prototype.run = function(dataset, k) {
        this.init(dataset, k);
        var len = this.dataset.length;
        for (var i = 0; i < this.k; i++) {
          this.centroids[i] = this.randomCentroid();
        }
        var change = true;
        while (change) {
          change = this.assign();
          for (var centroidId = 0; centroidId < this.k; centroidId++) {
            var mean = new Array(maxDim);
            var count = 0;
            for (var dim = 0; dim < maxDim; dim++) {
              mean[dim] = 0;
            }
            for (var j = 0; j < len; j++) {
              var maxDim = this.dataset[j].length;
              if (centroidId === this.assignments[j]) {
                for (var dim = 0; dim < maxDim; dim++) {
                  mean[dim] += this.dataset[j][dim];
                }
                count++;
              }
            }
            if (count > 0) {
              for (var dim = 0; dim < maxDim; dim++) {
                mean[dim] /= count;
              }
              this.centroids[centroidId] = mean;
            } else {
              this.centroids[centroidId] = this.randomCentroid();
              change = true;
            }
          }
        }
        return this.getClusters();
      };
      KMEANS.prototype.randomCentroid = function() {
        var maxId = this.dataset.length - 1;
        var centroid;
        var id;
        do {
          id = Math.round(Math.random() * maxId);
          centroid = this.dataset[id];
        } while (this.centroids.indexOf(centroid) >= 0);
        return centroid;
      };
      KMEANS.prototype.assign = function() {
        var change = false;
        var len = this.dataset.length;
        var closestCentroid;
        for (var i = 0; i < len; i++) {
          closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);
          if (closestCentroid != this.assignments[i]) {
            this.assignments[i] = closestCentroid;
            change = true;
          }
        }
        return change;
      };
      KMEANS.prototype.getClusters = function() {
        var clusters = new Array(this.k);
        var centroidId;
        for (var pointId = 0; pointId < this.assignments.length; pointId++) {
          centroidId = this.assignments[pointId];
          if (typeof clusters[centroidId] === "undefined") {
            clusters[centroidId] = [];
          }
          clusters[centroidId].push(pointId);
        }
        return clusters;
      };
      KMEANS.prototype.argmin = function(point2, set, f) {
        var min = Number.MAX_VALUE;
        var arg = 0;
        var len = set.length;
        var d;
        for (var i = 0; i < len; i++) {
          d = f(point2, set[i]);
          if (d < min) {
            min = d;
            arg = i;
          }
        }
        return arg;
      };
      KMEANS.prototype.distance = function(p, q) {
        var sum2 = 0;
        var i = Math.min(p.length, q.length);
        while (i--) {
          var diff = p[i] - q[i];
          sum2 += diff * diff;
        }
        return Math.sqrt(sum2);
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = KMEANS;
      }
    }
  });

  // node_modules/density-clustering/lib/PriorityQueue.js
  var require_PriorityQueue = __commonJS({
    "node_modules/density-clustering/lib/PriorityQueue.js"(exports, module) {
      function PriorityQueue(elements, priorities, sorting) {
        this._queue = [];
        this._priorities = [];
        this._sorting = "desc";
        this._init(elements, priorities, sorting);
      }
      PriorityQueue.prototype.insert = function(ele, priority) {
        var indexToInsert = this._queue.length;
        var index = indexToInsert;
        while (index--) {
          var priority2 = this._priorities[index];
          if (this._sorting === "desc") {
            if (priority > priority2) {
              indexToInsert = index;
            }
          } else {
            if (priority < priority2) {
              indexToInsert = index;
            }
          }
        }
        this._insertAt(ele, priority, indexToInsert);
      };
      PriorityQueue.prototype.remove = function(ele) {
        var index = this._queue.length;
        while (index--) {
          var ele2 = this._queue[index];
          if (ele === ele2) {
            this._queue.splice(index, 1);
            this._priorities.splice(index, 1);
            break;
          }
        }
      };
      PriorityQueue.prototype.forEach = function(func) {
        this._queue.forEach(func);
      };
      PriorityQueue.prototype.getElements = function() {
        return this._queue;
      };
      PriorityQueue.prototype.getElementPriority = function(index) {
        return this._priorities[index];
      };
      PriorityQueue.prototype.getPriorities = function() {
        return this._priorities;
      };
      PriorityQueue.prototype.getElementsWithPriorities = function() {
        var result = [];
        for (var i = 0, l = this._queue.length; i < l; i++) {
          result.push([this._queue[i], this._priorities[i]]);
        }
        return result;
      };
      PriorityQueue.prototype._init = function(elements, priorities, sorting) {
        if (elements && priorities) {
          this._queue = [];
          this._priorities = [];
          if (elements.length !== priorities.length) {
            throw new Error("Arrays must have the same length");
          }
          for (var i = 0; i < elements.length; i++) {
            this.insert(elements[i], priorities[i]);
          }
        }
        if (sorting) {
          this._sorting = sorting;
        }
      };
      PriorityQueue.prototype._insertAt = function(ele, priority, index) {
        if (this._queue.length === index) {
          this._queue.push(ele);
          this._priorities.push(priority);
        } else {
          this._queue.splice(index, 0, ele);
          this._priorities.splice(index, 0, priority);
        }
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = PriorityQueue;
      }
    }
  });

  // node_modules/density-clustering/lib/OPTICS.js
  var require_OPTICS = __commonJS({
    "node_modules/density-clustering/lib/OPTICS.js"(exports, module) {
      if (typeof module !== "undefined" && module.exports) {
        PriorityQueue = require_PriorityQueue();
      }
      var PriorityQueue;
      function OPTICS(dataset, epsilon4, minPts, distanceFunction) {
        this.epsilon = 1;
        this.minPts = 1;
        this.distance = this._euclideanDistance;
        this._reachability = [];
        this._processed = [];
        this._coreDistance = 0;
        this._orderedList = [];
        this._init(dataset, epsilon4, minPts, distanceFunction);
      }
      OPTICS.prototype.run = function(dataset, epsilon4, minPts, distanceFunction) {
        this._init(dataset, epsilon4, minPts, distanceFunction);
        for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {
          if (this._processed[pointId] !== 1) {
            this._processed[pointId] = 1;
            this.clusters.push([pointId]);
            var clusterId = this.clusters.length - 1;
            this._orderedList.push(pointId);
            var priorityQueue = new PriorityQueue(null, null, "asc");
            var neighbors = this._regionQuery(pointId);
            if (this._distanceToCore(pointId) !== void 0) {
              this._updateQueue(pointId, neighbors, priorityQueue);
              this._expandCluster(clusterId, priorityQueue);
            }
          }
        }
        return this.clusters;
      };
      OPTICS.prototype.getReachabilityPlot = function() {
        var reachabilityPlot = [];
        for (var i = 0, l = this._orderedList.length; i < l; i++) {
          var pointId = this._orderedList[i];
          var distance = this._reachability[pointId];
          reachabilityPlot.push([pointId, distance]);
        }
        return reachabilityPlot;
      };
      OPTICS.prototype._init = function(dataset, epsilon4, minPts, distance) {
        if (dataset) {
          if (!(dataset instanceof Array)) {
            throw Error("Dataset must be of type array, " + typeof dataset + " given");
          }
          this.dataset = dataset;
          this.clusters = [];
          this._reachability = new Array(this.dataset.length);
          this._processed = new Array(this.dataset.length);
          this._coreDistance = 0;
          this._orderedList = [];
        }
        if (epsilon4) {
          this.epsilon = epsilon4;
        }
        if (minPts) {
          this.minPts = minPts;
        }
        if (distance) {
          this.distance = distance;
        }
      };
      OPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {
        var self2 = this;
        this._coreDistance = this._distanceToCore(pointId);
        neighbors.forEach(function(pointId2) {
          if (self2._processed[pointId2] === void 0) {
            var dist = self2.distance(self2.dataset[pointId], self2.dataset[pointId2]);
            var newReachableDistance = Math.max(self2._coreDistance, dist);
            if (self2._reachability[pointId2] === void 0) {
              self2._reachability[pointId2] = newReachableDistance;
              queue.insert(pointId2, newReachableDistance);
            } else {
              if (newReachableDistance < self2._reachability[pointId2]) {
                self2._reachability[pointId2] = newReachableDistance;
                queue.remove(pointId2);
                queue.insert(pointId2, newReachableDistance);
              }
            }
          }
        });
      };
      OPTICS.prototype._expandCluster = function(clusterId, queue) {
        var queueElements = queue.getElements();
        for (var p = 0, l = queueElements.length; p < l; p++) {
          var pointId = queueElements[p];
          if (this._processed[pointId] === void 0) {
            var neighbors = this._regionQuery(pointId);
            this._processed[pointId] = 1;
            this.clusters[clusterId].push(pointId);
            this._orderedList.push(pointId);
            if (this._distanceToCore(pointId) !== void 0) {
              this._updateQueue(pointId, neighbors, queue);
              this._expandCluster(clusterId, queue);
            }
          }
        }
      };
      OPTICS.prototype._distanceToCore = function(pointId) {
        var l = this.epsilon;
        for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {
          var neighbors = this._regionQuery(pointId, coreDistCand);
          if (neighbors.length >= this.minPts) {
            return coreDistCand;
          }
        }
        return;
      };
      OPTICS.prototype._regionQuery = function(pointId, epsilon4) {
        epsilon4 = epsilon4 || this.epsilon;
        var neighbors = [];
        for (var id = 0, l = this.dataset.length; id < l; id++) {
          if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon4) {
            neighbors.push(id);
          }
        }
        return neighbors;
      };
      OPTICS.prototype._euclideanDistance = function(p, q) {
        var sum2 = 0;
        var i = Math.min(p.length, q.length);
        while (i--) {
          sum2 += (p[i] - q[i]) * (p[i] - q[i]);
        }
        return Math.sqrt(sum2);
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = OPTICS;
      }
    }
  });

  // node_modules/density-clustering/lib/index.js
  var require_lib = __commonJS({
    "node_modules/density-clustering/lib/index.js"(exports, module) {
      if (typeof module !== "undefined" && module.exports) {
        module.exports = {
          DBSCAN: require_DBSCAN(),
          KMEANS: require_KMEANS(),
          OPTICS: require_OPTICS(),
          PriorityQueue: require_PriorityQueue()
        };
      }
    }
  });

  // node_modules/skmeans/dist/node/distance.js
  var require_distance = __commonJS({
    "node_modules/skmeans/dist/node/distance.js"(exports, module) {
      "use strict";
      module.exports = {
        eudist: function eudist(v1, v2, sqrt2) {
          var len = v1.length;
          var sum2 = 0;
          for (var i = 0; i < len; i++) {
            var d = (v1[i] || 0) - (v2[i] || 0);
            sum2 += d * d;
          }
          return sqrt2 ? Math.sqrt(sum2) : sum2;
        },
        mandist: function mandist(v1, v2, sqrt2) {
          var len = v1.length;
          var sum2 = 0;
          for (var i = 0; i < len; i++) {
            sum2 += Math.abs((v1[i] || 0) - (v2[i] || 0));
          }
          return sqrt2 ? Math.sqrt(sum2) : sum2;
        },
        dist: function dist(v1, v2, sqrt2) {
          var d = Math.abs(v1 - v2);
          return sqrt2 ? d : d * d;
        }
      };
    }
  });

  // node_modules/skmeans/dist/node/kinit.js
  var require_kinit = __commonJS({
    "node_modules/skmeans/dist/node/kinit.js"(exports, module) {
      "use strict";
      var Distance = require_distance();
      var eudist = Distance.eudist;
      var dist = Distance.dist;
      module.exports = {
        kmrand: function kmrand(data, k) {
          var map2 = {}, ks = [], t = k << 2;
          var len = data.length;
          var multi = data[0].length > 0;
          while (ks.length < k && t-- > 0) {
            var d = data[Math.floor(Math.random() * len)];
            var key = multi ? d.join("_") : "" + d;
            if (!map2[key]) {
              map2[key] = true;
              ks.push(d);
            }
          }
          if (ks.length < k)
            throw new Error("Error initializating clusters");
          else
            return ks;
        },
        kmpp: function kmpp(data, k) {
          var distance = data[0].length ? eudist : dist;
          var ks = [], len = data.length;
          var multi = data[0].length > 0;
          var map2 = {};
          var c = data[Math.floor(Math.random() * len)];
          var key = multi ? c.join("_") : "" + c;
          ks.push(c);
          map2[key] = true;
          while (ks.length < k) {
            var dists = [], lk = ks.length;
            var dsum = 0, prs = [];
            for (var i = 0; i < len; i++) {
              var min = Infinity;
              for (var j = 0; j < lk; j++) {
                var _dist = distance(data[i], ks[j]);
                if (_dist <= min)
                  min = _dist;
              }
              dists[i] = min;
            }
            for (var _i = 0; _i < len; _i++) {
              dsum += dists[_i];
            }
            for (var _i2 = 0; _i2 < len; _i2++) {
              prs[_i2] = { i: _i2, v: data[_i2], pr: dists[_i2] / dsum, cs: 0 };
            }
            prs.sort(function(a, b) {
              return a.pr - b.pr;
            });
            prs[0].cs = prs[0].pr;
            for (var _i3 = 1; _i3 < len; _i3++) {
              prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;
            }
            var rnd = Math.random();
            var idx = 0;
            while (idx < len - 1 && prs[idx++].cs < rnd) {
            }
            ks.push(prs[idx - 1].v);
          }
          return ks;
        }
      };
    }
  });

  // node_modules/skmeans/dist/node/main.js
  var require_main = __commonJS({
    "node_modules/skmeans/dist/node/main.js"(exports, module) {
      "use strict";
      var Distance = require_distance();
      var ClusterInit = require_kinit();
      var eudist = Distance.eudist;
      var mandist = Distance.mandist;
      var dist = Distance.dist;
      var kmrand = ClusterInit.kmrand;
      var kmpp = ClusterInit.kmpp;
      var MAX = 1e4;
      function init(len, val, v) {
        v = v || [];
        for (var i = 0; i < len; i++) {
          v[i] = val;
        }
        return v;
      }
      function skmeans2(data, k, initial, maxit) {
        var ks = [], old = [], idxs = [], dist2 = [];
        var conv = false, it = maxit || MAX;
        var len = data.length, vlen = data[0].length, multi = vlen > 0;
        var count = [];
        if (!initial) {
          var _idxs = {};
          while (ks.length < k) {
            var idx = Math.floor(Math.random() * len);
            if (!_idxs[idx]) {
              _idxs[idx] = true;
              ks.push(data[idx]);
            }
          }
        } else if (initial == "kmrand") {
          ks = kmrand(data, k);
        } else if (initial == "kmpp") {
          ks = kmpp(data, k);
        } else {
          ks = initial;
        }
        do {
          init(k, 0, count);
          for (var i = 0; i < len; i++) {
            var min = Infinity, _idx = 0;
            for (var j = 0; j < k; j++) {
              var dist2 = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);
              if (dist2 <= min) {
                min = dist2;
                _idx = j;
              }
            }
            idxs[i] = _idx;
            count[_idx]++;
          }
          var sum2 = [], old = [], dif = 0;
          for (var _j = 0; _j < k; _j++) {
            sum2[_j] = multi ? init(vlen, 0, sum2[_j]) : 0;
            old[_j] = ks[_j];
          }
          if (multi) {
            for (var _j2 = 0; _j2 < k; _j2++) {
              ks[_j2] = [];
            }
            for (var _i = 0; _i < len; _i++) {
              var _idx2 = idxs[_i], vsum = sum2[_idx2], vect = data[_i];
              for (var h = 0; h < vlen; h++) {
                vsum[h] += vect[h];
              }
            }
            conv = true;
            for (var _j3 = 0; _j3 < k; _j3++) {
              var ksj = ks[_j3], sumj = sum2[_j3], oldj = old[_j3], cj = count[_j3];
              for (var _h = 0; _h < vlen; _h++) {
                ksj[_h] = sumj[_h] / cj || 0;
              }
              if (conv) {
                for (var _h2 = 0; _h2 < vlen; _h2++) {
                  if (oldj[_h2] != ksj[_h2]) {
                    conv = false;
                    break;
                  }
                }
              }
            }
          } else {
            for (var _i2 = 0; _i2 < len; _i2++) {
              var _idx3 = idxs[_i2];
              sum2[_idx3] += data[_i2];
            }
            for (var _j4 = 0; _j4 < k; _j4++) {
              ks[_j4] = sum2[_j4] / count[_j4] || 0;
            }
            conv = true;
            for (var _j5 = 0; _j5 < k; _j5++) {
              if (old[_j5] != ks[_j5]) {
                conv = false;
                break;
              }
            }
          }
          conv = conv || --it <= 0;
        } while (!conv);
        return {
          it: MAX - it,
          k,
          idxs,
          centroids: ks
        };
      }
      module.exports = skmeans2;
    }
  });

  // node_modules/polygon-clipping/dist/polygon-clipping.umd.js
  var require_polygon_clipping_umd = __commonJS({
    "node_modules/polygon-clipping/dist/polygon-clipping.umd.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.polygonClipping = factory());
      })(exports, function() {
        "use strict";
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties(Constructor, staticProps);
          return Constructor;
        }
        var Node2 = function() {
          function Node3(key, data) {
            this.next = null;
            this.key = key;
            this.data = data;
            this.left = null;
            this.right = null;
          }
          return Node3;
        }();
        function DEFAULT_COMPARE(a, b) {
          return a > b ? 1 : a < b ? -1 : 0;
        }
        function splay(i, t, comparator) {
          var N = new Node2(null, null);
          var l = N;
          var r = N;
          while (true) {
            var cmp2 = comparator(i, t.key);
            if (cmp2 < 0) {
              if (t.left === null)
                break;
              if (comparator(i, t.left.key) < 0) {
                var y2 = t.left;
                t.left = y2.right;
                y2.right = t;
                t = y2;
                if (t.left === null)
                  break;
              }
              r.left = t;
              r = t;
              t = t.left;
            } else if (cmp2 > 0) {
              if (t.right === null)
                break;
              if (comparator(i, t.right.key) > 0) {
                var y2 = t.right;
                t.right = y2.left;
                y2.left = t;
                t = y2;
                if (t.right === null)
                  break;
              }
              l.right = t;
              l = t;
              t = t.right;
            } else
              break;
          }
          l.right = t.left;
          r.left = t.right;
          t.left = N.right;
          t.right = N.left;
          return t;
        }
        function insert(i, data, t, comparator) {
          var node = new Node2(i, data);
          if (t === null) {
            node.left = node.right = null;
            return node;
          }
          t = splay(i, t, comparator);
          var cmp2 = comparator(i, t.key);
          if (cmp2 < 0) {
            node.left = t.left;
            node.right = t;
            t.left = null;
          } else if (cmp2 >= 0) {
            node.right = t.right;
            node.left = t;
            t.right = null;
          }
          return node;
        }
        function split(key, v, comparator) {
          var left = null;
          var right = null;
          if (v) {
            v = splay(key, v, comparator);
            var cmp2 = comparator(v.key, key);
            if (cmp2 === 0) {
              left = v.left;
              right = v.right;
            } else if (cmp2 < 0) {
              right = v.right;
              v.right = null;
              left = v;
            } else {
              left = v.left;
              v.left = null;
              right = v;
            }
          }
          return {
            left,
            right
          };
        }
        function merge(left, right, comparator) {
          if (right === null)
            return left;
          if (left === null)
            return right;
          right = splay(left.key, right, comparator);
          right.left = left;
          return right;
        }
        function printRow(root, prefix, isTail, out, printNode) {
          if (root) {
            out("" + prefix + (isTail ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ") + printNode(root) + "\n");
            var indent = prefix + (isTail ? "    " : "\u2502   ");
            if (root.left)
              printRow(root.left, indent, false, out, printNode);
            if (root.right)
              printRow(root.right, indent, true, out, printNode);
          }
        }
        var Tree = function() {
          function Tree2(comparator) {
            if (comparator === void 0) {
              comparator = DEFAULT_COMPARE;
            }
            this._root = null;
            this._size = 0;
            this._comparator = comparator;
          }
          Tree2.prototype.insert = function(key, data) {
            this._size++;
            return this._root = insert(key, data, this._root, this._comparator);
          };
          Tree2.prototype.add = function(key, data) {
            var node = new Node2(key, data);
            if (this._root === null) {
              node.left = node.right = null;
              this._size++;
              this._root = node;
            }
            var comparator = this._comparator;
            var t = splay(key, this._root, comparator);
            var cmp2 = comparator(key, t.key);
            if (cmp2 === 0)
              this._root = t;
            else {
              if (cmp2 < 0) {
                node.left = t.left;
                node.right = t;
                t.left = null;
              } else if (cmp2 > 0) {
                node.right = t.right;
                node.left = t;
                t.right = null;
              }
              this._size++;
              this._root = node;
            }
            return this._root;
          };
          Tree2.prototype.remove = function(key) {
            this._root = this._remove(key, this._root, this._comparator);
          };
          Tree2.prototype._remove = function(i, t, comparator) {
            var x2;
            if (t === null)
              return null;
            t = splay(i, t, comparator);
            var cmp2 = comparator(i, t.key);
            if (cmp2 === 0) {
              if (t.left === null) {
                x2 = t.right;
              } else {
                x2 = splay(i, t.left, comparator);
                x2.right = t.right;
              }
              this._size--;
              return x2;
            }
            return t;
          };
          Tree2.prototype.pop = function() {
            var node = this._root;
            if (node) {
              while (node.left) {
                node = node.left;
              }
              this._root = splay(node.key, this._root, this._comparator);
              this._root = this._remove(node.key, this._root, this._comparator);
              return {
                key: node.key,
                data: node.data
              };
            }
            return null;
          };
          Tree2.prototype.findStatic = function(key) {
            var current = this._root;
            var compare = this._comparator;
            while (current) {
              var cmp2 = compare(key, current.key);
              if (cmp2 === 0)
                return current;
              else if (cmp2 < 0)
                current = current.left;
              else
                current = current.right;
            }
            return null;
          };
          Tree2.prototype.find = function(key) {
            if (this._root) {
              this._root = splay(key, this._root, this._comparator);
              if (this._comparator(key, this._root.key) !== 0)
                return null;
            }
            return this._root;
          };
          Tree2.prototype.contains = function(key) {
            var current = this._root;
            var compare = this._comparator;
            while (current) {
              var cmp2 = compare(key, current.key);
              if (cmp2 === 0)
                return true;
              else if (cmp2 < 0)
                current = current.left;
              else
                current = current.right;
            }
            return false;
          };
          Tree2.prototype.forEach = function(visitor, ctx) {
            var current = this._root;
            var Q = [];
            var done = false;
            while (!done) {
              if (current !== null) {
                Q.push(current);
                current = current.left;
              } else {
                if (Q.length !== 0) {
                  current = Q.pop();
                  visitor.call(ctx, current);
                  current = current.right;
                } else
                  done = true;
              }
            }
            return this;
          };
          Tree2.prototype.range = function(low, high, fn, ctx) {
            var Q = [];
            var compare = this._comparator;
            var node = this._root;
            var cmp2;
            while (Q.length !== 0 || node) {
              if (node) {
                Q.push(node);
                node = node.left;
              } else {
                node = Q.pop();
                cmp2 = compare(node.key, high);
                if (cmp2 > 0) {
                  break;
                } else if (compare(node.key, low) >= 0) {
                  if (fn.call(ctx, node))
                    return this;
                }
                node = node.right;
              }
            }
            return this;
          };
          Tree2.prototype.keys = function() {
            var keys = [];
            this.forEach(function(_a) {
              var key = _a.key;
              return keys.push(key);
            });
            return keys;
          };
          Tree2.prototype.values = function() {
            var values = [];
            this.forEach(function(_a) {
              var data = _a.data;
              return values.push(data);
            });
            return values;
          };
          Tree2.prototype.min = function() {
            if (this._root)
              return this.minNode(this._root).key;
            return null;
          };
          Tree2.prototype.max = function() {
            if (this._root)
              return this.maxNode(this._root).key;
            return null;
          };
          Tree2.prototype.minNode = function(t) {
            if (t === void 0) {
              t = this._root;
            }
            if (t)
              while (t.left) {
                t = t.left;
              }
            return t;
          };
          Tree2.prototype.maxNode = function(t) {
            if (t === void 0) {
              t = this._root;
            }
            if (t)
              while (t.right) {
                t = t.right;
              }
            return t;
          };
          Tree2.prototype.at = function(index2) {
            var current = this._root;
            var done = false;
            var i = 0;
            var Q = [];
            while (!done) {
              if (current) {
                Q.push(current);
                current = current.left;
              } else {
                if (Q.length > 0) {
                  current = Q.pop();
                  if (i === index2)
                    return current;
                  i++;
                  current = current.right;
                } else
                  done = true;
              }
            }
            return null;
          };
          Tree2.prototype.next = function(d) {
            var root = this._root;
            var successor = null;
            if (d.right) {
              successor = d.right;
              while (successor.left) {
                successor = successor.left;
              }
              return successor;
            }
            var comparator = this._comparator;
            while (root) {
              var cmp2 = comparator(d.key, root.key);
              if (cmp2 === 0)
                break;
              else if (cmp2 < 0) {
                successor = root;
                root = root.left;
              } else
                root = root.right;
            }
            return successor;
          };
          Tree2.prototype.prev = function(d) {
            var root = this._root;
            var predecessor = null;
            if (d.left !== null) {
              predecessor = d.left;
              while (predecessor.right) {
                predecessor = predecessor.right;
              }
              return predecessor;
            }
            var comparator = this._comparator;
            while (root) {
              var cmp2 = comparator(d.key, root.key);
              if (cmp2 === 0)
                break;
              else if (cmp2 < 0)
                root = root.left;
              else {
                predecessor = root;
                root = root.right;
              }
            }
            return predecessor;
          };
          Tree2.prototype.clear = function() {
            this._root = null;
            this._size = 0;
            return this;
          };
          Tree2.prototype.toList = function() {
            return toList(this._root);
          };
          Tree2.prototype.load = function(keys, values, presort) {
            if (values === void 0) {
              values = [];
            }
            if (presort === void 0) {
              presort = false;
            }
            var size = keys.length;
            var comparator = this._comparator;
            if (presort)
              sort(keys, values, 0, size - 1, comparator);
            if (this._root === null) {
              this._root = loadRecursive(keys, values, 0, size);
              this._size = size;
            } else {
              var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
              size = this._size + size;
              this._root = sortedListToBST({
                head: mergedList
              }, 0, size);
            }
            return this;
          };
          Tree2.prototype.isEmpty = function() {
            return this._root === null;
          };
          Object.defineProperty(Tree2.prototype, "size", {
            get: function get() {
              return this._size;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Tree2.prototype, "root", {
            get: function get() {
              return this._root;
            },
            enumerable: true,
            configurable: true
          });
          Tree2.prototype.toString = function(printNode) {
            if (printNode === void 0) {
              printNode = function printNode2(n) {
                return String(n.key);
              };
            }
            var out = [];
            printRow(this._root, "", true, function(v) {
              return out.push(v);
            }, printNode);
            return out.join("");
          };
          Tree2.prototype.update = function(key, newKey, newData) {
            var comparator = this._comparator;
            var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;
            if (comparator(key, newKey) < 0) {
              right = insert(newKey, newData, right, comparator);
            } else {
              left = insert(newKey, newData, left, comparator);
            }
            this._root = merge(left, right, comparator);
          };
          Tree2.prototype.split = function(key) {
            return split(key, this._root, this._comparator);
          };
          return Tree2;
        }();
        function loadRecursive(keys, values, start, end) {
          var size = end - start;
          if (size > 0) {
            var middle = start + Math.floor(size / 2);
            var key = keys[middle];
            var data = values[middle];
            var node = new Node2(key, data);
            node.left = loadRecursive(keys, values, start, middle);
            node.right = loadRecursive(keys, values, middle + 1, end);
            return node;
          }
          return null;
        }
        function createList(keys, values) {
          var head = new Node2(null, null);
          var p = head;
          for (var i = 0; i < keys.length; i++) {
            p = p.next = new Node2(keys[i], values[i]);
          }
          p.next = null;
          return head.next;
        }
        function toList(root) {
          var current = root;
          var Q = [];
          var done = false;
          var head = new Node2(null, null);
          var p = head;
          while (!done) {
            if (current) {
              Q.push(current);
              current = current.left;
            } else {
              if (Q.length > 0) {
                current = p = p.next = Q.pop();
                current = current.right;
              } else
                done = true;
            }
          }
          p.next = null;
          return head.next;
        }
        function sortedListToBST(list, start, end) {
          var size = end - start;
          if (size > 0) {
            var middle = start + Math.floor(size / 2);
            var left = sortedListToBST(list, start, middle);
            var root = list.head;
            root.left = left;
            list.head = list.head.next;
            root.right = sortedListToBST(list, middle + 1, end);
            return root;
          }
          return null;
        }
        function mergeLists(l1, l2, compare) {
          var head = new Node2(null, null);
          var p = head;
          var p1 = l1;
          var p2 = l2;
          while (p1 !== null && p2 !== null) {
            if (compare(p1.key, p2.key) < 0) {
              p.next = p1;
              p1 = p1.next;
            } else {
              p.next = p2;
              p2 = p2.next;
            }
            p = p.next;
          }
          if (p1 !== null) {
            p.next = p1;
          } else if (p2 !== null) {
            p.next = p2;
          }
          return head.next;
        }
        function sort(keys, values, left, right, compare) {
          if (left >= right)
            return;
          var pivot = keys[left + right >> 1];
          var i = left - 1;
          var j = right + 1;
          while (true) {
            do {
              i++;
            } while (compare(keys[i], pivot) < 0);
            do {
              j--;
            } while (compare(keys[j], pivot) > 0);
            if (i >= j)
              break;
            var tmp = keys[i];
            keys[i] = keys[j];
            keys[j] = tmp;
            tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
          }
          sort(keys, values, left, j, compare);
          sort(keys, values, j + 1, right, compare);
        }
        var isInBbox = function isInBbox2(bbox2, point2) {
          return bbox2.ll.x <= point2.x && point2.x <= bbox2.ur.x && bbox2.ll.y <= point2.y && point2.y <= bbox2.ur.y;
        };
        var getBboxOverlap = function getBboxOverlap2(b1, b2) {
          if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y)
            return null;
          var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
          var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;
          var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
          var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;
          return {
            ll: {
              x: lowerX,
              y: lowerY
            },
            ur: {
              x: upperX,
              y: upperY
            }
          };
        };
        var epsilon4 = Number.EPSILON;
        if (epsilon4 === void 0)
          epsilon4 = Math.pow(2, -52);
        var EPSILON_SQ = epsilon4 * epsilon4;
        var cmp = function cmp2(a, b) {
          if (-epsilon4 < a && a < epsilon4) {
            if (-epsilon4 < b && b < epsilon4) {
              return 0;
            }
          }
          var ab = a - b;
          if (ab * ab < EPSILON_SQ * a * b) {
            return 0;
          }
          return a < b ? -1 : 1;
        };
        var PtRounder = /* @__PURE__ */ function() {
          function PtRounder2() {
            _classCallCheck(this, PtRounder2);
            this.reset();
          }
          _createClass(PtRounder2, [{
            key: "reset",
            value: function reset() {
              this.xRounder = new CoordRounder();
              this.yRounder = new CoordRounder();
            }
          }, {
            key: "round",
            value: function round(x2, y2) {
              return {
                x: this.xRounder.round(x2),
                y: this.yRounder.round(y2)
              };
            }
          }]);
          return PtRounder2;
        }();
        var CoordRounder = /* @__PURE__ */ function() {
          function CoordRounder2() {
            _classCallCheck(this, CoordRounder2);
            this.tree = new Tree();
            this.round(0);
          }
          _createClass(CoordRounder2, [{
            key: "round",
            value: function round(coord) {
              var node = this.tree.add(coord);
              var prevNode = this.tree.prev(node);
              if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
                this.tree.remove(coord);
                return prevNode.key;
              }
              var nextNode = this.tree.next(node);
              if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
                this.tree.remove(coord);
                return nextNode.key;
              }
              return coord;
            }
          }]);
          return CoordRounder2;
        }();
        var rounder = new PtRounder();
        var crossProduct = function crossProduct2(a, b) {
          return a.x * b.y - a.y * b.x;
        };
        var dotProduct = function dotProduct2(a, b) {
          return a.x * b.x + a.y * b.y;
        };
        var compareVectorAngles = function compareVectorAngles2(basePt, endPt1, endPt2) {
          var v1 = {
            x: endPt1.x - basePt.x,
            y: endPt1.y - basePt.y
          };
          var v2 = {
            x: endPt2.x - basePt.x,
            y: endPt2.y - basePt.y
          };
          var kross = crossProduct(v1, v2);
          return cmp(kross, 0);
        };
        var length2 = function length3(v) {
          return Math.sqrt(dotProduct(v, v));
        };
        var sineOfAngle = function sineOfAngle2(pShared, pBase, pAngle) {
          var vBase = {
            x: pBase.x - pShared.x,
            y: pBase.y - pShared.y
          };
          var vAngle = {
            x: pAngle.x - pShared.x,
            y: pAngle.y - pShared.y
          };
          return crossProduct(vAngle, vBase) / length2(vAngle) / length2(vBase);
        };
        var cosineOfAngle = function cosineOfAngle2(pShared, pBase, pAngle) {
          var vBase = {
            x: pBase.x - pShared.x,
            y: pBase.y - pShared.y
          };
          var vAngle = {
            x: pAngle.x - pShared.x,
            y: pAngle.y - pShared.y
          };
          return dotProduct(vAngle, vBase) / length2(vAngle) / length2(vBase);
        };
        var horizontalIntersection = function horizontalIntersection2(pt, v, y2) {
          if (v.y === 0)
            return null;
          return {
            x: pt.x + v.x / v.y * (y2 - pt.y),
            y: y2
          };
        };
        var verticalIntersection = function verticalIntersection2(pt, v, x2) {
          if (v.x === 0)
            return null;
          return {
            x: x2,
            y: pt.y + v.y / v.x * (x2 - pt.x)
          };
        };
        var intersection = function intersection2(pt1, v1, pt2, v2) {
          if (v1.x === 0)
            return verticalIntersection(pt2, v2, pt1.x);
          if (v2.x === 0)
            return verticalIntersection(pt1, v1, pt2.x);
          if (v1.y === 0)
            return horizontalIntersection(pt2, v2, pt1.y);
          if (v2.y === 0)
            return horizontalIntersection(pt1, v1, pt2.y);
          var kross = crossProduct(v1, v2);
          if (kross == 0)
            return null;
          var ve = {
            x: pt2.x - pt1.x,
            y: pt2.y - pt1.y
          };
          var d1 = crossProduct(ve, v1) / kross;
          var d2 = crossProduct(ve, v2) / kross;
          var x12 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x;
          var y1 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y;
          var x3 = (x12 + x2) / 2;
          var y3 = (y1 + y2) / 2;
          return {
            x: x3,
            y: y3
          };
        };
        var SweepEvent = /* @__PURE__ */ function() {
          _createClass(SweepEvent2, null, [{
            key: "compare",
            value: function compare(a, b) {
              var ptCmp = SweepEvent2.comparePoints(a.point, b.point);
              if (ptCmp !== 0)
                return ptCmp;
              if (a.point !== b.point)
                a.link(b);
              if (a.isLeft !== b.isLeft)
                return a.isLeft ? 1 : -1;
              return Segment.compare(a.segment, b.segment);
            }
          }, {
            key: "comparePoints",
            value: function comparePoints(aPt, bPt) {
              if (aPt.x < bPt.x)
                return -1;
              if (aPt.x > bPt.x)
                return 1;
              if (aPt.y < bPt.y)
                return -1;
              if (aPt.y > bPt.y)
                return 1;
              return 0;
            }
          }]);
          function SweepEvent2(point2, isLeft) {
            _classCallCheck(this, SweepEvent2);
            if (point2.events === void 0)
              point2.events = [this];
            else
              point2.events.push(this);
            this.point = point2;
            this.isLeft = isLeft;
          }
          _createClass(SweepEvent2, [{
            key: "link",
            value: function link2(other) {
              if (other.point === this.point) {
                throw new Error("Tried to link already linked events");
              }
              var otherEvents = other.point.events;
              for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {
                var evt = otherEvents[i];
                this.point.events.push(evt);
                evt.point = this.point;
              }
              this.checkForConsuming();
            }
          }, {
            key: "checkForConsuming",
            value: function checkForConsuming() {
              var numEvents = this.point.events.length;
              for (var i = 0; i < numEvents; i++) {
                var evt1 = this.point.events[i];
                if (evt1.segment.consumedBy !== void 0)
                  continue;
                for (var j = i + 1; j < numEvents; j++) {
                  var evt2 = this.point.events[j];
                  if (evt2.consumedBy !== void 0)
                    continue;
                  if (evt1.otherSE.point.events !== evt2.otherSE.point.events)
                    continue;
                  evt1.segment.consume(evt2.segment);
                }
              }
            }
          }, {
            key: "getAvailableLinkedEvents",
            value: function getAvailableLinkedEvents() {
              var events = [];
              for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {
                var evt = this.point.events[i];
                if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
                  events.push(evt);
                }
              }
              return events;
            }
          }, {
            key: "getLeftmostComparator",
            value: function getLeftmostComparator(baseEvent) {
              var _this = this;
              var cache = /* @__PURE__ */ new Map();
              var fillCache = function fillCache2(linkedEvent) {
                var nextEvent = linkedEvent.otherSE;
                cache.set(linkedEvent, {
                  sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),
                  cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)
                });
              };
              return function(a, b) {
                if (!cache.has(a))
                  fillCache(a);
                if (!cache.has(b))
                  fillCache(b);
                var _cache$get = cache.get(a), asine = _cache$get.sine, acosine = _cache$get.cosine;
                var _cache$get2 = cache.get(b), bsine = _cache$get2.sine, bcosine = _cache$get2.cosine;
                if (asine >= 0 && bsine >= 0) {
                  if (acosine < bcosine)
                    return 1;
                  if (acosine > bcosine)
                    return -1;
                  return 0;
                }
                if (asine < 0 && bsine < 0) {
                  if (acosine < bcosine)
                    return -1;
                  if (acosine > bcosine)
                    return 1;
                  return 0;
                }
                if (bsine < asine)
                  return -1;
                if (bsine > asine)
                  return 1;
                return 0;
              };
            }
          }]);
          return SweepEvent2;
        }();
        var segmentId = 0;
        var Segment = /* @__PURE__ */ function() {
          _createClass(Segment2, null, [{
            key: "compare",
            value: function compare(a, b) {
              var alx = a.leftSE.point.x;
              var blx = b.leftSE.point.x;
              var arx = a.rightSE.point.x;
              var brx = b.rightSE.point.x;
              if (brx < alx)
                return 1;
              if (arx < blx)
                return -1;
              var aly = a.leftSE.point.y;
              var bly = b.leftSE.point.y;
              var ary = a.rightSE.point.y;
              var bry = b.rightSE.point.y;
              if (alx < blx) {
                if (bly < aly && bly < ary)
                  return 1;
                if (bly > aly && bly > ary)
                  return -1;
                var aCmpBLeft = a.comparePoint(b.leftSE.point);
                if (aCmpBLeft < 0)
                  return 1;
                if (aCmpBLeft > 0)
                  return -1;
                var bCmpARight = b.comparePoint(a.rightSE.point);
                if (bCmpARight !== 0)
                  return bCmpARight;
                return -1;
              }
              if (alx > blx) {
                if (aly < bly && aly < bry)
                  return -1;
                if (aly > bly && aly > bry)
                  return 1;
                var bCmpALeft = b.comparePoint(a.leftSE.point);
                if (bCmpALeft !== 0)
                  return bCmpALeft;
                var aCmpBRight = a.comparePoint(b.rightSE.point);
                if (aCmpBRight < 0)
                  return 1;
                if (aCmpBRight > 0)
                  return -1;
                return 1;
              }
              if (aly < bly)
                return -1;
              if (aly > bly)
                return 1;
              if (arx < brx) {
                var _bCmpARight = b.comparePoint(a.rightSE.point);
                if (_bCmpARight !== 0)
                  return _bCmpARight;
              }
              if (arx > brx) {
                var _aCmpBRight = a.comparePoint(b.rightSE.point);
                if (_aCmpBRight < 0)
                  return 1;
                if (_aCmpBRight > 0)
                  return -1;
              }
              if (arx !== brx) {
                var ay = ary - aly;
                var ax = arx - alx;
                var by = bry - bly;
                var bx = brx - blx;
                if (ay > ax && by < bx)
                  return 1;
                if (ay < ax && by > bx)
                  return -1;
              }
              if (arx > brx)
                return 1;
              if (arx < brx)
                return -1;
              if (ary < bry)
                return -1;
              if (ary > bry)
                return 1;
              if (a.id < b.id)
                return -1;
              if (a.id > b.id)
                return 1;
              return 0;
            }
          }]);
          function Segment2(leftSE, rightSE, rings, windings) {
            _classCallCheck(this, Segment2);
            this.id = ++segmentId;
            this.leftSE = leftSE;
            leftSE.segment = this;
            leftSE.otherSE = rightSE;
            this.rightSE = rightSE;
            rightSE.segment = this;
            rightSE.otherSE = leftSE;
            this.rings = rings;
            this.windings = windings;
          }
          _createClass(Segment2, [{
            key: "replaceRightSE",
            value: function replaceRightSE(newRightSE) {
              this.rightSE = newRightSE;
              this.rightSE.segment = this;
              this.rightSE.otherSE = this.leftSE;
              this.leftSE.otherSE = this.rightSE;
            }
          }, {
            key: "bbox",
            value: function bbox2() {
              var y1 = this.leftSE.point.y;
              var y2 = this.rightSE.point.y;
              return {
                ll: {
                  x: this.leftSE.point.x,
                  y: y1 < y2 ? y1 : y2
                },
                ur: {
                  x: this.rightSE.point.x,
                  y: y1 > y2 ? y1 : y2
                }
              };
            }
          }, {
            key: "vector",
            value: function vector() {
              return {
                x: this.rightSE.point.x - this.leftSE.point.x,
                y: this.rightSE.point.y - this.leftSE.point.y
              };
            }
          }, {
            key: "isAnEndpoint",
            value: function isAnEndpoint(pt) {
              return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
            }
          }, {
            key: "comparePoint",
            value: function comparePoint(point2) {
              if (this.isAnEndpoint(point2))
                return 0;
              var lPt = this.leftSE.point;
              var rPt = this.rightSE.point;
              var v = this.vector();
              if (lPt.x === rPt.x) {
                if (point2.x === lPt.x)
                  return 0;
                return point2.x < lPt.x ? 1 : -1;
              }
              var yDist = (point2.y - lPt.y) / v.y;
              var xFromYDist = lPt.x + yDist * v.x;
              if (point2.x === xFromYDist)
                return 0;
              var xDist = (point2.x - lPt.x) / v.x;
              var yFromXDist = lPt.y + xDist * v.y;
              if (point2.y === yFromXDist)
                return 0;
              return point2.y < yFromXDist ? -1 : 1;
            }
          }, {
            key: "getIntersection",
            value: function getIntersection(other) {
              var tBbox = this.bbox();
              var oBbox = other.bbox();
              var bboxOverlap = getBboxOverlap(tBbox, oBbox);
              if (bboxOverlap === null)
                return null;
              var tlp = this.leftSE.point;
              var trp = this.rightSE.point;
              var olp = other.leftSE.point;
              var orp = other.rightSE.point;
              var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
              var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
              var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
              var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
              if (touchesThisLSE && touchesOtherLSE) {
                if (touchesThisRSE && !touchesOtherRSE)
                  return trp;
                if (!touchesThisRSE && touchesOtherRSE)
                  return orp;
                return null;
              }
              if (touchesThisLSE) {
                if (touchesOtherRSE) {
                  if (tlp.x === orp.x && tlp.y === orp.y)
                    return null;
                }
                return tlp;
              }
              if (touchesOtherLSE) {
                if (touchesThisRSE) {
                  if (trp.x === olp.x && trp.y === olp.y)
                    return null;
                }
                return olp;
              }
              if (touchesThisRSE && touchesOtherRSE)
                return null;
              if (touchesThisRSE)
                return trp;
              if (touchesOtherRSE)
                return orp;
              var pt = intersection(tlp, this.vector(), olp, other.vector());
              if (pt === null)
                return null;
              if (!isInBbox(bboxOverlap, pt))
                return null;
              return rounder.round(pt.x, pt.y);
            }
          }, {
            key: "split",
            value: function split2(point2) {
              var newEvents = [];
              var alreadyLinked = point2.events !== void 0;
              var newLeftSE = new SweepEvent(point2, true);
              var newRightSE = new SweepEvent(point2, false);
              var oldRightSE = this.rightSE;
              this.replaceRightSE(newRightSE);
              newEvents.push(newRightSE);
              newEvents.push(newLeftSE);
              var newSeg = new Segment2(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
              if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
                newSeg.swapEvents();
              }
              if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
                this.swapEvents();
              }
              if (alreadyLinked) {
                newLeftSE.checkForConsuming();
                newRightSE.checkForConsuming();
              }
              return newEvents;
            }
          }, {
            key: "swapEvents",
            value: function swapEvents() {
              var tmpEvt = this.rightSE;
              this.rightSE = this.leftSE;
              this.leftSE = tmpEvt;
              this.leftSE.isLeft = true;
              this.rightSE.isLeft = false;
              for (var i = 0, iMax = this.windings.length; i < iMax; i++) {
                this.windings[i] *= -1;
              }
            }
          }, {
            key: "consume",
            value: function consume(other) {
              var consumer = this;
              var consumee = other;
              while (consumer.consumedBy) {
                consumer = consumer.consumedBy;
              }
              while (consumee.consumedBy) {
                consumee = consumee.consumedBy;
              }
              var cmp2 = Segment2.compare(consumer, consumee);
              if (cmp2 === 0)
                return;
              if (cmp2 > 0) {
                var tmp = consumer;
                consumer = consumee;
                consumee = tmp;
              }
              if (consumer.prev === consumee) {
                var _tmp = consumer;
                consumer = consumee;
                consumee = _tmp;
              }
              for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {
                var ring = consumee.rings[i];
                var winding = consumee.windings[i];
                var index2 = consumer.rings.indexOf(ring);
                if (index2 === -1) {
                  consumer.rings.push(ring);
                  consumer.windings.push(winding);
                } else
                  consumer.windings[index2] += winding;
              }
              consumee.rings = null;
              consumee.windings = null;
              consumee.consumedBy = consumer;
              consumee.leftSE.consumedBy = consumer.leftSE;
              consumee.rightSE.consumedBy = consumer.rightSE;
            }
          }, {
            key: "prevInResult",
            value: function prevInResult() {
              if (this._prevInResult !== void 0)
                return this._prevInResult;
              if (!this.prev)
                this._prevInResult = null;
              else if (this.prev.isInResult())
                this._prevInResult = this.prev;
              else
                this._prevInResult = this.prev.prevInResult();
              return this._prevInResult;
            }
          }, {
            key: "beforeState",
            value: function beforeState() {
              if (this._beforeState !== void 0)
                return this._beforeState;
              if (!this.prev)
                this._beforeState = {
                  rings: [],
                  windings: [],
                  multiPolys: []
                };
              else {
                var seg = this.prev.consumedBy || this.prev;
                this._beforeState = seg.afterState();
              }
              return this._beforeState;
            }
          }, {
            key: "afterState",
            value: function afterState() {
              if (this._afterState !== void 0)
                return this._afterState;
              var beforeState = this.beforeState();
              this._afterState = {
                rings: beforeState.rings.slice(0),
                windings: beforeState.windings.slice(0),
                multiPolys: []
              };
              var ringsAfter = this._afterState.rings;
              var windingsAfter = this._afterState.windings;
              var mpsAfter = this._afterState.multiPolys;
              for (var i = 0, iMax = this.rings.length; i < iMax; i++) {
                var ring = this.rings[i];
                var winding = this.windings[i];
                var index2 = ringsAfter.indexOf(ring);
                if (index2 === -1) {
                  ringsAfter.push(ring);
                  windingsAfter.push(winding);
                } else
                  windingsAfter[index2] += winding;
              }
              var polysAfter = [];
              var polysExclude = [];
              for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {
                if (windingsAfter[_i] === 0)
                  continue;
                var _ring = ringsAfter[_i];
                var poly = _ring.poly;
                if (polysExclude.indexOf(poly) !== -1)
                  continue;
                if (_ring.isExterior)
                  polysAfter.push(poly);
                else {
                  if (polysExclude.indexOf(poly) === -1)
                    polysExclude.push(poly);
                  var _index = polysAfter.indexOf(_ring.poly);
                  if (_index !== -1)
                    polysAfter.splice(_index, 1);
                }
              }
              for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {
                var mp = polysAfter[_i2].multiPoly;
                if (mpsAfter.indexOf(mp) === -1)
                  mpsAfter.push(mp);
              }
              return this._afterState;
            }
          }, {
            key: "isInResult",
            value: function isInResult() {
              if (this.consumedBy)
                return false;
              if (this._isInResult !== void 0)
                return this._isInResult;
              var mpsBefore = this.beforeState().multiPolys;
              var mpsAfter = this.afterState().multiPolys;
              switch (operation.type) {
                case "union": {
                  var noBefores = mpsBefore.length === 0;
                  var noAfters = mpsAfter.length === 0;
                  this._isInResult = noBefores !== noAfters;
                  break;
                }
                case "intersection": {
                  var least;
                  var most;
                  if (mpsBefore.length < mpsAfter.length) {
                    least = mpsBefore.length;
                    most = mpsAfter.length;
                  } else {
                    least = mpsAfter.length;
                    most = mpsBefore.length;
                  }
                  this._isInResult = most === operation.numMultiPolys && least < most;
                  break;
                }
                case "xor": {
                  var diff = Math.abs(mpsBefore.length - mpsAfter.length);
                  this._isInResult = diff % 2 === 1;
                  break;
                }
                case "difference": {
                  var isJustSubject = function isJustSubject2(mps) {
                    return mps.length === 1 && mps[0].isSubject;
                  };
                  this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
                  break;
                }
                default:
                  throw new Error("Unrecognized operation type found ".concat(operation.type));
              }
              return this._isInResult;
            }
          }], [{
            key: "fromRing",
            value: function fromRing(pt1, pt2, ring) {
              var leftPt, rightPt, winding;
              var cmpPts = SweepEvent.comparePoints(pt1, pt2);
              if (cmpPts < 0) {
                leftPt = pt1;
                rightPt = pt2;
                winding = 1;
              } else if (cmpPts > 0) {
                leftPt = pt2;
                rightPt = pt1;
                winding = -1;
              } else
                throw new Error("Tried to create degenerate segment at [".concat(pt1.x, ", ").concat(pt1.y, "]"));
              var leftSE = new SweepEvent(leftPt, true);
              var rightSE = new SweepEvent(rightPt, false);
              return new Segment2(leftSE, rightSE, [ring], [winding]);
            }
          }]);
          return Segment2;
        }();
        var RingIn = /* @__PURE__ */ function() {
          function RingIn2(geomRing, poly, isExterior) {
            _classCallCheck(this, RingIn2);
            if (!Array.isArray(geomRing) || geomRing.length === 0) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            this.poly = poly;
            this.isExterior = isExterior;
            this.segments = [];
            if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
            this.bbox = {
              ll: {
                x: firstPoint.x,
                y: firstPoint.y
              },
              ur: {
                x: firstPoint.x,
                y: firstPoint.y
              }
            };
            var prevPoint = firstPoint;
            for (var i = 1, iMax = geomRing.length; i < iMax; i++) {
              if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
                throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
              }
              var point2 = rounder.round(geomRing[i][0], geomRing[i][1]);
              if (point2.x === prevPoint.x && point2.y === prevPoint.y)
                continue;
              this.segments.push(Segment.fromRing(prevPoint, point2, this));
              if (point2.x < this.bbox.ll.x)
                this.bbox.ll.x = point2.x;
              if (point2.y < this.bbox.ll.y)
                this.bbox.ll.y = point2.y;
              if (point2.x > this.bbox.ur.x)
                this.bbox.ur.x = point2.x;
              if (point2.y > this.bbox.ur.y)
                this.bbox.ur.y = point2.y;
              prevPoint = point2;
            }
            if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
              this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
            }
          }
          _createClass(RingIn2, [{
            key: "getSweepEvents",
            value: function getSweepEvents() {
              var sweepEvents = [];
              for (var i = 0, iMax = this.segments.length; i < iMax; i++) {
                var segment = this.segments[i];
                sweepEvents.push(segment.leftSE);
                sweepEvents.push(segment.rightSE);
              }
              return sweepEvents;
            }
          }]);
          return RingIn2;
        }();
        var PolyIn = /* @__PURE__ */ function() {
          function PolyIn2(geomPoly, multiPoly) {
            _classCallCheck(this, PolyIn2);
            if (!Array.isArray(geomPoly)) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            this.exteriorRing = new RingIn(geomPoly[0], this, true);
            this.bbox = {
              ll: {
                x: this.exteriorRing.bbox.ll.x,
                y: this.exteriorRing.bbox.ll.y
              },
              ur: {
                x: this.exteriorRing.bbox.ur.x,
                y: this.exteriorRing.bbox.ur.y
              }
            };
            this.interiorRings = [];
            for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {
              var ring = new RingIn(geomPoly[i], this, false);
              if (ring.bbox.ll.x < this.bbox.ll.x)
                this.bbox.ll.x = ring.bbox.ll.x;
              if (ring.bbox.ll.y < this.bbox.ll.y)
                this.bbox.ll.y = ring.bbox.ll.y;
              if (ring.bbox.ur.x > this.bbox.ur.x)
                this.bbox.ur.x = ring.bbox.ur.x;
              if (ring.bbox.ur.y > this.bbox.ur.y)
                this.bbox.ur.y = ring.bbox.ur.y;
              this.interiorRings.push(ring);
            }
            this.multiPoly = multiPoly;
          }
          _createClass(PolyIn2, [{
            key: "getSweepEvents",
            value: function getSweepEvents() {
              var sweepEvents = this.exteriorRing.getSweepEvents();
              for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
                var ringSweepEvents = this.interiorRings[i].getSweepEvents();
                for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
                  sweepEvents.push(ringSweepEvents[j]);
                }
              }
              return sweepEvents;
            }
          }]);
          return PolyIn2;
        }();
        var MultiPolyIn = /* @__PURE__ */ function() {
          function MultiPolyIn2(geom, isSubject) {
            _classCallCheck(this, MultiPolyIn2);
            if (!Array.isArray(geom)) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            try {
              if (typeof geom[0][0][0] === "number")
                geom = [geom];
            } catch (ex) {
            }
            this.polys = [];
            this.bbox = {
              ll: {
                x: Number.POSITIVE_INFINITY,
                y: Number.POSITIVE_INFINITY
              },
              ur: {
                x: Number.NEGATIVE_INFINITY,
                y: Number.NEGATIVE_INFINITY
              }
            };
            for (var i = 0, iMax = geom.length; i < iMax; i++) {
              var poly = new PolyIn(geom[i], this);
              if (poly.bbox.ll.x < this.bbox.ll.x)
                this.bbox.ll.x = poly.bbox.ll.x;
              if (poly.bbox.ll.y < this.bbox.ll.y)
                this.bbox.ll.y = poly.bbox.ll.y;
              if (poly.bbox.ur.x > this.bbox.ur.x)
                this.bbox.ur.x = poly.bbox.ur.x;
              if (poly.bbox.ur.y > this.bbox.ur.y)
                this.bbox.ur.y = poly.bbox.ur.y;
              this.polys.push(poly);
            }
            this.isSubject = isSubject;
          }
          _createClass(MultiPolyIn2, [{
            key: "getSweepEvents",
            value: function getSweepEvents() {
              var sweepEvents = [];
              for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
                var polySweepEvents = this.polys[i].getSweepEvents();
                for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
                  sweepEvents.push(polySweepEvents[j]);
                }
              }
              return sweepEvents;
            }
          }]);
          return MultiPolyIn2;
        }();
        var RingOut = /* @__PURE__ */ function() {
          _createClass(RingOut2, null, [{
            key: "factory",
            value: function factory(allSegments) {
              var ringsOut = [];
              for (var i = 0, iMax = allSegments.length; i < iMax; i++) {
                var segment = allSegments[i];
                if (!segment.isInResult() || segment.ringOut)
                  continue;
                var prevEvent = null;
                var event = segment.leftSE;
                var nextEvent = segment.rightSE;
                var events = [event];
                var startingPoint = event.point;
                var intersectionLEs = [];
                while (true) {
                  prevEvent = event;
                  event = nextEvent;
                  events.push(event);
                  if (event.point === startingPoint)
                    break;
                  while (true) {
                    var availableLEs = event.getAvailableLinkedEvents();
                    if (availableLEs.length === 0) {
                      var firstPt = events[0].point;
                      var lastPt = events[events.length - 1].point;
                      throw new Error("Unable to complete output ring starting at [".concat(firstPt.x, ",") + " ".concat(firstPt.y, "]. Last matching segment found ends at") + " [".concat(lastPt.x, ", ").concat(lastPt.y, "]."));
                    }
                    if (availableLEs.length === 1) {
                      nextEvent = availableLEs[0].otherSE;
                      break;
                    }
                    var indexLE = null;
                    for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
                      if (intersectionLEs[j].point === event.point) {
                        indexLE = j;
                        break;
                      }
                    }
                    if (indexLE !== null) {
                      var intersectionLE = intersectionLEs.splice(indexLE)[0];
                      var ringEvents = events.splice(intersectionLE.index);
                      ringEvents.unshift(ringEvents[0].otherSE);
                      ringsOut.push(new RingOut2(ringEvents.reverse()));
                      continue;
                    }
                    intersectionLEs.push({
                      index: events.length,
                      point: event.point
                    });
                    var comparator = event.getLeftmostComparator(prevEvent);
                    nextEvent = availableLEs.sort(comparator)[0].otherSE;
                    break;
                  }
                }
                ringsOut.push(new RingOut2(events));
              }
              return ringsOut;
            }
          }]);
          function RingOut2(events) {
            _classCallCheck(this, RingOut2);
            this.events = events;
            for (var i = 0, iMax = events.length; i < iMax; i++) {
              events[i].segment.ringOut = this;
            }
            this.poly = null;
          }
          _createClass(RingOut2, [{
            key: "getGeom",
            value: function getGeom2() {
              var prevPt = this.events[0].point;
              var points = [prevPt];
              for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {
                var _pt = this.events[i].point;
                var _nextPt = this.events[i + 1].point;
                if (compareVectorAngles(_pt, prevPt, _nextPt) === 0)
                  continue;
                points.push(_pt);
                prevPt = _pt;
              }
              if (points.length === 1)
                return null;
              var pt = points[0];
              var nextPt = points[1];
              if (compareVectorAngles(pt, prevPt, nextPt) === 0)
                points.shift();
              points.push(points[0]);
              var step = this.isExteriorRing() ? 1 : -1;
              var iStart = this.isExteriorRing() ? 0 : points.length - 1;
              var iEnd = this.isExteriorRing() ? points.length : -1;
              var orderedPoints = [];
              for (var _i = iStart; _i != iEnd; _i += step) {
                orderedPoints.push([points[_i].x, points[_i].y]);
              }
              return orderedPoints;
            }
          }, {
            key: "isExteriorRing",
            value: function isExteriorRing() {
              if (this._isExteriorRing === void 0) {
                var enclosing = this.enclosingRing();
                this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
              }
              return this._isExteriorRing;
            }
          }, {
            key: "enclosingRing",
            value: function enclosingRing() {
              if (this._enclosingRing === void 0) {
                this._enclosingRing = this._calcEnclosingRing();
              }
              return this._enclosingRing;
            }
          }, {
            key: "_calcEnclosingRing",
            value: function _calcEnclosingRing() {
              var leftMostEvt = this.events[0];
              for (var i = 1, iMax = this.events.length; i < iMax; i++) {
                var evt = this.events[i];
                if (SweepEvent.compare(leftMostEvt, evt) > 0)
                  leftMostEvt = evt;
              }
              var prevSeg = leftMostEvt.segment.prevInResult();
              var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
              while (true) {
                if (!prevSeg)
                  return null;
                if (!prevPrevSeg)
                  return prevSeg.ringOut;
                if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
                  if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
                    return prevSeg.ringOut;
                  } else
                    return prevSeg.ringOut.enclosingRing();
                }
                prevSeg = prevPrevSeg.prevInResult();
                prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
              }
            }
          }]);
          return RingOut2;
        }();
        var PolyOut = /* @__PURE__ */ function() {
          function PolyOut2(exteriorRing) {
            _classCallCheck(this, PolyOut2);
            this.exteriorRing = exteriorRing;
            exteriorRing.poly = this;
            this.interiorRings = [];
          }
          _createClass(PolyOut2, [{
            key: "addInterior",
            value: function addInterior(ring) {
              this.interiorRings.push(ring);
              ring.poly = this;
            }
          }, {
            key: "getGeom",
            value: function getGeom2() {
              var geom = [this.exteriorRing.getGeom()];
              if (geom[0] === null)
                return null;
              for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
                var ringGeom = this.interiorRings[i].getGeom();
                if (ringGeom === null)
                  continue;
                geom.push(ringGeom);
              }
              return geom;
            }
          }]);
          return PolyOut2;
        }();
        var MultiPolyOut = /* @__PURE__ */ function() {
          function MultiPolyOut2(rings) {
            _classCallCheck(this, MultiPolyOut2);
            this.rings = rings;
            this.polys = this._composePolys(rings);
          }
          _createClass(MultiPolyOut2, [{
            key: "getGeom",
            value: function getGeom2() {
              var geom = [];
              for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
                var polyGeom = this.polys[i].getGeom();
                if (polyGeom === null)
                  continue;
                geom.push(polyGeom);
              }
              return geom;
            }
          }, {
            key: "_composePolys",
            value: function _composePolys(rings) {
              var polys = [];
              for (var i = 0, iMax = rings.length; i < iMax; i++) {
                var ring = rings[i];
                if (ring.poly)
                  continue;
                if (ring.isExteriorRing())
                  polys.push(new PolyOut(ring));
                else {
                  var enclosingRing = ring.enclosingRing();
                  if (!enclosingRing.poly)
                    polys.push(new PolyOut(enclosingRing));
                  enclosingRing.poly.addInterior(ring);
                }
              }
              return polys;
            }
          }]);
          return MultiPolyOut2;
        }();
        var SweepLine = /* @__PURE__ */ function() {
          function SweepLine2(queue) {
            var comparator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Segment.compare;
            _classCallCheck(this, SweepLine2);
            this.queue = queue;
            this.tree = new Tree(comparator);
            this.segments = [];
          }
          _createClass(SweepLine2, [{
            key: "process",
            value: function process2(event) {
              var segment = event.segment;
              var newEvents = [];
              if (event.consumedBy) {
                if (event.isLeft)
                  this.queue.remove(event.otherSE);
                else
                  this.tree.remove(segment);
                return newEvents;
              }
              var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);
              if (!node)
                throw new Error("Unable to find segment #".concat(segment.id, " ") + "[".concat(segment.leftSE.point.x, ", ").concat(segment.leftSE.point.y, "] -> ") + "[".concat(segment.rightSE.point.x, ", ").concat(segment.rightSE.point.y, "] ") + "in SweepLine tree. Please submit a bug report.");
              var prevNode = node;
              var nextNode = node;
              var prevSeg = void 0;
              var nextSeg = void 0;
              while (prevSeg === void 0) {
                prevNode = this.tree.prev(prevNode);
                if (prevNode === null)
                  prevSeg = null;
                else if (prevNode.key.consumedBy === void 0)
                  prevSeg = prevNode.key;
              }
              while (nextSeg === void 0) {
                nextNode = this.tree.next(nextNode);
                if (nextNode === null)
                  nextSeg = null;
                else if (nextNode.key.consumedBy === void 0)
                  nextSeg = nextNode.key;
              }
              if (event.isLeft) {
                var prevMySplitter = null;
                if (prevSeg) {
                  var prevInter = prevSeg.getIntersection(segment);
                  if (prevInter !== null) {
                    if (!segment.isAnEndpoint(prevInter))
                      prevMySplitter = prevInter;
                    if (!prevSeg.isAnEndpoint(prevInter)) {
                      var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
                      for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                        newEvents.push(newEventsFromSplit[i]);
                      }
                    }
                  }
                }
                var nextMySplitter = null;
                if (nextSeg) {
                  var nextInter = nextSeg.getIntersection(segment);
                  if (nextInter !== null) {
                    if (!segment.isAnEndpoint(nextInter))
                      nextMySplitter = nextInter;
                    if (!nextSeg.isAnEndpoint(nextInter)) {
                      var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
                      for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {
                        newEvents.push(_newEventsFromSplit[_i]);
                      }
                    }
                  }
                }
                if (prevMySplitter !== null || nextMySplitter !== null) {
                  var mySplitter = null;
                  if (prevMySplitter === null)
                    mySplitter = nextMySplitter;
                  else if (nextMySplitter === null)
                    mySplitter = prevMySplitter;
                  else {
                    var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
                    mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
                  }
                  this.queue.remove(segment.rightSE);
                  newEvents.push(segment.rightSE);
                  var _newEventsFromSplit2 = segment.split(mySplitter);
                  for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {
                    newEvents.push(_newEventsFromSplit2[_i2]);
                  }
                }
                if (newEvents.length > 0) {
                  this.tree.remove(segment);
                  newEvents.push(event);
                } else {
                  this.segments.push(segment);
                  segment.prev = prevSeg;
                }
              } else {
                if (prevSeg && nextSeg) {
                  var inter = prevSeg.getIntersection(nextSeg);
                  if (inter !== null) {
                    if (!prevSeg.isAnEndpoint(inter)) {
                      var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);
                      for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {
                        newEvents.push(_newEventsFromSplit3[_i3]);
                      }
                    }
                    if (!nextSeg.isAnEndpoint(inter)) {
                      var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);
                      for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {
                        newEvents.push(_newEventsFromSplit4[_i4]);
                      }
                    }
                  }
                }
                this.tree.remove(segment);
              }
              return newEvents;
            }
          }, {
            key: "_splitSafely",
            value: function _splitSafely(seg, pt) {
              this.tree.remove(seg);
              var rightSE = seg.rightSE;
              this.queue.remove(rightSE);
              var newEvents = seg.split(pt);
              newEvents.push(rightSE);
              if (seg.consumedBy === void 0)
                this.tree.insert(seg);
              return newEvents;
            }
          }]);
          return SweepLine2;
        }();
        var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6;
        var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
        var Operation = /* @__PURE__ */ function() {
          function Operation2() {
            _classCallCheck(this, Operation2);
          }
          _createClass(Operation2, [{
            key: "run",
            value: function run(type, geom, moreGeoms) {
              operation.type = type;
              rounder.reset();
              var multipolys = [new MultiPolyIn(geom, true)];
              for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {
                multipolys.push(new MultiPolyIn(moreGeoms[i], false));
              }
              operation.numMultiPolys = multipolys.length;
              if (operation.type === "difference") {
                var subject = multipolys[0];
                var _i = 1;
                while (_i < multipolys.length) {
                  if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null)
                    _i++;
                  else
                    multipolys.splice(_i, 1);
                }
              }
              if (operation.type === "intersection") {
                for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {
                  var mpA = multipolys[_i2];
                  for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {
                    if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null)
                      return [];
                  }
                }
              }
              var queue = new Tree(SweepEvent.compare);
              for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {
                var sweepEvents = multipolys[_i3].getSweepEvents();
                for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {
                  queue.insert(sweepEvents[_j]);
                  if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                    throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.");
                  }
                }
              }
              var sweepLine = new SweepLine(queue);
              var prevQueueSize = queue.size;
              var node = queue.pop();
              while (node) {
                var evt = node.key;
                if (queue.size === prevQueueSize) {
                  var seg = evt.segment;
                  throw new Error("Unable to pop() ".concat(evt.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(evt.point.x, ", ").concat(evt.point.y, "] from segment #").concat(seg.id, " ") + "[".concat(seg.leftSE.point.x, ", ").concat(seg.leftSE.point.y, "] -> ") + "[".concat(seg.rightSE.point.x, ", ").concat(seg.rightSE.point.y, "] from queue. ") + "Please file a bug report.");
                }
                if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                  throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.");
                }
                if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
                  throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.");
                }
                var newEvents = sweepLine.process(evt);
                for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {
                  var _evt = newEvents[_i4];
                  if (_evt.consumedBy === void 0)
                    queue.insert(_evt);
                }
                prevQueueSize = queue.size;
                node = queue.pop();
              }
              rounder.reset();
              var ringsOut = RingOut.factory(sweepLine.segments);
              var result = new MultiPolyOut(ringsOut);
              return result.getGeom();
            }
          }]);
          return Operation2;
        }();
        var operation = new Operation();
        var union = function union2(geom) {
          for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            moreGeoms[_key - 1] = arguments[_key];
          }
          return operation.run("union", geom, moreGeoms);
        };
        var intersection$1 = function intersection2(geom) {
          for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            moreGeoms[_key2 - 1] = arguments[_key2];
          }
          return operation.run("intersection", geom, moreGeoms);
        };
        var xor = function xor2(geom) {
          for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            moreGeoms[_key3 - 1] = arguments[_key3];
          }
          return operation.run("xor", geom, moreGeoms);
        };
        var difference = function difference2(subjectGeom) {
          for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            clippingGeoms[_key4 - 1] = arguments[_key4];
          }
          return operation.run("difference", subjectGeom, clippingGeoms);
        };
        var index = {
          union,
          intersection: intersection$1,
          xor,
          difference
        };
        return index;
      });
    }
  });

  // node_modules/turf-jsts/jsts.min.js
  var require_jsts_min = __commonJS({
    "node_modules/turf-jsts/jsts.min.js"(exports, module) {
      !function(t, e) {
        typeof exports == "object" && typeof module != "undefined" ? e(exports) : typeof define == "function" && define.amd ? define(["exports"], e) : e(t.jsts = {});
      }(exports, function(t) {
        "use strict";
        function e() {
        }
        function n(t2) {
          this.message = t2 || "";
        }
        function i(t2) {
          this.message = t2 || "";
        }
        function r(t2) {
          this.message = t2 || "";
        }
        function o() {
        }
        function s(t2) {
          return t2 === null ? Mt : t2.color;
        }
        function a(t2) {
          return t2 === null ? null : t2.parent;
        }
        function u(t2, e3) {
          t2 !== null && (t2.color = e3);
        }
        function l(t2) {
          return t2 === null ? null : t2.left;
        }
        function c(t2) {
          return t2 === null ? null : t2.right;
        }
        function p() {
          this.root_ = null, this.size_ = 0;
        }
        function h() {
        }
        function f() {
          this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
        }
        function g() {
        }
        function d(t2) {
          this.message = t2 || "";
        }
        function y2() {
          this.array_ = [];
        }
        "fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", { configurable: true, value: function(t2) {
          if (this === void 0 || this === null)
            throw new TypeError(this + " is not an object");
          var e3 = Object(this), n2 = Math.max(Math.min(e3.length, 9007199254740991), 0) || 0, i2 = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;
          i2 = i2 < 0 ? Math.max(n2 + i2, 0) : Math.min(i2, n2);
          var r2 = 2 in arguments && arguments[2] !== void 0 ? parseInt(Number(arguments[2]), 10) || 0 : n2;
          for (r2 = r2 < 0 ? Math.max(n2 + arguments[2], 0) : Math.min(r2, n2); i2 < r2; )
            e3[i2] = t2, ++i2;
          return e3;
        }, writable: true }), Number.isFinite = Number.isFinite || function(t2) {
          return typeof t2 == "number" && isFinite(t2);
        }, Number.isInteger = Number.isInteger || function(t2) {
          return typeof t2 == "number" && isFinite(t2) && Math.floor(t2) === t2;
        }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function(t2) {
          return t2 != t2;
        }, Math.trunc = Math.trunc || function(t2) {
          return t2 < 0 ? Math.ceil(t2) : Math.floor(t2);
        };
        var _ = function() {
        };
        _.prototype.interfaces_ = function() {
          return [];
        }, _.prototype.getClass = function() {
          return _;
        }, _.prototype.equalsWithTolerance = function(t2, e3, n2) {
          return Math.abs(t2 - e3) <= n2;
        };
        var m = function(t2) {
          function e3(e4) {
            t2.call(this, e4), this.name = "IllegalArgumentException", this.message = e4, this.stack = new t2().stack;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3;
        }(Error), v = function() {
        }, I = { MAX_VALUE: { configurable: true } };
        v.isNaN = function(t2) {
          return Number.isNaN(t2);
        }, v.doubleToLongBits = function(t2) {
          return t2;
        }, v.longBitsToDouble = function(t2) {
          return t2;
        }, v.isInfinite = function(t2) {
          return !Number.isFinite(t2);
        }, I.MAX_VALUE.get = function() {
          return Number.MAX_VALUE;
        }, Object.defineProperties(v, I);
        var E = function() {
        }, x2 = function() {
        }, N = function() {
        }, C = function t2() {
          if (this.x = null, this.y = null, this.z = null, arguments.length === 0)
            this.x = 0, this.y = 0, this.z = t2.NULL_ORDINATE;
          else if (arguments.length === 1) {
            var e3 = arguments[0];
            this.x = e3.x, this.y = e3.y, this.z = e3.z;
          } else
            arguments.length === 2 ? (this.x = arguments[0], this.y = arguments[1], this.z = t2.NULL_ORDINATE) : arguments.length === 3 && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2]);
        }, S = { DimensionalComparator: { configurable: true }, serialVersionUID: { configurable: true }, NULL_ORDINATE: { configurable: true }, X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true } };
        C.prototype.setOrdinate = function(t2, e3) {
          switch (t2) {
            case C.X:
              this.x = e3;
              break;
            case C.Y:
              this.y = e3;
              break;
            case C.Z:
              this.z = e3;
              break;
            default:
              throw new m("Invalid ordinate index: " + t2);
          }
        }, C.prototype.equals2D = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return this.x === t2.x && this.y === t2.y;
          }
          if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            return !!_.equalsWithTolerance(this.x, e3.x, n2) && !!_.equalsWithTolerance(this.y, e3.y, n2);
          }
        }, C.prototype.getOrdinate = function(t2) {
          switch (t2) {
            case C.X:
              return this.x;
            case C.Y:
              return this.y;
            case C.Z:
              return this.z;
          }
          throw new m("Invalid ordinate index: " + t2);
        }, C.prototype.equals3D = function(t2) {
          return this.x === t2.x && this.y === t2.y && (this.z === t2.z || v.isNaN(this.z)) && v.isNaN(t2.z);
        }, C.prototype.equals = function(t2) {
          return t2 instanceof C && this.equals2D(t2);
        }, C.prototype.equalInZ = function(t2, e3) {
          return _.equalsWithTolerance(this.z, t2.z, e3);
        }, C.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.x < e3.x ? -1 : this.x > e3.x ? 1 : this.y < e3.y ? -1 : this.y > e3.y ? 1 : 0;
        }, C.prototype.clone = function() {
        }, C.prototype.copy = function() {
          return new C(this);
        }, C.prototype.toString = function() {
          return "(" + this.x + ", " + this.y + ", " + this.z + ")";
        }, C.prototype.distance3D = function(t2) {
          var e3 = this.x - t2.x, n2 = this.y - t2.y, i2 = this.z - t2.z;
          return Math.sqrt(e3 * e3 + n2 * n2 + i2 * i2);
        }, C.prototype.distance = function(t2) {
          var e3 = this.x - t2.x, n2 = this.y - t2.y;
          return Math.sqrt(e3 * e3 + n2 * n2);
        }, C.prototype.hashCode = function() {
          var t2 = 17;
          return t2 = 37 * t2 + C.hashCode(this.x), t2 = 37 * t2 + C.hashCode(this.y);
        }, C.prototype.setCoordinate = function(t2) {
          this.x = t2.x, this.y = t2.y, this.z = t2.z;
        }, C.prototype.interfaces_ = function() {
          return [E, x2, e];
        }, C.prototype.getClass = function() {
          return C;
        }, C.hashCode = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0], e3 = v.doubleToLongBits(t2);
            return Math.trunc((e3 ^ e3) >>> 32);
          }
        }, S.DimensionalComparator.get = function() {
          return L2;
        }, S.serialVersionUID.get = function() {
          return 6683108902428367e3;
        }, S.NULL_ORDINATE.get = function() {
          return v.NaN;
        }, S.X.get = function() {
          return 0;
        }, S.Y.get = function() {
          return 1;
        }, S.Z.get = function() {
          return 2;
        }, Object.defineProperties(C, S);
        var L2 = function(t2) {
          if (this._dimensionsToTest = 2, arguments.length === 0)
            ;
          else if (arguments.length === 1) {
            var e3 = arguments[0];
            if (e3 !== 2 && e3 !== 3)
              throw new m("only 2 or 3 dimensions may be specified");
            this._dimensionsToTest = e3;
          }
        };
        L2.prototype.compare = function(t2, e3) {
          var n2 = t2, i2 = e3, r2 = L2.compare(n2.x, i2.x);
          if (r2 !== 0)
            return r2;
          var o2 = L2.compare(n2.y, i2.y);
          if (o2 !== 0)
            return o2;
          if (this._dimensionsToTest <= 2)
            return 0;
          return L2.compare(n2.z, i2.z);
        }, L2.prototype.interfaces_ = function() {
          return [N];
        }, L2.prototype.getClass = function() {
          return L2;
        }, L2.compare = function(t2, e3) {
          return t2 < e3 ? -1 : t2 > e3 ? 1 : v.isNaN(t2) ? v.isNaN(e3) ? 0 : -1 : v.isNaN(e3) ? 1 : 0;
        };
        var b = function() {
        };
        b.prototype.create = function() {
        }, b.prototype.interfaces_ = function() {
          return [];
        }, b.prototype.getClass = function() {
          return b;
        };
        var w = function() {
        }, O = { INTERIOR: { configurable: true }, BOUNDARY: { configurable: true }, EXTERIOR: { configurable: true }, NONE: { configurable: true } };
        w.prototype.interfaces_ = function() {
          return [];
        }, w.prototype.getClass = function() {
          return w;
        }, w.toLocationSymbol = function(t2) {
          switch (t2) {
            case w.EXTERIOR:
              return "e";
            case w.BOUNDARY:
              return "b";
            case w.INTERIOR:
              return "i";
            case w.NONE:
              return "-";
          }
          throw new m("Unknown location value: " + t2);
        }, O.INTERIOR.get = function() {
          return 0;
        }, O.BOUNDARY.get = function() {
          return 1;
        }, O.EXTERIOR.get = function() {
          return 2;
        }, O.NONE.get = function() {
          return -1;
        }, Object.defineProperties(w, O);
        var T = function(t2, e3) {
          return t2.interfaces_ && t2.interfaces_().indexOf(e3) > -1;
        }, R = function() {
        }, P = { LOG_10: { configurable: true } };
        R.prototype.interfaces_ = function() {
          return [];
        }, R.prototype.getClass = function() {
          return R;
        }, R.log10 = function(t2) {
          var e3 = Math.log(t2);
          return v.isInfinite(e3) ? e3 : v.isNaN(e3) ? e3 : e3 / R.LOG_10;
        }, R.min = function(t2, e3, n2, i2) {
          var r2 = t2;
          return e3 < r2 && (r2 = e3), n2 < r2 && (r2 = n2), i2 < r2 && (r2 = i2), r2;
        }, R.clamp = function() {
          if (typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
            return t2 < e3 ? e3 : t2 > n2 ? n2 : t2;
          }
          if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            return i2 < r2 ? r2 : i2 > o2 ? o2 : i2;
          }
        }, R.wrap = function(t2, e3) {
          return t2 < 0 ? e3 - -t2 % e3 : t2 % e3;
        }, R.max = function() {
          if (arguments.length === 3) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = t2;
            return e3 > i2 && (i2 = e3), n2 > i2 && (i2 = n2), i2;
          }
          if (arguments.length === 4) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3], u2 = r2;
            return o2 > u2 && (u2 = o2), s2 > u2 && (u2 = s2), a2 > u2 && (u2 = a2), u2;
          }
        }, R.average = function(t2, e3) {
          return (t2 + e3) / 2;
        }, P.LOG_10.get = function() {
          return Math.log(10);
        }, Object.defineProperties(R, P);
        var D = function(t2) {
          this.str = t2;
        };
        D.prototype.append = function(t2) {
          this.str += t2;
        }, D.prototype.setCharAt = function(t2, e3) {
          this.str = this.str.substr(0, t2) + e3 + this.str.substr(t2 + 1);
        }, D.prototype.toString = function(t2) {
          return this.str;
        };
        var M = function(t2) {
          this.value = t2;
        };
        M.prototype.intValue = function() {
          return this.value;
        }, M.prototype.compareTo = function(t2) {
          return this.value < t2 ? -1 : this.value > t2 ? 1 : 0;
        }, M.isNaN = function(t2) {
          return Number.isNaN(t2);
        };
        var A = function() {
        };
        A.isWhitespace = function(t2) {
          return t2 <= 32 && t2 >= 0 || t2 === 127;
        }, A.toUpperCase = function(t2) {
          return t2.toUpperCase();
        };
        var F = function t2() {
          if (this._hi = 0, this._lo = 0, arguments.length === 0)
            this.init(0);
          else if (arguments.length === 1) {
            if (typeof arguments[0] == "number") {
              var e3 = arguments[0];
              this.init(e3);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.init(n2);
            } else if (typeof arguments[0] == "string") {
              var i2 = arguments[0];
              t2.call(this, t2.parse(i2));
            }
          } else if (arguments.length === 2) {
            var r2 = arguments[0], o2 = arguments[1];
            this.init(r2, o2);
          }
        }, G = { PI: { configurable: true }, TWO_PI: { configurable: true }, PI_2: { configurable: true }, E: { configurable: true }, NaN: { configurable: true }, EPS: { configurable: true }, SPLIT: { configurable: true }, MAX_PRINT_DIGITS: { configurable: true }, TEN: { configurable: true }, ONE: { configurable: true }, SCI_NOT_EXPONENT_CHAR: { configurable: true }, SCI_NOT_ZERO: { configurable: true } };
        F.prototype.le = function(t2) {
          return (this._hi < t2._hi || this._hi === t2._hi) && this._lo <= t2._lo;
        }, F.prototype.extractSignificantDigits = function(t2, e3) {
          var n2 = this.abs(), i2 = F.magnitude(n2._hi), r2 = F.TEN.pow(i2);
          (n2 = n2.divide(r2)).gt(F.TEN) ? (n2 = n2.divide(F.TEN), i2 += 1) : n2.lt(F.ONE) && (n2 = n2.multiply(F.TEN), i2 -= 1);
          for (var o2 = i2 + 1, s2 = new D(), a2 = F.MAX_PRINT_DIGITS - 1, u2 = 0; u2 <= a2; u2++) {
            t2 && u2 === o2 && s2.append(".");
            var l2 = Math.trunc(n2._hi);
            if (l2 < 0)
              break;
            var c2 = false, p2 = 0;
            l2 > 9 ? (c2 = true, p2 = "9") : p2 = "0" + l2, s2.append(p2), n2 = n2.subtract(F.valueOf(l2)).multiply(F.TEN), c2 && n2.selfAdd(F.TEN);
            var h2 = true, f2 = F.magnitude(n2._hi);
            if (f2 < 0 && Math.abs(f2) >= a2 - u2 && (h2 = false), !h2)
              break;
          }
          return e3[0] = i2, s2.toString();
        }, F.prototype.sqr = function() {
          return this.multiply(this);
        }, F.prototype.doubleValue = function() {
          return this._hi + this._lo;
        }, F.prototype.subtract = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.add(t2.negate());
          }
          if (typeof arguments[0] == "number") {
            var e3 = arguments[0];
            return this.add(-e3);
          }
        }, F.prototype.equals = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return this._hi === t2._hi && this._lo === t2._lo;
          }
        }, F.prototype.isZero = function() {
          return this._hi === 0 && this._lo === 0;
        }, F.prototype.selfSubtract = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-t2._hi, -t2._lo);
          }
          if (typeof arguments[0] == "number") {
            var e3 = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-e3, 0);
          }
        }, F.prototype.getSpecialNumberString = function() {
          return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
        }, F.prototype.min = function(t2) {
          return this.le(t2) ? this : t2;
        }, F.prototype.selfDivide = function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof F) {
              var t2 = arguments[0];
              return this.selfDivide(t2._hi, t2._lo);
            }
            if (typeof arguments[0] == "number") {
              var e3 = arguments[0];
              return this.selfDivide(e3, 0);
            }
          } else if (arguments.length === 2) {
            var n2 = arguments[0], i2 = arguments[1], r2 = null, o2 = null, s2 = null, a2 = null, u2 = null, l2 = null, c2 = null, p2 = null;
            return u2 = this._hi / n2, l2 = F.SPLIT * u2, r2 = l2 - u2, p2 = F.SPLIT * n2, r2 = l2 - r2, o2 = u2 - r2, s2 = p2 - n2, c2 = u2 * n2, s2 = p2 - s2, a2 = n2 - s2, p2 = r2 * s2 - c2 + r2 * a2 + o2 * s2 + o2 * a2, l2 = (this._hi - c2 - p2 + this._lo - u2 * i2) / n2, p2 = u2 + l2, this._hi = p2, this._lo = u2 - p2 + l2, this;
          }
        }, F.prototype.dump = function() {
          return "DD<" + this._hi + ", " + this._lo + ">";
        }, F.prototype.divide = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0], e3 = null, n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a2 = null, u2 = null;
            n2 = (o2 = this._hi / t2._hi) - (e3 = (s2 = F.SPLIT * o2) - (e3 = s2 - o2)), u2 = e3 * (i2 = (u2 = F.SPLIT * t2._hi) - (i2 = u2 - t2._hi)) - (a2 = o2 * t2._hi) + e3 * (r2 = t2._hi - i2) + n2 * i2 + n2 * r2, s2 = (this._hi - a2 - u2 + this._lo - o2 * t2._lo) / t2._hi;
            return new F(u2 = o2 + s2, o2 - u2 + s2);
          }
          if (typeof arguments[0] == "number") {
            var l2 = arguments[0];
            return v.isNaN(l2) ? F.createNaN() : F.copy(this).selfDivide(l2, 0);
          }
        }, F.prototype.ge = function(t2) {
          return (this._hi > t2._hi || this._hi === t2._hi) && this._lo >= t2._lo;
        }, F.prototype.pow = function(t2) {
          if (t2 === 0)
            return F.valueOf(1);
          var e3 = new F(this), n2 = F.valueOf(1), i2 = Math.abs(t2);
          if (i2 > 1)
            for (; i2 > 0; )
              i2 % 2 == 1 && n2.selfMultiply(e3), (i2 /= 2) > 0 && (e3 = e3.sqr());
          else
            n2 = e3;
          return t2 < 0 ? n2.reciprocal() : n2;
        }, F.prototype.ceil = function() {
          if (this.isNaN())
            return F.NaN;
          var t2 = Math.ceil(this._hi), e3 = 0;
          return t2 === this._hi && (e3 = Math.ceil(this._lo)), new F(t2, e3);
        }, F.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._hi < e3._hi ? -1 : this._hi > e3._hi ? 1 : this._lo < e3._lo ? -1 : this._lo > e3._lo ? 1 : 0;
        }, F.prototype.rint = function() {
          if (this.isNaN())
            return this;
          return this.add(0.5).floor();
        }, F.prototype.setValue = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.init(t2), this;
          }
          if (typeof arguments[0] == "number") {
            var e3 = arguments[0];
            return this.init(e3), this;
          }
        }, F.prototype.max = function(t2) {
          return this.ge(t2) ? this : t2;
        }, F.prototype.sqrt = function() {
          if (this.isZero())
            return F.valueOf(0);
          if (this.isNegative())
            return F.NaN;
          var t2 = 1 / Math.sqrt(this._hi), e3 = this._hi * t2, n2 = F.valueOf(e3), i2 = this.subtract(n2.sqr())._hi * (0.5 * t2);
          return n2.add(i2);
        }, F.prototype.selfAdd = function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof F) {
              var t2 = arguments[0];
              return this.selfAdd(t2._hi, t2._lo);
            }
            if (typeof arguments[0] == "number") {
              var e3 = arguments[0], n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a2 = null;
              return r2 = this._hi + e3, s2 = r2 - this._hi, o2 = r2 - s2, o2 = e3 - s2 + (this._hi - o2), a2 = o2 + this._lo, n2 = r2 + a2, i2 = a2 + (r2 - n2), this._hi = n2 + i2, this._lo = i2 + (n2 - this._hi), this;
            }
          } else if (arguments.length === 2) {
            var u2 = arguments[0], l2 = arguments[1], c2 = null, p2 = null, h2 = null, f2 = null, g2 = null, d2 = null, y3 = null;
            f2 = this._hi + u2, p2 = this._lo + l2, g2 = f2 - (d2 = f2 - this._hi), h2 = p2 - (y3 = p2 - this._lo);
            var _2 = (c2 = f2 + (d2 = (g2 = u2 - d2 + (this._hi - g2)) + p2)) + (d2 = (h2 = l2 - y3 + (this._lo - h2)) + (d2 + (f2 - c2))), m2 = d2 + (c2 - _2);
            return this._hi = _2, this._lo = m2, this;
          }
        }, F.prototype.selfMultiply = function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof F) {
              var t2 = arguments[0];
              return this.selfMultiply(t2._hi, t2._lo);
            }
            if (typeof arguments[0] == "number") {
              var e3 = arguments[0];
              return this.selfMultiply(e3, 0);
            }
          } else if (arguments.length === 2) {
            var n2 = arguments[0], i2 = arguments[1], r2 = null, o2 = null, s2 = null, a2 = null, u2 = null, l2 = null;
            r2 = (u2 = F.SPLIT * this._hi) - this._hi, l2 = F.SPLIT * n2, r2 = u2 - r2, o2 = this._hi - r2, s2 = l2 - n2;
            var c2 = (u2 = this._hi * n2) + (l2 = r2 * (s2 = l2 - s2) - u2 + r2 * (a2 = n2 - s2) + o2 * s2 + o2 * a2 + (this._hi * i2 + this._lo * n2)), p2 = l2 + (r2 = u2 - c2);
            return this._hi = c2, this._lo = p2, this;
          }
        }, F.prototype.selfSqr = function() {
          return this.selfMultiply(this);
        }, F.prototype.floor = function() {
          if (this.isNaN())
            return F.NaN;
          var t2 = Math.floor(this._hi), e3 = 0;
          return t2 === this._hi && (e3 = Math.floor(this._lo)), new F(t2, e3);
        }, F.prototype.negate = function() {
          return this.isNaN() ? this : new F(-this._hi, -this._lo);
        }, F.prototype.clone = function() {
        }, F.prototype.multiply = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return t2.isNaN() ? F.createNaN() : F.copy(this).selfMultiply(t2);
          }
          if (typeof arguments[0] == "number") {
            var e3 = arguments[0];
            return v.isNaN(e3) ? F.createNaN() : F.copy(this).selfMultiply(e3, 0);
          }
        }, F.prototype.isNaN = function() {
          return v.isNaN(this._hi);
        }, F.prototype.intValue = function() {
          return Math.trunc(this._hi);
        }, F.prototype.toString = function() {
          var t2 = F.magnitude(this._hi);
          return t2 >= -3 && t2 <= 20 ? this.toStandardNotation() : this.toSciNotation();
        }, F.prototype.toStandardNotation = function() {
          var t2 = this.getSpecialNumberString();
          if (t2 !== null)
            return t2;
          var e3 = new Array(1).fill(null), n2 = this.extractSignificantDigits(true, e3), i2 = e3[0] + 1, r2 = n2;
          if (n2.charAt(0) === ".")
            r2 = "0" + n2;
          else if (i2 < 0)
            r2 = "0." + F.stringOfChar("0", -i2) + n2;
          else if (n2.indexOf(".") === -1) {
            var o2 = i2 - n2.length;
            r2 = n2 + F.stringOfChar("0", o2) + ".0";
          }
          return this.isNegative() ? "-" + r2 : r2;
        }, F.prototype.reciprocal = function() {
          var t2 = null, e3 = null, n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a2 = null;
          e3 = (r2 = 1 / this._hi) - (t2 = (o2 = F.SPLIT * r2) - (t2 = o2 - r2)), n2 = (a2 = F.SPLIT * this._hi) - this._hi;
          var u2 = r2 + (o2 = (1 - (s2 = r2 * this._hi) - (a2 = t2 * (n2 = a2 - n2) - s2 + t2 * (i2 = this._hi - n2) + e3 * n2 + e3 * i2) - r2 * this._lo) / this._hi);
          return new F(u2, r2 - u2 + o2);
        }, F.prototype.toSciNotation = function() {
          if (this.isZero())
            return F.SCI_NOT_ZERO;
          var t2 = this.getSpecialNumberString();
          if (t2 !== null)
            return t2;
          var e3 = new Array(1).fill(null), n2 = this.extractSignificantDigits(false, e3), i2 = F.SCI_NOT_EXPONENT_CHAR + e3[0];
          if (n2.charAt(0) === "0")
            throw new Error("Found leading zero: " + n2);
          var r2 = "";
          n2.length > 1 && (r2 = n2.substring(1));
          var o2 = n2.charAt(0) + "." + r2;
          return this.isNegative() ? "-" + o2 + i2 : o2 + i2;
        }, F.prototype.abs = function() {
          return this.isNaN() ? F.NaN : this.isNegative() ? this.negate() : new F(this);
        }, F.prototype.isPositive = function() {
          return (this._hi > 0 || this._hi === 0) && this._lo > 0;
        }, F.prototype.lt = function(t2) {
          return (this._hi < t2._hi || this._hi === t2._hi) && this._lo < t2._lo;
        }, F.prototype.add = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return F.copy(this).selfAdd(t2);
          }
          if (typeof arguments[0] == "number") {
            var e3 = arguments[0];
            return F.copy(this).selfAdd(e3);
          }
        }, F.prototype.init = function() {
          if (arguments.length === 1) {
            if (typeof arguments[0] == "number") {
              var t2 = arguments[0];
              this._hi = t2, this._lo = 0;
            } else if (arguments[0] instanceof F) {
              var e3 = arguments[0];
              this._hi = e3._hi, this._lo = e3._lo;
            }
          } else if (arguments.length === 2) {
            var n2 = arguments[0], i2 = arguments[1];
            this._hi = n2, this._lo = i2;
          }
        }, F.prototype.gt = function(t2) {
          return (this._hi > t2._hi || this._hi === t2._hi) && this._lo > t2._lo;
        }, F.prototype.isNegative = function() {
          return (this._hi < 0 || this._hi === 0) && this._lo < 0;
        }, F.prototype.trunc = function() {
          return this.isNaN() ? F.NaN : this.isPositive() ? this.floor() : this.ceil();
        }, F.prototype.signum = function() {
          return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
        }, F.prototype.interfaces_ = function() {
          return [e, E, x2];
        }, F.prototype.getClass = function() {
          return F;
        }, F.sqr = function(t2) {
          return F.valueOf(t2).selfMultiply(t2);
        }, F.valueOf = function() {
          if (typeof arguments[0] == "string") {
            var t2 = arguments[0];
            return F.parse(t2);
          }
          if (typeof arguments[0] == "number") {
            var e3 = arguments[0];
            return new F(e3);
          }
        }, F.sqrt = function(t2) {
          return F.valueOf(t2).sqrt();
        }, F.parse = function(t2) {
          for (var e3 = 0, n2 = t2.length; A.isWhitespace(t2.charAt(e3)); )
            e3++;
          var i2 = false;
          if (e3 < n2) {
            var r2 = t2.charAt(e3);
            r2 !== "-" && r2 !== "+" || (e3++, r2 === "-" && (i2 = true));
          }
          for (var o2 = new F(), s2 = 0, a2 = 0, u2 = 0; !(e3 >= n2); ) {
            var l2 = t2.charAt(e3);
            if (e3++, A.isDigit(l2)) {
              var c2 = l2 - "0";
              o2.selfMultiply(F.TEN), o2.selfAdd(c2), s2++;
            } else {
              if (l2 !== ".") {
                if (l2 === "e" || l2 === "E") {
                  var p2 = t2.substring(e3);
                  try {
                    u2 = M.parseInt(p2);
                  } catch (e4) {
                    throw e4 instanceof Error ? new Error("Invalid exponent " + p2 + " in string " + t2) : e4;
                  }
                  break;
                }
                throw new Error("Unexpected character '" + l2 + "' at position " + e3 + " in string " + t2);
              }
              a2 = s2;
            }
          }
          var h2 = o2, f2 = s2 - a2 - u2;
          if (f2 === 0)
            h2 = o2;
          else if (f2 > 0) {
            var g2 = F.TEN.pow(f2);
            h2 = o2.divide(g2);
          } else if (f2 < 0) {
            var d2 = F.TEN.pow(-f2);
            h2 = o2.multiply(d2);
          }
          return i2 ? h2.negate() : h2;
        }, F.createNaN = function() {
          return new F(v.NaN, v.NaN);
        }, F.copy = function(t2) {
          return new F(t2);
        }, F.magnitude = function(t2) {
          var e3 = Math.abs(t2), n2 = Math.log(e3) / Math.log(10), i2 = Math.trunc(Math.floor(n2));
          return 10 * Math.pow(10, i2) <= e3 && (i2 += 1), i2;
        }, F.stringOfChar = function(t2, e3) {
          for (var n2 = new D(), i2 = 0; i2 < e3; i2++)
            n2.append(t2);
          return n2.toString();
        }, G.PI.get = function() {
          return new F(3.141592653589793, 12246467991473532e-32);
        }, G.TWO_PI.get = function() {
          return new F(6.283185307179586, 24492935982947064e-32);
        }, G.PI_2.get = function() {
          return new F(1.5707963267948966, 6123233995736766e-32);
        }, G.E.get = function() {
          return new F(2.718281828459045, 14456468917292502e-32);
        }, G.NaN.get = function() {
          return new F(v.NaN, v.NaN);
        }, G.EPS.get = function() {
          return 123259516440783e-46;
        }, G.SPLIT.get = function() {
          return 134217729;
        }, G.MAX_PRINT_DIGITS.get = function() {
          return 32;
        }, G.TEN.get = function() {
          return F.valueOf(10);
        }, G.ONE.get = function() {
          return F.valueOf(1);
        }, G.SCI_NOT_EXPONENT_CHAR.get = function() {
          return "E";
        }, G.SCI_NOT_ZERO.get = function() {
          return "0.0E0";
        }, Object.defineProperties(F, G);
        var q = function() {
        }, B2 = { DP_SAFE_EPSILON: { configurable: true } };
        q.prototype.interfaces_ = function() {
          return [];
        }, q.prototype.getClass = function() {
          return q;
        }, q.orientationIndex = function(t2, e3, n2) {
          var i2 = q.orientationIndexFilter(t2, e3, n2);
          if (i2 <= 1)
            return i2;
          var r2 = F.valueOf(e3.x).selfAdd(-t2.x), o2 = F.valueOf(e3.y).selfAdd(-t2.y), s2 = F.valueOf(n2.x).selfAdd(-e3.x), a2 = F.valueOf(n2.y).selfAdd(-e3.y);
          return r2.selfMultiply(a2).selfSubtract(o2.selfMultiply(s2)).signum();
        }, q.signOfDet2x2 = function(t2, e3, n2, i2) {
          return t2.multiply(i2).selfSubtract(e3.multiply(n2)).signum();
        }, q.intersection = function(t2, e3, n2, i2) {
          var r2 = F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(F.valueOf(e3.x).selfSubtract(t2.x)), o2 = F.valueOf(i2.x).selfSubtract(n2.x).selfMultiply(F.valueOf(e3.y).selfSubtract(t2.y)), s2 = r2.subtract(o2), a2 = F.valueOf(i2.x).selfSubtract(n2.x).selfMultiply(F.valueOf(t2.y).selfSubtract(n2.y)), u2 = F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(F.valueOf(t2.x).selfSubtract(n2.x)), l2 = a2.subtract(u2).selfDivide(s2).doubleValue(), c2 = F.valueOf(t2.x).selfAdd(F.valueOf(e3.x).selfSubtract(t2.x).selfMultiply(l2)).doubleValue(), p2 = F.valueOf(e3.x).selfSubtract(t2.x).selfMultiply(F.valueOf(t2.y).selfSubtract(n2.y)), h2 = F.valueOf(e3.y).selfSubtract(t2.y).selfMultiply(F.valueOf(t2.x).selfSubtract(n2.x)), f2 = p2.subtract(h2).selfDivide(s2).doubleValue(), g2 = F.valueOf(n2.y).selfAdd(F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(f2)).doubleValue();
          return new C(c2, g2);
        }, q.orientationIndexFilter = function(t2, e3, n2) {
          var i2 = null, r2 = (t2.x - n2.x) * (e3.y - n2.y), o2 = (t2.y - n2.y) * (e3.x - n2.x), s2 = r2 - o2;
          if (r2 > 0) {
            if (o2 <= 0)
              return q.signum(s2);
            i2 = r2 + o2;
          } else {
            if (!(r2 < 0))
              return q.signum(s2);
            if (o2 >= 0)
              return q.signum(s2);
            i2 = -r2 - o2;
          }
          var a2 = q.DP_SAFE_EPSILON * i2;
          return s2 >= a2 || -s2 >= a2 ? q.signum(s2) : 2;
        }, q.signum = function(t2) {
          return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
        }, B2.DP_SAFE_EPSILON.get = function() {
          return 1e-15;
        }, Object.defineProperties(q, B2);
        var V = function() {
        }, U = { X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true }, M: { configurable: true } };
        U.X.get = function() {
          return 0;
        }, U.Y.get = function() {
          return 1;
        }, U.Z.get = function() {
          return 2;
        }, U.M.get = function() {
          return 3;
        }, V.prototype.setOrdinate = function(t2, e3, n2) {
        }, V.prototype.size = function() {
        }, V.prototype.getOrdinate = function(t2, e3) {
        }, V.prototype.getCoordinate = function() {
        }, V.prototype.getCoordinateCopy = function(t2) {
        }, V.prototype.getDimension = function() {
        }, V.prototype.getX = function(t2) {
        }, V.prototype.clone = function() {
        }, V.prototype.expandEnvelope = function(t2) {
        }, V.prototype.copy = function() {
        }, V.prototype.getY = function(t2) {
        }, V.prototype.toCoordinateArray = function() {
        }, V.prototype.interfaces_ = function() {
          return [x2];
        }, V.prototype.getClass = function() {
          return V;
        }, Object.defineProperties(V, U);
        var z = function() {
        }, X = function(t2) {
          function e3() {
            t2.call(this, "Projective point not representable on the Cartesian plane.");
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(z), Y = function() {
        };
        Y.arraycopy = function(t2, e3, n2, i2, r2) {
          for (var o2 = 0, s2 = e3; s2 < e3 + r2; s2++)
            n2[i2 + o2] = t2[s2], o2++;
        }, Y.getProperty = function(t2) {
          return { "line.separator": "\n" }[t2];
        };
        var k = function t2() {
          if (this.x = null, this.y = null, this.w = null, arguments.length === 0)
            this.x = 0, this.y = 0, this.w = 1;
          else if (arguments.length === 1) {
            var e3 = arguments[0];
            this.x = e3.x, this.y = e3.y, this.w = 1;
          } else if (arguments.length === 2) {
            if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
              var n2 = arguments[0], i2 = arguments[1];
              this.x = n2, this.y = i2, this.w = 1;
            } else if (arguments[0] instanceof t2 && arguments[1] instanceof t2) {
              var r2 = arguments[0], o2 = arguments[1];
              this.x = r2.y * o2.w - o2.y * r2.w, this.y = o2.x * r2.w - r2.x * o2.w, this.w = r2.x * o2.y - o2.x * r2.y;
            } else if (arguments[0] instanceof C && arguments[1] instanceof C) {
              var s2 = arguments[0], a2 = arguments[1];
              this.x = s2.y - a2.y, this.y = a2.x - s2.x, this.w = s2.x * a2.y - a2.x * s2.y;
            }
          } else if (arguments.length === 3) {
            var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2];
            this.x = u2, this.y = l2, this.w = c2;
          } else if (arguments.length === 4) {
            var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2], g2 = arguments[3], d2 = p2.y - h2.y, y3 = h2.x - p2.x, _2 = p2.x * h2.y - h2.x * p2.y, m2 = f2.y - g2.y, v2 = g2.x - f2.x, I2 = f2.x * g2.y - g2.x * f2.y;
            this.x = y3 * I2 - v2 * _2, this.y = m2 * _2 - d2 * I2, this.w = d2 * v2 - m2 * y3;
          }
        };
        k.prototype.getY = function() {
          var t2 = this.y / this.w;
          if (v.isNaN(t2) || v.isInfinite(t2))
            throw new X();
          return t2;
        }, k.prototype.getX = function() {
          var t2 = this.x / this.w;
          if (v.isNaN(t2) || v.isInfinite(t2))
            throw new X();
          return t2;
        }, k.prototype.getCoordinate = function() {
          var t2 = new C();
          return t2.x = this.getX(), t2.y = this.getY(), t2;
        }, k.prototype.interfaces_ = function() {
          return [];
        }, k.prototype.getClass = function() {
          return k;
        }, k.intersection = function(t2, e3, n2, i2) {
          var r2 = t2.y - e3.y, o2 = e3.x - t2.x, s2 = t2.x * e3.y - e3.x * t2.y, a2 = n2.y - i2.y, u2 = i2.x - n2.x, l2 = n2.x * i2.y - i2.x * n2.y, c2 = r2 * u2 - a2 * o2, p2 = (o2 * l2 - u2 * s2) / c2, h2 = (a2 * s2 - r2 * l2) / c2;
          if (v.isNaN(p2) || v.isInfinite(p2) || v.isNaN(h2) || v.isInfinite(h2))
            throw new X();
          return new C(p2, h2);
        };
        var j = function t2() {
          if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, arguments.length === 0)
            this.init();
          else if (arguments.length === 1) {
            if (arguments[0] instanceof C) {
              var e3 = arguments[0];
              this.init(e3.x, e3.x, e3.y, e3.y);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.init(n2);
            }
          } else if (arguments.length === 2) {
            var i2 = arguments[0], r2 = arguments[1];
            this.init(i2.x, r2.x, i2.y, r2.y);
          } else if (arguments.length === 4) {
            var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2], u2 = arguments[3];
            this.init(o2, s2, a2, u2);
          }
        }, H = { serialVersionUID: { configurable: true } };
        j.prototype.getArea = function() {
          return this.getWidth() * this.getHeight();
        }, j.prototype.equals = function(t2) {
          if (!(t2 instanceof j))
            return false;
          var e3 = t2;
          return this.isNull() ? e3.isNull() : this._maxx === e3.getMaxX() && this._maxy === e3.getMaxY() && this._minx === e3.getMinX() && this._miny === e3.getMinY();
        }, j.prototype.intersection = function(t2) {
          if (this.isNull() || t2.isNull() || !this.intersects(t2))
            return new j();
          var e3 = this._minx > t2._minx ? this._minx : t2._minx, n2 = this._miny > t2._miny ? this._miny : t2._miny, i2 = this._maxx < t2._maxx ? this._maxx : t2._maxx, r2 = this._maxy < t2._maxy ? this._maxy : t2._maxy;
          return new j(e3, i2, n2, r2);
        }, j.prototype.isNull = function() {
          return this._maxx < this._minx;
        }, j.prototype.getMaxX = function() {
          return this._maxx;
        }, j.prototype.covers = function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              return this.covers(t2.x, t2.y);
            }
            if (arguments[0] instanceof j) {
              var e3 = arguments[0];
              return !this.isNull() && !e3.isNull() && (e3.getMinX() >= this._minx && e3.getMaxX() <= this._maxx && e3.getMinY() >= this._miny && e3.getMaxY() <= this._maxy);
            }
          } else if (arguments.length === 2) {
            var n2 = arguments[0], i2 = arguments[1];
            return !this.isNull() && (n2 >= this._minx && n2 <= this._maxx && i2 >= this._miny && i2 <= this._maxy);
          }
        }, j.prototype.intersects = function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof j) {
              var t2 = arguments[0];
              return !this.isNull() && !t2.isNull() && !(t2._minx > this._maxx || t2._maxx < this._minx || t2._miny > this._maxy || t2._maxy < this._miny);
            }
            if (arguments[0] instanceof C) {
              var e3 = arguments[0];
              return this.intersects(e3.x, e3.y);
            }
          } else if (arguments.length === 2) {
            var n2 = arguments[0], i2 = arguments[1];
            return !this.isNull() && !(n2 > this._maxx || n2 < this._minx || i2 > this._maxy || i2 < this._miny);
          }
        }, j.prototype.getMinY = function() {
          return this._miny;
        }, j.prototype.getMinX = function() {
          return this._minx;
        }, j.prototype.expandToInclude = function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              this.expandToInclude(t2.x, t2.y);
            } else if (arguments[0] instanceof j) {
              var e3 = arguments[0];
              if (e3.isNull())
                return null;
              this.isNull() ? (this._minx = e3.getMinX(), this._maxx = e3.getMaxX(), this._miny = e3.getMinY(), this._maxy = e3.getMaxY()) : (e3._minx < this._minx && (this._minx = e3._minx), e3._maxx > this._maxx && (this._maxx = e3._maxx), e3._miny < this._miny && (this._miny = e3._miny), e3._maxy > this._maxy && (this._maxy = e3._maxy));
            }
          } else if (arguments.length === 2) {
            var n2 = arguments[0], i2 = arguments[1];
            this.isNull() ? (this._minx = n2, this._maxx = n2, this._miny = i2, this._maxy = i2) : (n2 < this._minx && (this._minx = n2), n2 > this._maxx && (this._maxx = n2), i2 < this._miny && (this._miny = i2), i2 > this._maxy && (this._maxy = i2));
          }
        }, j.prototype.minExtent = function() {
          if (this.isNull())
            return 0;
          var t2 = this.getWidth(), e3 = this.getHeight();
          return t2 < e3 ? t2 : e3;
        }, j.prototype.getWidth = function() {
          return this.isNull() ? 0 : this._maxx - this._minx;
        }, j.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.isNull() ? e3.isNull() ? 0 : -1 : e3.isNull() ? 1 : this._minx < e3._minx ? -1 : this._minx > e3._minx ? 1 : this._miny < e3._miny ? -1 : this._miny > e3._miny ? 1 : this._maxx < e3._maxx ? -1 : this._maxx > e3._maxx ? 1 : this._maxy < e3._maxy ? -1 : this._maxy > e3._maxy ? 1 : 0;
        }, j.prototype.translate = function(t2, e3) {
          if (this.isNull())
            return null;
          this.init(this.getMinX() + t2, this.getMaxX() + t2, this.getMinY() + e3, this.getMaxY() + e3);
        }, j.prototype.toString = function() {
          return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
        }, j.prototype.setToNull = function() {
          this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
        }, j.prototype.getHeight = function() {
          return this.isNull() ? 0 : this._maxy - this._miny;
        }, j.prototype.maxExtent = function() {
          if (this.isNull())
            return 0;
          var t2 = this.getWidth(), e3 = this.getHeight();
          return t2 > e3 ? t2 : e3;
        }, j.prototype.expandBy = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            this.expandBy(t2, t2);
          } else if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this.isNull())
              return null;
            this._minx -= e3, this._maxx += e3, this._miny -= n2, this._maxy += n2, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
          }
        }, j.prototype.contains = function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof j) {
              var t2 = arguments[0];
              return this.covers(t2);
            }
            if (arguments[0] instanceof C) {
              var e3 = arguments[0];
              return this.covers(e3);
            }
          } else if (arguments.length === 2) {
            var n2 = arguments[0], i2 = arguments[1];
            return this.covers(n2, i2);
          }
        }, j.prototype.centre = function() {
          return this.isNull() ? null : new C((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
        }, j.prototype.init = function() {
          if (arguments.length === 0)
            this.setToNull();
          else if (arguments.length === 1) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              this.init(t2.x, t2.x, t2.y, t2.y);
            } else if (arguments[0] instanceof j) {
              var e3 = arguments[0];
              this._minx = e3._minx, this._maxx = e3._maxx, this._miny = e3._miny, this._maxy = e3._maxy;
            }
          } else if (arguments.length === 2) {
            var n2 = arguments[0], i2 = arguments[1];
            this.init(n2.x, i2.x, n2.y, i2.y);
          } else if (arguments.length === 4) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
            r2 < o2 ? (this._minx = r2, this._maxx = o2) : (this._minx = o2, this._maxx = r2), s2 < a2 ? (this._miny = s2, this._maxy = a2) : (this._miny = a2, this._maxy = s2);
          }
        }, j.prototype.getMaxY = function() {
          return this._maxy;
        }, j.prototype.distance = function(t2) {
          if (this.intersects(t2))
            return 0;
          var e3 = 0;
          this._maxx < t2._minx ? e3 = t2._minx - this._maxx : this._minx > t2._maxx && (e3 = this._minx - t2._maxx);
          var n2 = 0;
          return this._maxy < t2._miny ? n2 = t2._miny - this._maxy : this._miny > t2._maxy && (n2 = this._miny - t2._maxy), e3 === 0 ? n2 : n2 === 0 ? e3 : Math.sqrt(e3 * e3 + n2 * n2);
        }, j.prototype.hashCode = function() {
          var t2 = 17;
          return t2 = 37 * t2 + C.hashCode(this._minx), t2 = 37 * t2 + C.hashCode(this._maxx), t2 = 37 * t2 + C.hashCode(this._miny), t2 = 37 * t2 + C.hashCode(this._maxy);
        }, j.prototype.interfaces_ = function() {
          return [E, e];
        }, j.prototype.getClass = function() {
          return j;
        }, j.intersects = function() {
          if (arguments.length === 3) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
            return n2.x >= (t2.x < e3.x ? t2.x : e3.x) && n2.x <= (t2.x > e3.x ? t2.x : e3.x) && n2.y >= (t2.y < e3.y ? t2.y : e3.y) && n2.y <= (t2.y > e3.y ? t2.y : e3.y);
          }
          if (arguments.length === 4) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = arguments[3], a2 = Math.min(o2.x, s2.x), u2 = Math.max(o2.x, s2.x), l2 = Math.min(i2.x, r2.x), c2 = Math.max(i2.x, r2.x);
            return !(l2 > u2) && (!(c2 < a2) && (a2 = Math.min(o2.y, s2.y), u2 = Math.max(o2.y, s2.y), l2 = Math.min(i2.y, r2.y), c2 = Math.max(i2.y, r2.y), !(l2 > u2) && !(c2 < a2)));
          }
        }, H.serialVersionUID.get = function() {
          return 5873921885273102e3;
        }, Object.defineProperties(j, H);
        var W = { typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/, emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/, spaces: /\s+/, parenComma: /\)\s*,\s*\(/, doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/, trimParens: /^\s*\(?(.*?)\)?\s*$/ }, K = function(t2) {
          this.geometryFactory = t2 || new _e();
        };
        K.prototype.read = function(t2) {
          var e3, n2, i2;
          t2 = t2.replace(/[\n\r]/g, " ");
          var r2 = W.typeStr.exec(t2);
          if (t2.search("EMPTY") !== -1 && ((r2 = W.emptyTypeStr.exec(t2))[2] = void 0), r2 && (n2 = r2[1].toLowerCase(), i2 = r2[2], Q[n2] && (e3 = Q[n2].apply(this, [i2]))), e3 === void 0)
            throw new Error("Could not parse WKT " + t2);
          return e3;
        }, K.prototype.write = function(t2) {
          return this.extractGeometry(t2);
        }, K.prototype.extractGeometry = function(t2) {
          var e3 = t2.getGeometryType().toLowerCase();
          if (!J[e3])
            return null;
          var n2 = e3.toUpperCase();
          return t2.isEmpty() ? n2 + " EMPTY" : n2 + "(" + J[e3].apply(this, [t2]) + ")";
        };
        var J = { coordinate: function(t2) {
          return t2.x + " " + t2.y;
        }, point: function(t2) {
          return J.coordinate.call(this, t2._coordinates._coordinates[0]);
        }, multipoint: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push("(" + J.point.apply(this, [t2._geometries[n2]]) + ")");
          return e3.join(",");
        }, linestring: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._points._coordinates.length; n2 < i2; ++n2)
            e3.push(J.coordinate.apply(this, [t2._points._coordinates[n2]]));
          return e3.join(",");
        }, linearring: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._points._coordinates.length; n2 < i2; ++n2)
            e3.push(J.coordinate.apply(this, [t2._points._coordinates[n2]]));
          return e3.join(",");
        }, multilinestring: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push("(" + J.linestring.apply(this, [t2._geometries[n2]]) + ")");
          return e3.join(",");
        }, polygon: function(t2) {
          var e3 = [];
          e3.push("(" + J.linestring.apply(this, [t2._shell]) + ")");
          for (var n2 = 0, i2 = t2._holes.length; n2 < i2; ++n2)
            e3.push("(" + J.linestring.apply(this, [t2._holes[n2]]) + ")");
          return e3.join(",");
        }, multipolygon: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push("(" + J.polygon.apply(this, [t2._geometries[n2]]) + ")");
          return e3.join(",");
        }, geometrycollection: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push(this.extractGeometry(t2._geometries[n2]));
          return e3.join(",");
        } }, Q = { point: function(t2) {
          if (t2 === void 0)
            return this.geometryFactory.createPoint();
          var e3 = t2.trim().split(W.spaces);
          return this.geometryFactory.createPoint(new C(Number.parseFloat(e3[0]), Number.parseFloat(e3[1])));
        }, multipoint: function(t2) {
          if (t2 === void 0)
            return this.geometryFactory.createMultiPoint();
          for (var e3, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.point.apply(this, [e3]));
          return this.geometryFactory.createMultiPoint(i2);
        }, linestring: function(t2) {
          if (t2 === void 0)
            return this.geometryFactory.createLineString();
          for (var e3, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].trim().split(W.spaces), i2.push(new C(Number.parseFloat(e3[0]), Number.parseFloat(e3[1])));
          return this.geometryFactory.createLineString(i2);
        }, linearring: function(t2) {
          if (t2 === void 0)
            return this.geometryFactory.createLinearRing();
          for (var e3, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].trim().split(W.spaces), i2.push(new C(Number.parseFloat(e3[0]), Number.parseFloat(e3[1])));
          return this.geometryFactory.createLinearRing(i2);
        }, multilinestring: function(t2) {
          if (t2 === void 0)
            return this.geometryFactory.createMultiLineString();
          for (var e3, n2 = t2.trim().split(W.parenComma), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.linestring.apply(this, [e3]));
          return this.geometryFactory.createMultiLineString(i2);
        }, polygon: function(t2) {
          if (t2 === void 0)
            return this.geometryFactory.createPolygon();
          for (var e3, n2, i2, r2, o2 = t2.trim().split(W.parenComma), s2 = [], a2 = 0, u2 = o2.length; a2 < u2; ++a2)
            e3 = o2[a2].replace(W.trimParens, "$1"), n2 = Q.linestring.apply(this, [e3]), i2 = this.geometryFactory.createLinearRing(n2._points), a2 === 0 ? r2 = i2 : s2.push(i2);
          return this.geometryFactory.createPolygon(r2, s2);
        }, multipolygon: function(t2) {
          if (t2 === void 0)
            return this.geometryFactory.createMultiPolygon();
          for (var e3, n2 = t2.trim().split(W.doubleParenComma), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.polygon.apply(this, [e3]));
          return this.geometryFactory.createMultiPolygon(i2);
        }, geometrycollection: function(t2) {
          if (t2 === void 0)
            return this.geometryFactory.createGeometryCollection();
          for (var e3 = (t2 = t2.replace(/,\s*([A-Za-z])/g, "|$1")).trim().split("|"), n2 = [], i2 = 0, r2 = e3.length; i2 < r2; ++i2)
            n2.push(this.read(e3[i2]));
          return this.geometryFactory.createGeometryCollection(n2);
        } }, Z = function(t2) {
          this.parser = new K(t2);
        };
        Z.prototype.write = function(t2) {
          return this.parser.write(t2);
        }, Z.toLineString = function(t2, e3) {
          if (arguments.length !== 2)
            throw new Error("Not implemented");
          return "LINESTRING ( " + t2.x + " " + t2.y + ", " + e3.x + " " + e3.y + " )";
        };
        var $ = function(t2) {
          function e3(e4) {
            t2.call(this, e4), this.name = "RuntimeException", this.message = e4, this.stack = new t2().stack;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3;
        }(Error), tt = function(t2) {
          function e3() {
            if (t2.call(this), arguments.length === 0)
              t2.call(this);
            else if (arguments.length === 1) {
              var e4 = arguments[0];
              t2.call(this, e4);
            }
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }($), et = function() {
        };
        et.prototype.interfaces_ = function() {
          return [];
        }, et.prototype.getClass = function() {
          return et;
        }, et.shouldNeverReachHere = function() {
          if (arguments.length === 0)
            et.shouldNeverReachHere(null);
          else if (arguments.length === 1) {
            var t2 = arguments[0];
            throw new tt("Should never reach here" + (t2 !== null ? ": " + t2 : ""));
          }
        }, et.isTrue = function() {
          var t2, e3;
          if (arguments.length === 1)
            t2 = arguments[0], et.isTrue(t2, null);
          else if (arguments.length === 2 && (t2 = arguments[0], e3 = arguments[1], !t2))
            throw e3 === null ? new tt() : new tt(e3);
        }, et.equals = function() {
          var t2, e3, n2;
          if (arguments.length === 2)
            t2 = arguments[0], e3 = arguments[1], et.equals(t2, e3, null);
          else if (arguments.length === 3 && (t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], !e3.equals(t2)))
            throw new tt("Expected " + t2 + " but encountered " + e3 + (n2 !== null ? ": " + n2 : ""));
        };
        var nt = function() {
          this._result = null, this._inputLines = Array(2).fill().map(function() {
            return Array(2);
          }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new C(), this._intPt[1] = new C(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
        }, it = { DONT_INTERSECT: { configurable: true }, DO_INTERSECT: { configurable: true }, COLLINEAR: { configurable: true }, NO_INTERSECTION: { configurable: true }, POINT_INTERSECTION: { configurable: true }, COLLINEAR_INTERSECTION: { configurable: true } };
        nt.prototype.getIndexAlongSegment = function(t2, e3) {
          return this.computeIntLineIndex(), this._intLineIndex[t2][e3];
        }, nt.prototype.getTopologySummary = function() {
          var t2 = new D();
          return this.isEndPoint() && t2.append(" endpoint"), this._isProper && t2.append(" proper"), this.isCollinear() && t2.append(" collinear"), t2.toString();
        }, nt.prototype.computeIntersection = function(t2, e3, n2, i2) {
          this._inputLines[0][0] = t2, this._inputLines[0][1] = e3, this._inputLines[1][0] = n2, this._inputLines[1][1] = i2, this._result = this.computeIntersect(t2, e3, n2, i2);
        }, nt.prototype.getIntersectionNum = function() {
          return this._result;
        }, nt.prototype.computeIntLineIndex = function() {
          if (arguments.length === 0)
            this._intLineIndex === null && (this._intLineIndex = Array(2).fill().map(function() {
              return Array(2);
            }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
          else if (arguments.length === 1) {
            var t2 = arguments[0];
            this.getEdgeDistance(t2, 0) > this.getEdgeDistance(t2, 1) ? (this._intLineIndex[t2][0] = 0, this._intLineIndex[t2][1] = 1) : (this._intLineIndex[t2][0] = 1, this._intLineIndex[t2][1] = 0);
          }
        }, nt.prototype.isProper = function() {
          return this.hasIntersection() && this._isProper;
        }, nt.prototype.setPrecisionModel = function(t2) {
          this._precisionModel = t2;
        }, nt.prototype.isInteriorIntersection = function() {
          if (arguments.length === 0)
            return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
          if (arguments.length === 1) {
            for (var t2 = arguments[0], e3 = 0; e3 < this._result; e3++)
              if (!this._intPt[e3].equals2D(this._inputLines[t2][0]) && !this._intPt[e3].equals2D(this._inputLines[t2][1]))
                return true;
            return false;
          }
        }, nt.prototype.getIntersection = function(t2) {
          return this._intPt[t2];
        }, nt.prototype.isEndPoint = function() {
          return this.hasIntersection() && !this._isProper;
        }, nt.prototype.hasIntersection = function() {
          return this._result !== nt.NO_INTERSECTION;
        }, nt.prototype.getEdgeDistance = function(t2, e3) {
          return nt.computeEdgeDistance(this._intPt[e3], this._inputLines[t2][0], this._inputLines[t2][1]);
        }, nt.prototype.isCollinear = function() {
          return this._result === nt.COLLINEAR_INTERSECTION;
        }, nt.prototype.toString = function() {
          return Z.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Z.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
        }, nt.prototype.getEndpoint = function(t2, e3) {
          return this._inputLines[t2][e3];
        }, nt.prototype.isIntersection = function(t2) {
          for (var e3 = 0; e3 < this._result; e3++)
            if (this._intPt[e3].equals2D(t2))
              return true;
          return false;
        }, nt.prototype.getIntersectionAlongSegment = function(t2, e3) {
          return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t2][e3]];
        }, nt.prototype.interfaces_ = function() {
          return [];
        }, nt.prototype.getClass = function() {
          return nt;
        }, nt.computeEdgeDistance = function(t2, e3, n2) {
          var i2 = Math.abs(n2.x - e3.x), r2 = Math.abs(n2.y - e3.y), o2 = -1;
          if (t2.equals(e3))
            o2 = 0;
          else if (t2.equals(n2))
            o2 = i2 > r2 ? i2 : r2;
          else {
            var s2 = Math.abs(t2.x - e3.x), a2 = Math.abs(t2.y - e3.y);
            (o2 = i2 > r2 ? s2 : a2) !== 0 || t2.equals(e3) || (o2 = Math.max(s2, a2));
          }
          return et.isTrue(!(o2 === 0 && !t2.equals(e3)), "Bad distance calculation"), o2;
        }, nt.nonRobustComputeEdgeDistance = function(t2, e3, n2) {
          var i2 = t2.x - e3.x, r2 = t2.y - e3.y, o2 = Math.sqrt(i2 * i2 + r2 * r2);
          return et.isTrue(!(o2 === 0 && !t2.equals(e3)), "Invalid distance calculation"), o2;
        }, it.DONT_INTERSECT.get = function() {
          return 0;
        }, it.DO_INTERSECT.get = function() {
          return 1;
        }, it.COLLINEAR.get = function() {
          return 2;
        }, it.NO_INTERSECTION.get = function() {
          return 0;
        }, it.POINT_INTERSECTION.get = function() {
          return 1;
        }, it.COLLINEAR_INTERSECTION.get = function() {
          return 2;
        }, Object.defineProperties(nt, it);
        var rt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.isInSegmentEnvelopes = function(t3) {
            var e4 = new j(this._inputLines[0][0], this._inputLines[0][1]), n2 = new j(this._inputLines[1][0], this._inputLines[1][1]);
            return e4.contains(t3) && n2.contains(t3);
          }, e3.prototype.computeIntersection = function() {
            if (arguments.length !== 3)
              return t2.prototype.computeIntersection.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            if (this._isProper = false, j.intersects(n2, i2, e4) && at.orientationIndex(n2, i2, e4) === 0 && at.orientationIndex(i2, n2, e4) === 0)
              return this._isProper = true, (e4.equals(n2) || e4.equals(i2)) && (this._isProper = false), this._result = t2.POINT_INTERSECTION, null;
            this._result = t2.NO_INTERSECTION;
          }, e3.prototype.normalizeToMinimum = function(t3, e4, n2, i2, r2) {
            r2.x = this.smallestInAbsValue(t3.x, e4.x, n2.x, i2.x), r2.y = this.smallestInAbsValue(t3.y, e4.y, n2.y, i2.y), t3.x -= r2.x, t3.y -= r2.y, e4.x -= r2.x, e4.y -= r2.y, n2.x -= r2.x, n2.y -= r2.y, i2.x -= r2.x, i2.y -= r2.y;
          }, e3.prototype.safeHCoordinateIntersection = function(t3, n2, i2, r2) {
            var o2 = null;
            try {
              o2 = k.intersection(t3, n2, i2, r2);
            } catch (s2) {
              if (!(s2 instanceof X))
                throw s2;
              o2 = e3.nearestEndpoint(t3, n2, i2, r2);
            }
            return o2;
          }, e3.prototype.intersection = function(t3, n2, i2, r2) {
            var o2 = this.intersectionWithNormalization(t3, n2, i2, r2);
            return this.isInSegmentEnvelopes(o2) || (o2 = new C(e3.nearestEndpoint(t3, n2, i2, r2))), this._precisionModel !== null && this._precisionModel.makePrecise(o2), o2;
          }, e3.prototype.smallestInAbsValue = function(t3, e4, n2, i2) {
            var r2 = t3, o2 = Math.abs(r2);
            return Math.abs(e4) < o2 && (r2 = e4, o2 = Math.abs(e4)), Math.abs(n2) < o2 && (r2 = n2, o2 = Math.abs(n2)), Math.abs(i2) < o2 && (r2 = i2), r2;
          }, e3.prototype.checkDD = function(t3, e4, n2, i2, r2) {
            var o2 = q.intersection(t3, e4, n2, i2), s2 = this.isInSegmentEnvelopes(o2);
            Y.out.println("DD in env = " + s2 + "  --------------------- " + o2), r2.distance(o2) > 1e-4 && Y.out.println("Distance = " + r2.distance(o2));
          }, e3.prototype.intersectionWithNormalization = function(t3, e4, n2, i2) {
            var r2 = new C(t3), o2 = new C(e4), s2 = new C(n2), a2 = new C(i2), u2 = new C();
            this.normalizeToEnvCentre(r2, o2, s2, a2, u2);
            var l2 = this.safeHCoordinateIntersection(r2, o2, s2, a2);
            return l2.x += u2.x, l2.y += u2.y, l2;
          }, e3.prototype.computeCollinearIntersection = function(e4, n2, i2, r2) {
            var o2 = j.intersects(e4, n2, i2), s2 = j.intersects(e4, n2, r2), a2 = j.intersects(i2, r2, e4), u2 = j.intersects(i2, r2, n2);
            return o2 && s2 ? (this._intPt[0] = i2, this._intPt[1] = r2, t2.COLLINEAR_INTERSECTION) : a2 && u2 ? (this._intPt[0] = e4, this._intPt[1] = n2, t2.COLLINEAR_INTERSECTION) : o2 && a2 ? (this._intPt[0] = i2, this._intPt[1] = e4, !i2.equals(e4) || s2 || u2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : o2 && u2 ? (this._intPt[0] = i2, this._intPt[1] = n2, !i2.equals(n2) || s2 || a2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : s2 && a2 ? (this._intPt[0] = r2, this._intPt[1] = e4, !r2.equals(e4) || o2 || u2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : s2 && u2 ? (this._intPt[0] = r2, this._intPt[1] = n2, !r2.equals(n2) || o2 || a2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : t2.NO_INTERSECTION;
          }, e3.prototype.normalizeToEnvCentre = function(t3, e4, n2, i2, r2) {
            var o2 = t3.x < e4.x ? t3.x : e4.x, s2 = t3.y < e4.y ? t3.y : e4.y, a2 = t3.x > e4.x ? t3.x : e4.x, u2 = t3.y > e4.y ? t3.y : e4.y, l2 = n2.x < i2.x ? n2.x : i2.x, c2 = n2.y < i2.y ? n2.y : i2.y, p2 = n2.x > i2.x ? n2.x : i2.x, h2 = n2.y > i2.y ? n2.y : i2.y, f2 = ((o2 > l2 ? o2 : l2) + (a2 < p2 ? a2 : p2)) / 2, g2 = ((s2 > c2 ? s2 : c2) + (u2 < h2 ? u2 : h2)) / 2;
            r2.x = f2, r2.y = g2, t3.x -= r2.x, t3.y -= r2.y, e4.x -= r2.x, e4.y -= r2.y, n2.x -= r2.x, n2.y -= r2.y, i2.x -= r2.x, i2.y -= r2.y;
          }, e3.prototype.computeIntersect = function(e4, n2, i2, r2) {
            if (this._isProper = false, !j.intersects(e4, n2, i2, r2))
              return t2.NO_INTERSECTION;
            var o2 = at.orientationIndex(e4, n2, i2), s2 = at.orientationIndex(e4, n2, r2);
            if (o2 > 0 && s2 > 0 || o2 < 0 && s2 < 0)
              return t2.NO_INTERSECTION;
            var a2 = at.orientationIndex(i2, r2, e4), u2 = at.orientationIndex(i2, r2, n2);
            if (a2 > 0 && u2 > 0 || a2 < 0 && u2 < 0)
              return t2.NO_INTERSECTION;
            return o2 === 0 && s2 === 0 && a2 === 0 && u2 === 0 ? this.computeCollinearIntersection(e4, n2, i2, r2) : (o2 === 0 || s2 === 0 || a2 === 0 || u2 === 0 ? (this._isProper = false, e4.equals2D(i2) || e4.equals2D(r2) ? this._intPt[0] = e4 : n2.equals2D(i2) || n2.equals2D(r2) ? this._intPt[0] = n2 : o2 === 0 ? this._intPt[0] = new C(i2) : s2 === 0 ? this._intPt[0] = new C(r2) : a2 === 0 ? this._intPt[0] = new C(e4) : u2 === 0 && (this._intPt[0] = new C(n2))) : (this._isProper = true, this._intPt[0] = this.intersection(e4, n2, i2, r2)), t2.POINT_INTERSECTION);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.nearestEndpoint = function(t3, e4, n2, i2) {
            var r2 = t3, o2 = at.distancePointLine(t3, n2, i2), s2 = at.distancePointLine(e4, n2, i2);
            return s2 < o2 && (o2 = s2, r2 = e4), (s2 = at.distancePointLine(n2, t3, e4)) < o2 && (o2 = s2, r2 = n2), (s2 = at.distancePointLine(i2, t3, e4)) < o2 && (o2 = s2, r2 = i2), r2;
          }, e3;
        }(nt), ot = function() {
        };
        ot.prototype.interfaces_ = function() {
          return [];
        }, ot.prototype.getClass = function() {
          return ot;
        }, ot.orientationIndex = function(t2, e3, n2) {
          var i2 = e3.x - t2.x, r2 = e3.y - t2.y, o2 = n2.x - e3.x, s2 = n2.y - e3.y;
          return ot.signOfDet2x2(i2, r2, o2, s2);
        }, ot.signOfDet2x2 = function(t2, e3, n2, i2) {
          var r2 = null, o2 = null, s2 = null;
          if (r2 = 1, t2 === 0 || i2 === 0)
            return e3 === 0 || n2 === 0 ? 0 : e3 > 0 ? n2 > 0 ? -r2 : r2 : n2 > 0 ? r2 : -r2;
          if (e3 === 0 || n2 === 0)
            return i2 > 0 ? t2 > 0 ? r2 : -r2 : t2 > 0 ? -r2 : r2;
          if (e3 > 0 ? i2 > 0 ? e3 <= i2 || (r2 = -r2, o2 = t2, t2 = n2, n2 = o2, o2 = e3, e3 = i2, i2 = o2) : e3 <= -i2 ? (r2 = -r2, n2 = -n2, i2 = -i2) : (o2 = t2, t2 = -n2, n2 = o2, o2 = e3, e3 = -i2, i2 = o2) : i2 > 0 ? -e3 <= i2 ? (r2 = -r2, t2 = -t2, e3 = -e3) : (o2 = -t2, t2 = n2, n2 = o2, o2 = -e3, e3 = i2, i2 = o2) : e3 >= i2 ? (t2 = -t2, e3 = -e3, n2 = -n2, i2 = -i2) : (r2 = -r2, o2 = -t2, t2 = -n2, n2 = o2, o2 = -e3, e3 = -i2, i2 = o2), t2 > 0) {
            if (!(n2 > 0))
              return r2;
            if (!(t2 <= n2))
              return r2;
          } else {
            if (n2 > 0)
              return -r2;
            if (!(t2 >= n2))
              return -r2;
            r2 = -r2, t2 = -t2, n2 = -n2;
          }
          for (; ; ) {
            if (s2 = Math.floor(n2 / t2), n2 -= s2 * t2, (i2 -= s2 * e3) < 0)
              return -r2;
            if (i2 > e3)
              return r2;
            if (t2 > n2 + n2) {
              if (e3 < i2 + i2)
                return r2;
            } else {
              if (e3 > i2 + i2)
                return -r2;
              n2 = t2 - n2, i2 = e3 - i2, r2 = -r2;
            }
            if (i2 === 0)
              return n2 === 0 ? 0 : -r2;
            if (n2 === 0)
              return r2;
            if (s2 = Math.floor(t2 / n2), t2 -= s2 * n2, (e3 -= s2 * i2) < 0)
              return r2;
            if (e3 > i2)
              return -r2;
            if (n2 > t2 + t2) {
              if (i2 < e3 + e3)
                return -r2;
            } else {
              if (i2 > e3 + e3)
                return r2;
              t2 = n2 - t2, e3 = i2 - e3, r2 = -r2;
            }
            if (e3 === 0)
              return t2 === 0 ? 0 : r2;
            if (t2 === 0)
              return -r2;
          }
        };
        var st = function() {
          this._p = null, this._crossingCount = 0, this._isPointOnSegment = false;
          var t2 = arguments[0];
          this._p = t2;
        };
        st.prototype.countSegment = function(t2, e3) {
          if (t2.x < this._p.x && e3.x < this._p.x)
            return null;
          if (this._p.x === e3.x && this._p.y === e3.y)
            return this._isPointOnSegment = true, null;
          if (t2.y === this._p.y && e3.y === this._p.y) {
            var n2 = t2.x, i2 = e3.x;
            return n2 > i2 && (n2 = e3.x, i2 = t2.x), this._p.x >= n2 && this._p.x <= i2 && (this._isPointOnSegment = true), null;
          }
          if (t2.y > this._p.y && e3.y <= this._p.y || e3.y > this._p.y && t2.y <= this._p.y) {
            var r2 = t2.x - this._p.x, o2 = t2.y - this._p.y, s2 = e3.x - this._p.x, a2 = e3.y - this._p.y, u2 = ot.signOfDet2x2(r2, o2, s2, a2);
            if (u2 === 0)
              return this._isPointOnSegment = true, null;
            a2 < o2 && (u2 = -u2), u2 > 0 && this._crossingCount++;
          }
        }, st.prototype.isPointInPolygon = function() {
          return this.getLocation() !== w.EXTERIOR;
        }, st.prototype.getLocation = function() {
          return this._isPointOnSegment ? w.BOUNDARY : this._crossingCount % 2 == 1 ? w.INTERIOR : w.EXTERIOR;
        }, st.prototype.isOnSegment = function() {
          return this._isPointOnSegment;
        }, st.prototype.interfaces_ = function() {
          return [];
        }, st.prototype.getClass = function() {
          return st;
        }, st.locatePointInRing = function() {
          if (arguments[0] instanceof C && T(arguments[1], V)) {
            for (var t2 = arguments[0], e3 = arguments[1], n2 = new st(t2), i2 = new C(), r2 = new C(), o2 = 1; o2 < e3.size(); o2++)
              if (e3.getCoordinate(o2, i2), e3.getCoordinate(o2 - 1, r2), n2.countSegment(i2, r2), n2.isOnSegment())
                return n2.getLocation();
            return n2.getLocation();
          }
          if (arguments[0] instanceof C && arguments[1] instanceof Array) {
            for (var s2 = arguments[0], a2 = arguments[1], u2 = new st(s2), l2 = 1; l2 < a2.length; l2++) {
              var c2 = a2[l2], p2 = a2[l2 - 1];
              if (u2.countSegment(c2, p2), u2.isOnSegment())
                return u2.getLocation();
            }
            return u2.getLocation();
          }
        };
        var at = function() {
        }, ut = { CLOCKWISE: { configurable: true }, RIGHT: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, LEFT: { configurable: true }, COLLINEAR: { configurable: true }, STRAIGHT: { configurable: true } };
        at.prototype.interfaces_ = function() {
          return [];
        }, at.prototype.getClass = function() {
          return at;
        }, at.orientationIndex = function(t2, e3, n2) {
          return q.orientationIndex(t2, e3, n2);
        }, at.signedArea = function() {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0];
            if (t2.length < 3)
              return 0;
            for (var e3 = 0, n2 = t2[0].x, i2 = 1; i2 < t2.length - 1; i2++) {
              var r2 = t2[i2].x - n2, o2 = t2[i2 + 1].y;
              e3 += r2 * (t2[i2 - 1].y - o2);
            }
            return e3 / 2;
          }
          if (T(arguments[0], V)) {
            var s2 = arguments[0], a2 = s2.size();
            if (a2 < 3)
              return 0;
            var u2 = new C(), l2 = new C(), c2 = new C();
            s2.getCoordinate(0, l2), s2.getCoordinate(1, c2);
            var p2 = l2.x;
            c2.x -= p2;
            for (var h2 = 0, f2 = 1; f2 < a2 - 1; f2++)
              u2.y = l2.y, l2.x = c2.x, l2.y = c2.y, s2.getCoordinate(f2 + 1, c2), c2.x -= p2, h2 += l2.x * (u2.y - c2.y);
            return h2 / 2;
          }
        }, at.distanceLineLine = function(t2, e3, n2, i2) {
          if (t2.equals(e3))
            return at.distancePointLine(t2, n2, i2);
          if (n2.equals(i2))
            return at.distancePointLine(i2, t2, e3);
          var r2 = false;
          if (j.intersects(t2, e3, n2, i2)) {
            var o2 = (e3.x - t2.x) * (i2.y - n2.y) - (e3.y - t2.y) * (i2.x - n2.x);
            if (o2 === 0)
              r2 = true;
            else {
              var s2 = (t2.y - n2.y) * (i2.x - n2.x) - (t2.x - n2.x) * (i2.y - n2.y), a2 = ((t2.y - n2.y) * (e3.x - t2.x) - (t2.x - n2.x) * (e3.y - t2.y)) / o2, u2 = s2 / o2;
              (u2 < 0 || u2 > 1 || a2 < 0 || a2 > 1) && (r2 = true);
            }
          } else
            r2 = true;
          return r2 ? R.min(at.distancePointLine(t2, n2, i2), at.distancePointLine(e3, n2, i2), at.distancePointLine(n2, t2, e3), at.distancePointLine(i2, t2, e3)) : 0;
        }, at.isPointInRing = function(t2, e3) {
          return at.locatePointInRing(t2, e3) !== w.EXTERIOR;
        }, at.computeLength = function(t2) {
          var e3 = t2.size();
          if (e3 <= 1)
            return 0;
          var n2 = 0, i2 = new C();
          t2.getCoordinate(0, i2);
          for (var r2 = i2.x, o2 = i2.y, s2 = 1; s2 < e3; s2++) {
            t2.getCoordinate(s2, i2);
            var a2 = i2.x, u2 = i2.y, l2 = a2 - r2, c2 = u2 - o2;
            n2 += Math.sqrt(l2 * l2 + c2 * c2), r2 = a2, o2 = u2;
          }
          return n2;
        }, at.isCCW = function(t2) {
          var e3 = t2.length - 1;
          if (e3 < 3)
            throw new m("Ring has fewer than 4 points, so orientation cannot be determined");
          for (var n2 = t2[0], i2 = 0, r2 = 1; r2 <= e3; r2++) {
            var o2 = t2[r2];
            o2.y > n2.y && (n2 = o2, i2 = r2);
          }
          var s2 = i2;
          do {
            (s2 -= 1) < 0 && (s2 = e3);
          } while (t2[s2].equals2D(n2) && s2 !== i2);
          var a2 = i2;
          do {
            a2 = (a2 + 1) % e3;
          } while (t2[a2].equals2D(n2) && a2 !== i2);
          var u2 = t2[s2], l2 = t2[a2];
          if (u2.equals2D(n2) || l2.equals2D(n2) || u2.equals2D(l2))
            return false;
          var c2 = at.computeOrientation(u2, n2, l2), p2 = false;
          return p2 = c2 === 0 ? u2.x > l2.x : c2 > 0, p2;
        }, at.locatePointInRing = function(t2, e3) {
          return st.locatePointInRing(t2, e3);
        }, at.distancePointLinePerpendicular = function(t2, e3, n2) {
          var i2 = (n2.x - e3.x) * (n2.x - e3.x) + (n2.y - e3.y) * (n2.y - e3.y), r2 = ((e3.y - t2.y) * (n2.x - e3.x) - (e3.x - t2.x) * (n2.y - e3.y)) / i2;
          return Math.abs(r2) * Math.sqrt(i2);
        }, at.computeOrientation = function(t2, e3, n2) {
          return at.orientationIndex(t2, e3, n2);
        }, at.distancePointLine = function() {
          if (arguments.length === 2) {
            var t2 = arguments[0], e3 = arguments[1];
            if (e3.length === 0)
              throw new m("Line array must contain at least one vertex");
            for (var n2 = t2.distance(e3[0]), i2 = 0; i2 < e3.length - 1; i2++) {
              var r2 = at.distancePointLine(t2, e3[i2], e3[i2 + 1]);
              r2 < n2 && (n2 = r2);
            }
            return n2;
          }
          if (arguments.length === 3) {
            var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            if (s2.x === a2.x && s2.y === a2.y)
              return o2.distance(s2);
            var u2 = (a2.x - s2.x) * (a2.x - s2.x) + (a2.y - s2.y) * (a2.y - s2.y), l2 = ((o2.x - s2.x) * (a2.x - s2.x) + (o2.y - s2.y) * (a2.y - s2.y)) / u2;
            if (l2 <= 0)
              return o2.distance(s2);
            if (l2 >= 1)
              return o2.distance(a2);
            var c2 = ((s2.y - o2.y) * (a2.x - s2.x) - (s2.x - o2.x) * (a2.y - s2.y)) / u2;
            return Math.abs(c2) * Math.sqrt(u2);
          }
        }, at.isOnLine = function(t2, e3) {
          for (var n2 = new rt(), i2 = 1; i2 < e3.length; i2++) {
            var r2 = e3[i2 - 1], o2 = e3[i2];
            if (n2.computeIntersection(t2, r2, o2), n2.hasIntersection())
              return true;
          }
          return false;
        }, ut.CLOCKWISE.get = function() {
          return -1;
        }, ut.RIGHT.get = function() {
          return at.CLOCKWISE;
        }, ut.COUNTERCLOCKWISE.get = function() {
          return 1;
        }, ut.LEFT.get = function() {
          return at.COUNTERCLOCKWISE;
        }, ut.COLLINEAR.get = function() {
          return 0;
        }, ut.STRAIGHT.get = function() {
          return at.COLLINEAR;
        }, Object.defineProperties(at, ut);
        var lt = function() {
        };
        lt.prototype.filter = function(t2) {
        }, lt.prototype.interfaces_ = function() {
          return [];
        }, lt.prototype.getClass = function() {
          return lt;
        };
        var ct = function() {
          var t2 = arguments[0];
          this._envelope = null, this._factory = null, this._SRID = null, this._userData = null, this._factory = t2, this._SRID = t2.getSRID();
        }, pt = { serialVersionUID: { configurable: true }, SORTINDEX_POINT: { configurable: true }, SORTINDEX_MULTIPOINT: { configurable: true }, SORTINDEX_LINESTRING: { configurable: true }, SORTINDEX_LINEARRING: { configurable: true }, SORTINDEX_MULTILINESTRING: { configurable: true }, SORTINDEX_POLYGON: { configurable: true }, SORTINDEX_MULTIPOLYGON: { configurable: true }, SORTINDEX_GEOMETRYCOLLECTION: { configurable: true }, geometryChangedFilter: { configurable: true } };
        ct.prototype.isGeometryCollection = function() {
          return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION;
        }, ct.prototype.getFactory = function() {
          return this._factory;
        }, ct.prototype.getGeometryN = function(t2) {
          return this;
        }, ct.prototype.getArea = function() {
          return 0;
        }, ct.prototype.isRectangle = function() {
          return false;
        }, ct.prototype.equals = function() {
          if (arguments[0] instanceof ct) {
            var t2 = arguments[0];
            return t2 !== null && this.equalsTopo(t2);
          }
          if (arguments[0] instanceof Object) {
            var e3 = arguments[0];
            if (!(e3 instanceof ct))
              return false;
            var n2 = e3;
            return this.equalsExact(n2);
          }
        }, ct.prototype.equalsExact = function(t2) {
          return this === t2 || this.equalsExact(t2, 0);
        }, ct.prototype.geometryChanged = function() {
          this.apply(ct.geometryChangedFilter);
        }, ct.prototype.geometryChangedAction = function() {
          this._envelope = null;
        }, ct.prototype.equalsNorm = function(t2) {
          return t2 !== null && this.norm().equalsExact(t2.norm());
        }, ct.prototype.getLength = function() {
          return 0;
        }, ct.prototype.getNumGeometries = function() {
          return 1;
        }, ct.prototype.compareTo = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0], e3 = t2;
            return this.getSortIndex() !== e3.getSortIndex() ? this.getSortIndex() - e3.getSortIndex() : this.isEmpty() && e3.isEmpty() ? 0 : this.isEmpty() ? -1 : e3.isEmpty() ? 1 : this.compareToSameClass(t2);
          }
          if (arguments.length === 2) {
            var n2 = arguments[0], i2 = arguments[1];
            return this.getSortIndex() !== n2.getSortIndex() ? this.getSortIndex() - n2.getSortIndex() : this.isEmpty() && n2.isEmpty() ? 0 : this.isEmpty() ? -1 : n2.isEmpty() ? 1 : this.compareToSameClass(n2, i2);
          }
        }, ct.prototype.getUserData = function() {
          return this._userData;
        }, ct.prototype.getSRID = function() {
          return this._SRID;
        }, ct.prototype.getEnvelope = function() {
          return this.getFactory().toGeometry(this.getEnvelopeInternal());
        }, ct.prototype.checkNotGeometryCollection = function(t2) {
          if (t2.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION)
            throw new m("This method does not support GeometryCollection arguments");
        }, ct.prototype.equal = function(t2, e3, n2) {
          return n2 === 0 ? t2.equals(e3) : t2.distance(e3) <= n2;
        }, ct.prototype.norm = function() {
          var t2 = this.copy();
          return t2.normalize(), t2;
        }, ct.prototype.getPrecisionModel = function() {
          return this._factory.getPrecisionModel();
        }, ct.prototype.getEnvelopeInternal = function() {
          return this._envelope === null && (this._envelope = this.computeEnvelopeInternal()), new j(this._envelope);
        }, ct.prototype.setSRID = function(t2) {
          this._SRID = t2;
        }, ct.prototype.setUserData = function(t2) {
          this._userData = t2;
        }, ct.prototype.compare = function(t2, e3) {
          for (var n2 = t2.iterator(), i2 = e3.iterator(); n2.hasNext() && i2.hasNext(); ) {
            var r2 = n2.next(), o2 = i2.next(), s2 = r2.compareTo(o2);
            if (s2 !== 0)
              return s2;
          }
          return n2.hasNext() ? 1 : i2.hasNext() ? -1 : 0;
        }, ct.prototype.hashCode = function() {
          return this.getEnvelopeInternal().hashCode();
        }, ct.prototype.isGeometryCollectionOrDerived = function() {
          return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === ct.SORTINDEX_MULTIPOINT || this.getSortIndex() === ct.SORTINDEX_MULTILINESTRING || this.getSortIndex() === ct.SORTINDEX_MULTIPOLYGON;
        }, ct.prototype.interfaces_ = function() {
          return [x2, E, e];
        }, ct.prototype.getClass = function() {
          return ct;
        }, ct.hasNonEmptyElements = function(t2) {
          for (var e3 = 0; e3 < t2.length; e3++)
            if (!t2[e3].isEmpty())
              return true;
          return false;
        }, ct.hasNullElements = function(t2) {
          for (var e3 = 0; e3 < t2.length; e3++)
            if (t2[e3] === null)
              return true;
          return false;
        }, pt.serialVersionUID.get = function() {
          return 8763622679187377e3;
        }, pt.SORTINDEX_POINT.get = function() {
          return 0;
        }, pt.SORTINDEX_MULTIPOINT.get = function() {
          return 1;
        }, pt.SORTINDEX_LINESTRING.get = function() {
          return 2;
        }, pt.SORTINDEX_LINEARRING.get = function() {
          return 3;
        }, pt.SORTINDEX_MULTILINESTRING.get = function() {
          return 4;
        }, pt.SORTINDEX_POLYGON.get = function() {
          return 5;
        }, pt.SORTINDEX_MULTIPOLYGON.get = function() {
          return 6;
        }, pt.SORTINDEX_GEOMETRYCOLLECTION.get = function() {
          return 7;
        }, pt.geometryChangedFilter.get = function() {
          return ht;
        }, Object.defineProperties(ct, pt);
        var ht = function() {
        };
        ht.interfaces_ = function() {
          return [lt];
        }, ht.filter = function(t2) {
          t2.geometryChangedAction();
        };
        var ft = function() {
        };
        ft.prototype.filter = function(t2) {
        }, ft.prototype.interfaces_ = function() {
          return [];
        }, ft.prototype.getClass = function() {
          return ft;
        };
        var gt = function() {
        }, dt = { Mod2BoundaryNodeRule: { configurable: true }, EndPointBoundaryNodeRule: { configurable: true }, MultiValentEndPointBoundaryNodeRule: { configurable: true }, MonoValentEndPointBoundaryNodeRule: { configurable: true }, MOD2_BOUNDARY_RULE: { configurable: true }, ENDPOINT_BOUNDARY_RULE: { configurable: true }, MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, OGC_SFS_BOUNDARY_RULE: { configurable: true } };
        gt.prototype.isInBoundary = function(t2) {
        }, gt.prototype.interfaces_ = function() {
          return [];
        }, gt.prototype.getClass = function() {
          return gt;
        }, dt.Mod2BoundaryNodeRule.get = function() {
          return yt;
        }, dt.EndPointBoundaryNodeRule.get = function() {
          return _t;
        }, dt.MultiValentEndPointBoundaryNodeRule.get = function() {
          return mt;
        }, dt.MonoValentEndPointBoundaryNodeRule.get = function() {
          return vt;
        }, dt.MOD2_BOUNDARY_RULE.get = function() {
          return new yt();
        }, dt.ENDPOINT_BOUNDARY_RULE.get = function() {
          return new _t();
        }, dt.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
          return new mt();
        }, dt.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
          return new vt();
        }, dt.OGC_SFS_BOUNDARY_RULE.get = function() {
          return gt.MOD2_BOUNDARY_RULE;
        }, Object.defineProperties(gt, dt);
        var yt = function() {
        };
        yt.prototype.isInBoundary = function(t2) {
          return t2 % 2 == 1;
        }, yt.prototype.interfaces_ = function() {
          return [gt];
        }, yt.prototype.getClass = function() {
          return yt;
        };
        var _t = function() {
        };
        _t.prototype.isInBoundary = function(t2) {
          return t2 > 0;
        }, _t.prototype.interfaces_ = function() {
          return [gt];
        }, _t.prototype.getClass = function() {
          return _t;
        };
        var mt = function() {
        };
        mt.prototype.isInBoundary = function(t2) {
          return t2 > 1;
        }, mt.prototype.interfaces_ = function() {
          return [gt];
        }, mt.prototype.getClass = function() {
          return mt;
        };
        var vt = function() {
        };
        vt.prototype.isInBoundary = function(t2) {
          return t2 === 1;
        }, vt.prototype.interfaces_ = function() {
          return [gt];
        }, vt.prototype.getClass = function() {
          return vt;
        };
        var It = function() {
        };
        It.prototype.add = function() {
        }, It.prototype.addAll = function() {
        }, It.prototype.isEmpty = function() {
        }, It.prototype.iterator = function() {
        }, It.prototype.size = function() {
        }, It.prototype.toArray = function() {
        }, It.prototype.remove = function() {
        }, (n.prototype = new Error()).name = "IndexOutOfBoundsException";
        var Et = function() {
        };
        Et.prototype.hasNext = function() {
        }, Et.prototype.next = function() {
        }, Et.prototype.remove = function() {
        };
        var xt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.get = function() {
          }, e3.prototype.set = function() {
          }, e3.prototype.isEmpty = function() {
          }, e3;
        }(It);
        (i.prototype = new Error()).name = "NoSuchElementException";
        var Nt = function(t2) {
          function e3() {
            t2.call(this), this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.ensureCapacity = function() {
          }, e3.prototype.interfaces_ = function() {
            return [t2, It];
          }, e3.prototype.add = function(t3) {
            return arguments.length === 1 ? this.array_.push(t3) : this.array_.splice(arguments[0], arguments[1]), true;
          }, e3.prototype.clear = function() {
            this.array_ = [];
          }, e3.prototype.addAll = function(t3) {
            for (var e4 = t3.iterator(); e4.hasNext(); )
              this.add(e4.next());
            return true;
          }, e3.prototype.set = function(t3, e4) {
            var n2 = this.array_[t3];
            return this.array_[t3] = e4, n2;
          }, e3.prototype.iterator = function() {
            return new Ct(this);
          }, e3.prototype.get = function(t3) {
            if (t3 < 0 || t3 >= this.size())
              throw new n();
            return this.array_[t3];
          }, e3.prototype.isEmpty = function() {
            return this.array_.length === 0;
          }, e3.prototype.size = function() {
            return this.array_.length;
          }, e3.prototype.toArray = function() {
            for (var t3 = [], e4 = 0, n2 = this.array_.length; e4 < n2; e4++)
              t3.push(this.array_[e4]);
            return t3;
          }, e3.prototype.remove = function(t3) {
            for (var e4 = false, n2 = 0, i2 = this.array_.length; n2 < i2; n2++)
              if (this.array_[n2] === t3) {
                this.array_.splice(n2, 1), e4 = true;
                break;
              }
            return e4;
          }, e3;
        }(xt), Ct = function(t2) {
          function e3(e4) {
            t2.call(this), this.arrayList_ = e4, this.position_ = 0;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.next = function() {
            if (this.position_ === this.arrayList_.size())
              throw new i();
            return this.arrayList_.get(this.position_++);
          }, e3.prototype.hasNext = function() {
            return this.position_ < this.arrayList_.size();
          }, e3.prototype.set = function(t3) {
            return this.arrayList_.set(this.position_ - 1, t3);
          }, e3.prototype.remove = function() {
            this.arrayList_.remove(this.arrayList_.get(this.position_));
          }, e3;
        }(Et), St = function(t2) {
          function e3() {
            if (t2.call(this), arguments.length === 0)
              ;
            else if (arguments.length === 1) {
              var e4 = arguments[0];
              this.ensureCapacity(e4.length), this.add(e4, true);
            } else if (arguments.length === 2) {
              var n3 = arguments[0], i2 = arguments[1];
              this.ensureCapacity(n3.length), this.add(n3, i2);
            }
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { coordArrayType: { configurable: true } };
          return n2.coordArrayType.get = function() {
            return new Array(0).fill(null);
          }, e3.prototype.getCoordinate = function(t3) {
            return this.get(t3);
          }, e3.prototype.addAll = function() {
            if (arguments.length === 2) {
              for (var e4 = arguments[0], n3 = arguments[1], i2 = false, r2 = e4.iterator(); r2.hasNext(); )
                this.add(r2.next(), n3), i2 = true;
              return i2;
            }
            return t2.prototype.addAll.apply(this, arguments);
          }, e3.prototype.clone = function() {
            for (var e4 = t2.prototype.clone.call(this), n3 = 0; n3 < this.size(); n3++)
              e4.add(n3, this.get(n3).copy());
            return e4;
          }, e3.prototype.toCoordinateArray = function() {
            return this.toArray(e3.coordArrayType);
          }, e3.prototype.add = function() {
            if (arguments.length === 1) {
              var e4 = arguments[0];
              t2.prototype.add.call(this, e4);
            } else if (arguments.length === 2) {
              if (arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
                var n3 = arguments[0], i2 = arguments[1];
                return this.add(n3, i2, true), true;
              }
              if (arguments[0] instanceof C && typeof arguments[1] == "boolean") {
                var r2 = arguments[0];
                if (!arguments[1] && this.size() >= 1) {
                  if (this.get(this.size() - 1).equals2D(r2))
                    return null;
                }
                t2.prototype.add.call(this, r2);
              } else if (arguments[0] instanceof Object && typeof arguments[1] == "boolean") {
                var o2 = arguments[0], s2 = arguments[1];
                return this.add(o2, s2), true;
              }
            } else if (arguments.length === 3) {
              if (typeof arguments[2] == "boolean" && arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
                var a2 = arguments[0], u2 = arguments[1];
                if (arguments[2])
                  for (var l2 = 0; l2 < a2.length; l2++)
                    this.add(a2[l2], u2);
                else
                  for (var c2 = a2.length - 1; c2 >= 0; c2--)
                    this.add(a2[c2], u2);
                return true;
              }
              if (typeof arguments[2] == "boolean" && Number.isInteger(arguments[0]) && arguments[1] instanceof C) {
                var p2 = arguments[0], h2 = arguments[1];
                if (!arguments[2]) {
                  var f2 = this.size();
                  if (f2 > 0) {
                    if (p2 > 0) {
                      if (this.get(p2 - 1).equals2D(h2))
                        return null;
                    }
                    if (p2 < f2) {
                      if (this.get(p2).equals2D(h2))
                        return null;
                    }
                  }
                }
                t2.prototype.add.call(this, p2, h2);
              }
            } else if (arguments.length === 4) {
              var g2 = arguments[0], d2 = arguments[1], y3 = arguments[2], _2 = arguments[3], m2 = 1;
              y3 > _2 && (m2 = -1);
              for (var v2 = y3; v2 !== _2; v2 += m2)
                this.add(g2[v2], d2);
              return true;
            }
          }, e3.prototype.closeRing = function() {
            this.size() > 0 && this.add(new C(this.get(0)), false);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, Object.defineProperties(e3, n2), e3;
        }(Nt), Lt = function() {
        }, bt = { ForwardComparator: { configurable: true }, BidirectionalComparator: { configurable: true }, coordArrayType: { configurable: true } };
        bt.ForwardComparator.get = function() {
          return wt;
        }, bt.BidirectionalComparator.get = function() {
          return Ot;
        }, bt.coordArrayType.get = function() {
          return new Array(0).fill(null);
        }, Lt.prototype.interfaces_ = function() {
          return [];
        }, Lt.prototype.getClass = function() {
          return Lt;
        }, Lt.isRing = function(t2) {
          return !(t2.length < 4) && !!t2[0].equals2D(t2[t2.length - 1]);
        }, Lt.ptNotInList = function(t2, e3) {
          for (var n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            if (Lt.indexOf(i2, e3) < 0)
              return i2;
          }
          return null;
        }, Lt.scroll = function(t2, e3) {
          var n2 = Lt.indexOf(e3, t2);
          if (n2 < 0)
            return null;
          var i2 = new Array(t2.length).fill(null);
          Y.arraycopy(t2, n2, i2, 0, t2.length - n2), Y.arraycopy(t2, 0, i2, t2.length - n2, n2), Y.arraycopy(i2, 0, t2, 0, t2.length);
        }, Lt.equals = function() {
          if (arguments.length === 2) {
            var t2 = arguments[0], e3 = arguments[1];
            if (t2 === e3)
              return true;
            if (t2 === null || e3 === null)
              return false;
            if (t2.length !== e3.length)
              return false;
            for (var n2 = 0; n2 < t2.length; n2++)
              if (!t2[n2].equals(e3[n2]))
                return false;
            return true;
          }
          if (arguments.length === 3) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            if (i2 === r2)
              return true;
            if (i2 === null || r2 === null)
              return false;
            if (i2.length !== r2.length)
              return false;
            for (var s2 = 0; s2 < i2.length; s2++)
              if (o2.compare(i2[s2], r2[s2]) !== 0)
                return false;
            return true;
          }
        }, Lt.intersection = function(t2, e3) {
          for (var n2 = new St(), i2 = 0; i2 < t2.length; i2++)
            e3.intersects(t2[i2]) && n2.add(t2[i2], true);
          return n2.toCoordinateArray();
        }, Lt.hasRepeatedPoints = function(t2) {
          for (var e3 = 1; e3 < t2.length; e3++)
            if (t2[e3 - 1].equals(t2[e3]))
              return true;
          return false;
        }, Lt.removeRepeatedPoints = function(t2) {
          if (!Lt.hasRepeatedPoints(t2))
            return t2;
          return new St(t2, false).toCoordinateArray();
        }, Lt.reverse = function(t2) {
          for (var e3 = t2.length - 1, n2 = Math.trunc(e3 / 2), i2 = 0; i2 <= n2; i2++) {
            var r2 = t2[i2];
            t2[i2] = t2[e3 - i2], t2[e3 - i2] = r2;
          }
        }, Lt.removeNull = function(t2) {
          for (var e3 = 0, n2 = 0; n2 < t2.length; n2++)
            t2[n2] !== null && e3++;
          var i2 = new Array(e3).fill(null);
          if (e3 === 0)
            return i2;
          for (var r2 = 0, o2 = 0; o2 < t2.length; o2++)
            t2[o2] !== null && (i2[r2++] = t2[o2]);
          return i2;
        }, Lt.copyDeep = function() {
          if (arguments.length === 1) {
            for (var t2 = arguments[0], e3 = new Array(t2.length).fill(null), n2 = 0; n2 < t2.length; n2++)
              e3[n2] = new C(t2[n2]);
            return e3;
          }
          if (arguments.length === 5)
            for (var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = arguments[3], a2 = arguments[4], u2 = 0; u2 < a2; u2++)
              o2[s2 + u2] = new C(i2[r2 + u2]);
        }, Lt.isEqualReversed = function(t2, e3) {
          for (var n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2], r2 = e3[t2.length - n2 - 1];
            if (i2.compareTo(r2) !== 0)
              return false;
          }
          return true;
        }, Lt.envelope = function(t2) {
          for (var e3 = new j(), n2 = 0; n2 < t2.length; n2++)
            e3.expandToInclude(t2[n2]);
          return e3;
        }, Lt.toCoordinateArray = function(t2) {
          return t2.toArray(Lt.coordArrayType);
        }, Lt.atLeastNCoordinatesOrNothing = function(t2, e3) {
          return e3.length >= t2 ? e3 : [];
        }, Lt.indexOf = function(t2, e3) {
          for (var n2 = 0; n2 < e3.length; n2++)
            if (t2.equals(e3[n2]))
              return n2;
          return -1;
        }, Lt.increasingDirection = function(t2) {
          for (var e3 = 0; e3 < Math.trunc(t2.length / 2); e3++) {
            var n2 = t2.length - 1 - e3, i2 = t2[e3].compareTo(t2[n2]);
            if (i2 !== 0)
              return i2;
          }
          return 1;
        }, Lt.compare = function(t2, e3) {
          for (var n2 = 0; n2 < t2.length && n2 < e3.length; ) {
            var i2 = t2[n2].compareTo(e3[n2]);
            if (i2 !== 0)
              return i2;
            n2++;
          }
          return n2 < e3.length ? -1 : n2 < t2.length ? 1 : 0;
        }, Lt.minCoordinate = function(t2) {
          for (var e3 = null, n2 = 0; n2 < t2.length; n2++)
            (e3 === null || e3.compareTo(t2[n2]) > 0) && (e3 = t2[n2]);
          return e3;
        }, Lt.extract = function(t2, e3, n2) {
          e3 = R.clamp(e3, 0, t2.length);
          var i2 = (n2 = R.clamp(n2, -1, t2.length)) - e3 + 1;
          n2 < 0 && (i2 = 0), e3 >= t2.length && (i2 = 0), n2 < e3 && (i2 = 0);
          var r2 = new Array(i2).fill(null);
          if (i2 === 0)
            return r2;
          for (var o2 = 0, s2 = e3; s2 <= n2; s2++)
            r2[o2++] = t2[s2];
          return r2;
        }, Object.defineProperties(Lt, bt);
        var wt = function() {
        };
        wt.prototype.compare = function(t2, e3) {
          return Lt.compare(t2, e3);
        }, wt.prototype.interfaces_ = function() {
          return [N];
        }, wt.prototype.getClass = function() {
          return wt;
        };
        var Ot = function() {
        };
        Ot.prototype.compare = function(t2, e3) {
          var n2 = t2, i2 = e3;
          if (n2.length < i2.length)
            return -1;
          if (n2.length > i2.length)
            return 1;
          if (n2.length === 0)
            return 0;
          var r2 = Lt.compare(n2, i2);
          return Lt.isEqualReversed(n2, i2) ? 0 : r2;
        }, Ot.prototype.OLDcompare = function(t2, e3) {
          var n2 = t2, i2 = e3;
          if (n2.length < i2.length)
            return -1;
          if (n2.length > i2.length)
            return 1;
          if (n2.length === 0)
            return 0;
          for (var r2 = Lt.increasingDirection(n2), o2 = Lt.increasingDirection(i2), s2 = r2 > 0 ? 0 : n2.length - 1, a2 = o2 > 0 ? 0 : n2.length - 1, u2 = 0; u2 < n2.length; u2++) {
            var l2 = n2[s2].compareTo(i2[a2]);
            if (l2 !== 0)
              return l2;
            s2 += r2, a2 += o2;
          }
          return 0;
        }, Ot.prototype.interfaces_ = function() {
          return [N];
        }, Ot.prototype.getClass = function() {
          return Ot;
        };
        var Tt = function() {
        };
        Tt.prototype.get = function() {
        }, Tt.prototype.put = function() {
        }, Tt.prototype.size = function() {
        }, Tt.prototype.values = function() {
        }, Tt.prototype.entrySet = function() {
        };
        var Rt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3;
        }(Tt);
        (r.prototype = new Error()).name = "OperationNotSupported", (o.prototype = new It()).contains = function() {
        };
        var Pt = function(t2) {
          function e3() {
            t2.call(this), this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.contains = function(t3) {
            for (var e4 = 0, n2 = this.array_.length; e4 < n2; e4++) {
              if (this.array_[e4] === t3)
                return true;
            }
            return false;
          }, e3.prototype.add = function(t3) {
            return !this.contains(t3) && (this.array_.push(t3), true);
          }, e3.prototype.addAll = function(t3) {
            for (var e4 = t3.iterator(); e4.hasNext(); )
              this.add(e4.next());
            return true;
          }, e3.prototype.remove = function(t3) {
            throw new Error();
          }, e3.prototype.size = function() {
            return this.array_.length;
          }, e3.prototype.isEmpty = function() {
            return this.array_.length === 0;
          }, e3.prototype.toArray = function() {
            for (var t3 = [], e4 = 0, n2 = this.array_.length; e4 < n2; e4++)
              t3.push(this.array_[e4]);
            return t3;
          }, e3.prototype.iterator = function() {
            return new Dt(this);
          }, e3;
        }(o), Dt = function(t2) {
          function e3(e4) {
            t2.call(this), this.hashSet_ = e4, this.position_ = 0;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.next = function() {
            if (this.position_ === this.hashSet_.size())
              throw new i();
            return this.hashSet_.array_[this.position_++];
          }, e3.prototype.hasNext = function() {
            return this.position_ < this.hashSet_.size();
          }, e3.prototype.remove = function() {
            throw new r();
          }, e3;
        }(Et), Mt = 0;
        (p.prototype = new Rt()).get = function(t2) {
          for (var e3 = this.root_; e3 !== null; ) {
            var n2 = t2.compareTo(e3.key);
            if (n2 < 0)
              e3 = e3.left;
            else {
              if (!(n2 > 0))
                return e3.value;
              e3 = e3.right;
            }
          }
          return null;
        }, p.prototype.put = function(t2, e3) {
          if (this.root_ === null)
            return this.root_ = { key: t2, value: e3, left: null, right: null, parent: null, color: Mt, getValue: function() {
              return this.value;
            }, getKey: function() {
              return this.key;
            } }, this.size_ = 1, null;
          var n2, i2, r2 = this.root_;
          do {
            if (n2 = r2, (i2 = t2.compareTo(r2.key)) < 0)
              r2 = r2.left;
            else {
              if (!(i2 > 0)) {
                var o2 = r2.value;
                return r2.value = e3, o2;
              }
              r2 = r2.right;
            }
          } while (r2 !== null);
          var s2 = { key: t2, left: null, right: null, value: e3, parent: n2, color: Mt, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } };
          return i2 < 0 ? n2.left = s2 : n2.right = s2, this.fixAfterInsertion(s2), this.size_++, null;
        }, p.prototype.fixAfterInsertion = function(t2) {
          for (t2.color = 1; t2 != null && t2 !== this.root_ && t2.parent.color === 1; )
            if (a(t2) === l(a(a(t2)))) {
              var e3 = c(a(a(t2)));
              s(e3) === 1 ? (u(a(t2), Mt), u(e3, Mt), u(a(a(t2)), 1), t2 = a(a(t2))) : (t2 === c(a(t2)) && (t2 = a(t2), this.rotateLeft(t2)), u(a(t2), Mt), u(a(a(t2)), 1), this.rotateRight(a(a(t2))));
            } else {
              var n2 = l(a(a(t2)));
              s(n2) === 1 ? (u(a(t2), Mt), u(n2, Mt), u(a(a(t2)), 1), t2 = a(a(t2))) : (t2 === l(a(t2)) && (t2 = a(t2), this.rotateRight(t2)), u(a(t2), Mt), u(a(a(t2)), 1), this.rotateLeft(a(a(t2))));
            }
          this.root_.color = Mt;
        }, p.prototype.values = function() {
          var t2 = new Nt(), e3 = this.getFirstEntry();
          if (e3 !== null)
            for (t2.add(e3.value); (e3 = p.successor(e3)) !== null; )
              t2.add(e3.value);
          return t2;
        }, p.prototype.entrySet = function() {
          var t2 = new Pt(), e3 = this.getFirstEntry();
          if (e3 !== null)
            for (t2.add(e3); (e3 = p.successor(e3)) !== null; )
              t2.add(e3);
          return t2;
        }, p.prototype.rotateLeft = function(t2) {
          if (t2 != null) {
            var e3 = t2.right;
            t2.right = e3.left, e3.left != null && (e3.left.parent = t2), e3.parent = t2.parent, t2.parent === null ? this.root_ = e3 : t2.parent.left === t2 ? t2.parent.left = e3 : t2.parent.right = e3, e3.left = t2, t2.parent = e3;
          }
        }, p.prototype.rotateRight = function(t2) {
          if (t2 != null) {
            var e3 = t2.left;
            t2.left = e3.right, e3.right != null && (e3.right.parent = t2), e3.parent = t2.parent, t2.parent === null ? this.root_ = e3 : t2.parent.right === t2 ? t2.parent.right = e3 : t2.parent.left = e3, e3.right = t2, t2.parent = e3;
          }
        }, p.prototype.getFirstEntry = function() {
          var t2 = this.root_;
          if (t2 != null)
            for (; t2.left != null; )
              t2 = t2.left;
          return t2;
        }, p.successor = function(t2) {
          if (t2 === null)
            return null;
          if (t2.right !== null) {
            for (var e3 = t2.right; e3.left !== null; )
              e3 = e3.left;
            return e3;
          }
          for (var n2 = t2.parent, i2 = t2; n2 !== null && i2 === n2.right; )
            i2 = n2, n2 = n2.parent;
          return n2;
        }, p.prototype.size = function() {
          return this.size_;
        };
        var At = function() {
        };
        At.prototype.interfaces_ = function() {
          return [];
        }, At.prototype.getClass = function() {
          return At;
        }, h.prototype = new o(), (f.prototype = new h()).contains = function(t2) {
          for (var e3 = 0, n2 = this.array_.length; e3 < n2; e3++) {
            if (this.array_[e3].compareTo(t2) === 0)
              return true;
          }
          return false;
        }, f.prototype.add = function(t2) {
          if (this.contains(t2))
            return false;
          for (var e3 = 0, n2 = this.array_.length; e3 < n2; e3++) {
            if (this.array_[e3].compareTo(t2) === 1)
              return this.array_.splice(e3, 0, t2), true;
          }
          return this.array_.push(t2), true;
        }, f.prototype.addAll = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); )
            this.add(e3.next());
          return true;
        }, f.prototype.remove = function(t2) {
          throw new r();
        }, f.prototype.size = function() {
          return this.array_.length;
        }, f.prototype.isEmpty = function() {
          return this.array_.length === 0;
        }, f.prototype.toArray = function() {
          for (var t2 = [], e3 = 0, n2 = this.array_.length; e3 < n2; e3++)
            t2.push(this.array_[e3]);
          return t2;
        }, f.prototype.iterator = function() {
          return new Ft(this);
        };
        var Ft = function(t2) {
          this.treeSet_ = t2, this.position_ = 0;
        };
        Ft.prototype.next = function() {
          if (this.position_ === this.treeSet_.size())
            throw new i();
          return this.treeSet_.array_[this.position_++];
        }, Ft.prototype.hasNext = function() {
          return this.position_ < this.treeSet_.size();
        }, Ft.prototype.remove = function() {
          throw new r();
        };
        var Gt = function() {
        };
        Gt.sort = function() {
          var t2, e3, n2, i2, r2 = arguments[0];
          if (arguments.length === 1)
            i2 = function(t3, e4) {
              return t3.compareTo(e4);
            }, r2.sort(i2);
          else if (arguments.length === 2)
            n2 = arguments[1], i2 = function(t3, e4) {
              return n2.compare(t3, e4);
            }, r2.sort(i2);
          else if (arguments.length === 3) {
            (e3 = r2.slice(arguments[1], arguments[2])).sort();
            var o2 = r2.slice(0, arguments[1]).concat(e3, r2.slice(arguments[2], r2.length));
            for (r2.splice(0, r2.length), t2 = 0; t2 < o2.length; t2++)
              r2.push(o2[t2]);
          } else if (arguments.length === 4)
            for (e3 = r2.slice(arguments[1], arguments[2]), n2 = arguments[3], i2 = function(t3, e4) {
              return n2.compare(t3, e4);
            }, e3.sort(i2), o2 = r2.slice(0, arguments[1]).concat(e3, r2.slice(arguments[2], r2.length)), r2.splice(0, r2.length), t2 = 0; t2 < o2.length; t2++)
              r2.push(o2[t2]);
        }, Gt.asList = function(t2) {
          for (var e3 = new Nt(), n2 = 0, i2 = t2.length; n2 < i2; n2++)
            e3.add(t2[n2]);
          return e3;
        };
        var qt = function() {
        }, Bt = { P: { configurable: true }, L: { configurable: true }, A: { configurable: true }, FALSE: { configurable: true }, TRUE: { configurable: true }, DONTCARE: { configurable: true }, SYM_FALSE: { configurable: true }, SYM_TRUE: { configurable: true }, SYM_DONTCARE: { configurable: true }, SYM_P: { configurable: true }, SYM_L: { configurable: true }, SYM_A: { configurable: true } };
        Bt.P.get = function() {
          return 0;
        }, Bt.L.get = function() {
          return 1;
        }, Bt.A.get = function() {
          return 2;
        }, Bt.FALSE.get = function() {
          return -1;
        }, Bt.TRUE.get = function() {
          return -2;
        }, Bt.DONTCARE.get = function() {
          return -3;
        }, Bt.SYM_FALSE.get = function() {
          return "F";
        }, Bt.SYM_TRUE.get = function() {
          return "T";
        }, Bt.SYM_DONTCARE.get = function() {
          return "*";
        }, Bt.SYM_P.get = function() {
          return "0";
        }, Bt.SYM_L.get = function() {
          return "1";
        }, Bt.SYM_A.get = function() {
          return "2";
        }, qt.prototype.interfaces_ = function() {
          return [];
        }, qt.prototype.getClass = function() {
          return qt;
        }, qt.toDimensionSymbol = function(t2) {
          switch (t2) {
            case qt.FALSE:
              return qt.SYM_FALSE;
            case qt.TRUE:
              return qt.SYM_TRUE;
            case qt.DONTCARE:
              return qt.SYM_DONTCARE;
            case qt.P:
              return qt.SYM_P;
            case qt.L:
              return qt.SYM_L;
            case qt.A:
              return qt.SYM_A;
          }
          throw new m("Unknown dimension value: " + t2);
        }, qt.toDimensionValue = function(t2) {
          switch (A.toUpperCase(t2)) {
            case qt.SYM_FALSE:
              return qt.FALSE;
            case qt.SYM_TRUE:
              return qt.TRUE;
            case qt.SYM_DONTCARE:
              return qt.DONTCARE;
            case qt.SYM_P:
              return qt.P;
            case qt.SYM_L:
              return qt.L;
            case qt.SYM_A:
              return qt.A;
          }
          throw new m("Unknown dimension symbol: " + t2);
        }, Object.defineProperties(qt, Bt);
        var Vt = function() {
        };
        Vt.prototype.filter = function(t2) {
        }, Vt.prototype.interfaces_ = function() {
          return [];
        }, Vt.prototype.getClass = function() {
          return Vt;
        };
        var Ut = function() {
        };
        Ut.prototype.filter = function(t2, e3) {
        }, Ut.prototype.isDone = function() {
        }, Ut.prototype.isGeometryChanged = function() {
        }, Ut.prototype.interfaces_ = function() {
          return [];
        }, Ut.prototype.getClass = function() {
          return Ut;
        };
        var zt = function(t2) {
          function e3(e4, n3) {
            if (t2.call(this, n3), this._geometries = e4 || [], t2.hasNullElements(this._geometries))
              throw new m("geometries must not contain null elements");
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            for (var t3 = new j(), e4 = 0; e4 < this._geometries.length; e4++)
              t3.expandToInclude(this._geometries[e4].getEnvelopeInternal());
            return t3;
          }, e3.prototype.getGeometryN = function(t3) {
            return this._geometries[t3];
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_GEOMETRYCOLLECTION;
          }, e3.prototype.getCoordinates = function() {
            for (var t3 = new Array(this.getNumPoints()).fill(null), e4 = -1, n3 = 0; n3 < this._geometries.length; n3++)
              for (var i2 = this._geometries[n3].getCoordinates(), r2 = 0; r2 < i2.length; r2++)
                t3[++e4] = i2[r2];
            return t3;
          }, e3.prototype.getArea = function() {
            for (var t3 = 0, e4 = 0; e4 < this._geometries.length; e4++)
              t3 += this._geometries[e4].getArea();
            return t3;
          }, e3.prototype.equalsExact = function() {
            if (arguments.length === 2) {
              var e4 = arguments[0], n3 = arguments[1];
              if (!this.isEquivalentClass(e4))
                return false;
              var i2 = e4;
              if (this._geometries.length !== i2._geometries.length)
                return false;
              for (var r2 = 0; r2 < this._geometries.length; r2++)
                if (!this._geometries[r2].equalsExact(i2._geometries[r2], n3))
                  return false;
              return true;
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
            for (var t3 = 0; t3 < this._geometries.length; t3++)
              this._geometries[t3].normalize();
            Gt.sort(this._geometries);
          }, e3.prototype.getCoordinate = function() {
            return this.isEmpty() ? null : this._geometries[0].getCoordinate();
          }, e3.prototype.getBoundaryDimension = function() {
            for (var t3 = qt.FALSE, e4 = 0; e4 < this._geometries.length; e4++)
              t3 = Math.max(t3, this._geometries[e4].getBoundaryDimension());
            return t3;
          }, e3.prototype.getDimension = function() {
            for (var t3 = qt.FALSE, e4 = 0; e4 < this._geometries.length; e4++)
              t3 = Math.max(t3, this._geometries[e4].getDimension());
            return t3;
          }, e3.prototype.getLength = function() {
            for (var t3 = 0, e4 = 0; e4 < this._geometries.length; e4++)
              t3 += this._geometries[e4].getLength();
            return t3;
          }, e3.prototype.getNumPoints = function() {
            for (var t3 = 0, e4 = 0; e4 < this._geometries.length; e4++)
              t3 += this._geometries[e4].getNumPoints();
            return t3;
          }, e3.prototype.getNumGeometries = function() {
            return this._geometries.length;
          }, e3.prototype.reverse = function() {
            for (var t3 = this._geometries.length, e4 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
              e4[n3] = this._geometries[n3].reverse();
            return this.getFactory().createGeometryCollection(e4);
          }, e3.prototype.compareToSameClass = function() {
            if (arguments.length === 1) {
              var t3 = arguments[0], e4 = new f(Gt.asList(this._geometries)), n3 = new f(Gt.asList(t3._geometries));
              return this.compare(e4, n3);
            }
            if (arguments.length === 2) {
              for (var i2 = arguments[0], r2 = arguments[1], o2 = i2, s2 = this.getNumGeometries(), a2 = o2.getNumGeometries(), u2 = 0; u2 < s2 && u2 < a2; ) {
                var l2 = this.getGeometryN(u2), c2 = o2.getGeometryN(u2), p2 = l2.compareToSameClass(c2, r2);
                if (p2 !== 0)
                  return p2;
                u2++;
              }
              return u2 < s2 ? 1 : u2 < a2 ? -1 : 0;
            }
          }, e3.prototype.apply = function() {
            if (T(arguments[0], ft))
              for (var t3 = arguments[0], e4 = 0; e4 < this._geometries.length; e4++)
                this._geometries[e4].apply(t3);
            else if (T(arguments[0], Ut)) {
              var n3 = arguments[0];
              if (this._geometries.length === 0)
                return null;
              for (var i2 = 0; i2 < this._geometries.length && (this._geometries[i2].apply(n3), !n3.isDone()); i2++)
                ;
              n3.isGeometryChanged() && this.geometryChanged();
            } else if (T(arguments[0], Vt)) {
              var r2 = arguments[0];
              r2.filter(this);
              for (var o2 = 0; o2 < this._geometries.length; o2++)
                this._geometries[o2].apply(r2);
            } else if (T(arguments[0], lt)) {
              var s2 = arguments[0];
              s2.filter(this);
              for (var a2 = 0; a2 < this._geometries.length; a2++)
                this._geometries[a2].apply(s2);
            }
          }, e3.prototype.getBoundary = function() {
            return this.checkNotGeometryCollection(this), et.shouldNeverReachHere(), null;
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            e4._geometries = new Array(this._geometries.length).fill(null);
            for (var n3 = 0; n3 < this._geometries.length; n3++)
              e4._geometries[n3] = this._geometries[n3].clone();
            return e4;
          }, e3.prototype.getGeometryType = function() {
            return "GeometryCollection";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.isEmpty = function() {
            for (var t3 = 0; t3 < this._geometries.length; t3++)
              if (!this._geometries[t3].isEmpty())
                return false;
            return true;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -5694727726395021e3;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), Xt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_MULTILINESTRING;
          }, e3.prototype.equalsExact = function() {
            if (arguments.length === 2) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && t2.prototype.equalsExact.call(this, e4, n3);
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.getBoundaryDimension = function() {
            return this.isClosed() ? qt.FALSE : 0;
          }, e3.prototype.isClosed = function() {
            if (this.isEmpty())
              return false;
            for (var t3 = 0; t3 < this._geometries.length; t3++)
              if (!this._geometries[t3].isClosed())
                return false;
            return true;
          }, e3.prototype.getDimension = function() {
            return 1;
          }, e3.prototype.reverse = function() {
            for (var t3 = this._geometries.length, e4 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
              e4[t3 - 1 - n3] = this._geometries[n3].reverse();
            return this.getFactory().createMultiLineString(e4);
          }, e3.prototype.getBoundary = function() {
            return new Yt(this).getBoundary();
          }, e3.prototype.getGeometryType = function() {
            return "MultiLineString";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [At];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return 8166665132445434e3;
          }, Object.defineProperties(e3, n2), e3;
        }(zt), Yt = function() {
          if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, arguments.length === 1) {
            var t2 = arguments[0], e3 = gt.MOD2_BOUNDARY_RULE;
            this._geom = t2, this._geomFact = t2.getFactory(), this._bnRule = e3;
          } else if (arguments.length === 2) {
            var n2 = arguments[0], i2 = arguments[1];
            this._geom = n2, this._geomFact = n2.getFactory(), this._bnRule = i2;
          }
        };
        Yt.prototype.boundaryMultiLineString = function(t2) {
          if (this._geom.isEmpty())
            return this.getEmptyMultiPoint();
          var e3 = this.computeBoundaryCoordinates(t2);
          return e3.length === 1 ? this._geomFact.createPoint(e3[0]) : this._geomFact.createMultiPointFromCoords(e3);
        }, Yt.prototype.getBoundary = function() {
          return this._geom instanceof Kt ? this.boundaryLineString(this._geom) : this._geom instanceof Xt ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary();
        }, Yt.prototype.boundaryLineString = function(t2) {
          if (this._geom.isEmpty())
            return this.getEmptyMultiPoint();
          if (t2.isClosed()) {
            return this._bnRule.isInBoundary(2) ? t2.getStartPoint() : this._geomFact.createMultiPoint();
          }
          return this._geomFact.createMultiPoint([t2.getStartPoint(), t2.getEndPoint()]);
        }, Yt.prototype.getEmptyMultiPoint = function() {
          return this._geomFact.createMultiPoint();
        }, Yt.prototype.computeBoundaryCoordinates = function(t2) {
          var e3 = new Nt();
          this._endpointMap = new p();
          for (var n2 = 0; n2 < t2.getNumGeometries(); n2++) {
            var i2 = t2.getGeometryN(n2);
            i2.getNumPoints() !== 0 && (this.addEndpoint(i2.getCoordinateN(0)), this.addEndpoint(i2.getCoordinateN(i2.getNumPoints() - 1)));
          }
          for (var r2 = this._endpointMap.entrySet().iterator(); r2.hasNext(); ) {
            var o2 = r2.next(), s2 = o2.getValue().count;
            this._bnRule.isInBoundary(s2) && e3.add(o2.getKey());
          }
          return Lt.toCoordinateArray(e3);
        }, Yt.prototype.addEndpoint = function(t2) {
          var e3 = this._endpointMap.get(t2);
          e3 === null && (e3 = new kt(), this._endpointMap.put(t2, e3)), e3.count++;
        }, Yt.prototype.interfaces_ = function() {
          return [];
        }, Yt.prototype.getClass = function() {
          return Yt;
        }, Yt.getBoundary = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return new Yt(t2).getBoundary();
          }
          if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            return new Yt(e3, n2).getBoundary();
          }
        };
        var kt = function() {
          this.count = null;
        };
        kt.prototype.interfaces_ = function() {
          return [];
        }, kt.prototype.getClass = function() {
          return kt;
        };
        var jt = function() {
        }, Ht = { NEWLINE: { configurable: true }, SIMPLE_ORDINATE_FORMAT: { configurable: true } };
        jt.prototype.interfaces_ = function() {
          return [];
        }, jt.prototype.getClass = function() {
          return jt;
        }, jt.chars = function(t2, e3) {
          for (var n2 = new Array(e3).fill(null), i2 = 0; i2 < e3; i2++)
            n2[i2] = t2;
          return String(n2);
        }, jt.getStackTrace = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0], e3 = new function() {
            }(), n2 = new function() {
            }(e3);
            return t2.printStackTrace(n2), e3.toString();
          }
          if (arguments.length === 2) {
            for (var i2 = arguments[0], r2 = arguments[1], o2 = "", s2 = new function() {
            }(new function() {
            }(jt.getStackTrace(i2))), a2 = 0; a2 < r2; a2++)
              try {
                o2 += s2.readLine() + jt.NEWLINE;
              } catch (t3) {
                if (!(t3 instanceof g))
                  throw t3;
                et.shouldNeverReachHere();
              }
            return o2;
          }
        }, jt.split = function(t2, e3) {
          for (var n2 = e3.length, i2 = new Nt(), r2 = "" + t2, o2 = r2.indexOf(e3); o2 >= 0; ) {
            var s2 = r2.substring(0, o2);
            i2.add(s2), o2 = (r2 = r2.substring(o2 + n2)).indexOf(e3);
          }
          r2.length > 0 && i2.add(r2);
          for (var a2 = new Array(i2.size()).fill(null), u2 = 0; u2 < a2.length; u2++)
            a2[u2] = i2.get(u2);
          return a2;
        }, jt.toString = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return jt.SIMPLE_ORDINATE_FORMAT.format(t2);
          }
        }, jt.spaces = function(t2) {
          return jt.chars(" ", t2);
        }, Ht.NEWLINE.get = function() {
          return Y.getProperty("line.separator");
        }, Ht.SIMPLE_ORDINATE_FORMAT.get = function() {
          return new function() {
          }("0.#");
        }, Object.defineProperties(jt, Ht);
        var Wt = function() {
        };
        Wt.prototype.interfaces_ = function() {
          return [];
        }, Wt.prototype.getClass = function() {
          return Wt;
        }, Wt.copyCoord = function(t2, e3, n2, i2) {
          for (var r2 = Math.min(t2.getDimension(), n2.getDimension()), o2 = 0; o2 < r2; o2++)
            n2.setOrdinate(i2, o2, t2.getOrdinate(e3, o2));
        }, Wt.isRing = function(t2) {
          var e3 = t2.size();
          return e3 === 0 || !(e3 <= 3) && (t2.getOrdinate(0, V.X) === t2.getOrdinate(e3 - 1, V.X) && t2.getOrdinate(0, V.Y) === t2.getOrdinate(e3 - 1, V.Y));
        }, Wt.isEqual = function(t2, e3) {
          var n2 = t2.size();
          if (n2 !== e3.size())
            return false;
          for (var i2 = Math.min(t2.getDimension(), e3.getDimension()), r2 = 0; r2 < n2; r2++)
            for (var o2 = 0; o2 < i2; o2++) {
              var s2 = t2.getOrdinate(r2, o2), a2 = e3.getOrdinate(r2, o2);
              if (t2.getOrdinate(r2, o2) !== e3.getOrdinate(r2, o2) && (!v.isNaN(s2) || !v.isNaN(a2)))
                return false;
            }
          return true;
        }, Wt.extend = function(t2, e3, n2) {
          var i2 = t2.create(n2, e3.getDimension()), r2 = e3.size();
          if (Wt.copy(e3, 0, i2, 0, r2), r2 > 0)
            for (var o2 = r2; o2 < n2; o2++)
              Wt.copy(e3, r2 - 1, i2, o2, 1);
          return i2;
        }, Wt.reverse = function(t2) {
          for (var e3 = t2.size() - 1, n2 = Math.trunc(e3 / 2), i2 = 0; i2 <= n2; i2++)
            Wt.swap(t2, i2, e3 - i2);
        }, Wt.swap = function(t2, e3, n2) {
          if (e3 === n2)
            return null;
          for (var i2 = 0; i2 < t2.getDimension(); i2++) {
            var r2 = t2.getOrdinate(e3, i2);
            t2.setOrdinate(e3, i2, t2.getOrdinate(n2, i2)), t2.setOrdinate(n2, i2, r2);
          }
        }, Wt.copy = function(t2, e3, n2, i2, r2) {
          for (var o2 = 0; o2 < r2; o2++)
            Wt.copyCoord(t2, e3 + o2, n2, i2 + o2);
        }, Wt.toString = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0], e3 = t2.size();
            if (e3 === 0)
              return "()";
            var n2 = t2.getDimension(), i2 = new D();
            i2.append("(");
            for (var r2 = 0; r2 < e3; r2++) {
              r2 > 0 && i2.append(" ");
              for (var o2 = 0; o2 < n2; o2++)
                o2 > 0 && i2.append(","), i2.append(jt.toString(t2.getOrdinate(r2, o2)));
            }
            return i2.append(")"), i2.toString();
          }
        }, Wt.ensureValidRing = function(t2, e3) {
          var n2 = e3.size();
          if (n2 === 0)
            return e3;
          if (n2 <= 3)
            return Wt.createClosedRing(t2, e3, 4);
          return e3.getOrdinate(0, V.X) === e3.getOrdinate(n2 - 1, V.X) && e3.getOrdinate(0, V.Y) === e3.getOrdinate(n2 - 1, V.Y) ? e3 : Wt.createClosedRing(t2, e3, n2 + 1);
        }, Wt.createClosedRing = function(t2, e3, n2) {
          var i2 = t2.create(n2, e3.getDimension()), r2 = e3.size();
          Wt.copy(e3, 0, i2, 0, r2);
          for (var o2 = r2; o2 < n2; o2++)
            Wt.copy(e3, 0, i2, o2, 1);
          return i2;
        };
        var Kt = function(t2) {
          function e3(e4, n3) {
            t2.call(this, n3), this._points = null, this.init(e4);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            return this.isEmpty() ? new j() : this._points.expandEnvelope(new j());
          }, e3.prototype.isRing = function() {
            return this.isClosed() && this.isSimple();
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_LINESTRING;
          }, e3.prototype.getCoordinates = function() {
            return this._points.toCoordinateArray();
          }, e3.prototype.equalsExact = function() {
            if (arguments.length === 2) {
              var e4 = arguments[0], n3 = arguments[1];
              if (!this.isEquivalentClass(e4))
                return false;
              var i2 = e4;
              if (this._points.size() !== i2._points.size())
                return false;
              for (var r2 = 0; r2 < this._points.size(); r2++)
                if (!this.equal(this._points.getCoordinate(r2), i2._points.getCoordinate(r2), n3))
                  return false;
              return true;
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
            for (var t3 = 0; t3 < Math.trunc(this._points.size() / 2); t3++) {
              var e4 = this._points.size() - 1 - t3;
              if (!this._points.getCoordinate(t3).equals(this._points.getCoordinate(e4)))
                return this._points.getCoordinate(t3).compareTo(this._points.getCoordinate(e4)) > 0 && Wt.reverse(this._points), null;
            }
          }, e3.prototype.getCoordinate = function() {
            return this.isEmpty() ? null : this._points.getCoordinate(0);
          }, e3.prototype.getBoundaryDimension = function() {
            return this.isClosed() ? qt.FALSE : 0;
          }, e3.prototype.isClosed = function() {
            return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
          }, e3.prototype.getEndPoint = function() {
            return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
          }, e3.prototype.getDimension = function() {
            return 1;
          }, e3.prototype.getLength = function() {
            return at.computeLength(this._points);
          }, e3.prototype.getNumPoints = function() {
            return this._points.size();
          }, e3.prototype.reverse = function() {
            var t3 = this._points.copy();
            Wt.reverse(t3);
            return this.getFactory().createLineString(t3);
          }, e3.prototype.compareToSameClass = function() {
            if (arguments.length === 1) {
              for (var t3 = arguments[0], e4 = 0, n3 = 0; e4 < this._points.size() && n3 < t3._points.size(); ) {
                var i2 = this._points.getCoordinate(e4).compareTo(t3._points.getCoordinate(n3));
                if (i2 !== 0)
                  return i2;
                e4++, n3++;
              }
              return e4 < this._points.size() ? 1 : n3 < t3._points.size() ? -1 : 0;
            }
            if (arguments.length === 2) {
              var r2 = arguments[0];
              return arguments[1].compare(this._points, r2._points);
            }
          }, e3.prototype.apply = function() {
            if (T(arguments[0], ft))
              for (var t3 = arguments[0], e4 = 0; e4 < this._points.size(); e4++)
                t3.filter(this._points.getCoordinate(e4));
            else if (T(arguments[0], Ut)) {
              var n3 = arguments[0];
              if (this._points.size() === 0)
                return null;
              for (var i2 = 0; i2 < this._points.size() && (n3.filter(this._points, i2), !n3.isDone()); i2++)
                ;
              n3.isGeometryChanged() && this.geometryChanged();
            } else if (T(arguments[0], Vt)) {
              arguments[0].filter(this);
            } else if (T(arguments[0], lt)) {
              arguments[0].filter(this);
            }
          }, e3.prototype.getBoundary = function() {
            return new Yt(this).getBoundary();
          }, e3.prototype.isEquivalentClass = function(t3) {
            return t3 instanceof e3;
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            return e4._points = this._points.clone(), e4;
          }, e3.prototype.getCoordinateN = function(t3) {
            return this._points.getCoordinate(t3);
          }, e3.prototype.getGeometryType = function() {
            return "LineString";
          }, e3.prototype.copy = function() {
            return new e3(this._points.copy(), this._factory);
          }, e3.prototype.getCoordinateSequence = function() {
            return this._points;
          }, e3.prototype.isEmpty = function() {
            return this._points.size() === 0;
          }, e3.prototype.init = function(t3) {
            if (t3 === null && (t3 = this.getFactory().getCoordinateSequenceFactory().create([])), t3.size() === 1)
              throw new m("Invalid number of points in LineString (found " + t3.size() + " - must be 0 or >= 2)");
            this._points = t3;
          }, e3.prototype.isCoordinate = function(t3) {
            for (var e4 = 0; e4 < this._points.size(); e4++)
              if (this._points.getCoordinate(e4).equals(t3))
                return true;
            return false;
          }, e3.prototype.getStartPoint = function() {
            return this.isEmpty() ? null : this.getPointN(0);
          }, e3.prototype.getPointN = function(t3) {
            return this.getFactory().createPoint(this._points.getCoordinate(t3));
          }, e3.prototype.interfaces_ = function() {
            return [At];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return 3110669828065365500;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), Jt = function() {
        };
        Jt.prototype.interfaces_ = function() {
          return [];
        }, Jt.prototype.getClass = function() {
          return Jt;
        };
        var Qt = function(t2) {
          function e3(e4, n3) {
            t2.call(this, n3), this._coordinates = e4 || null, this.init(this._coordinates);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            if (this.isEmpty())
              return new j();
            var t3 = new j();
            return t3.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t3;
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_POINT;
          }, e3.prototype.getCoordinates = function() {
            return this.isEmpty() ? [] : [this.getCoordinate()];
          }, e3.prototype.equalsExact = function() {
            if (arguments.length === 2) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && (!(!this.isEmpty() || !e4.isEmpty()) || this.isEmpty() === e4.isEmpty() && this.equal(e4.getCoordinate(), this.getCoordinate(), n3));
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
          }, e3.prototype.getCoordinate = function() {
            return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
          }, e3.prototype.getBoundaryDimension = function() {
            return qt.FALSE;
          }, e3.prototype.getDimension = function() {
            return 0;
          }, e3.prototype.getNumPoints = function() {
            return this.isEmpty() ? 0 : 1;
          }, e3.prototype.reverse = function() {
            return this.copy();
          }, e3.prototype.getX = function() {
            if (this.getCoordinate() === null)
              throw new Error("getX called on empty Point");
            return this.getCoordinate().x;
          }, e3.prototype.compareToSameClass = function() {
            if (arguments.length === 1) {
              var t3 = arguments[0];
              return this.getCoordinate().compareTo(t3.getCoordinate());
            }
            if (arguments.length === 2) {
              var e4 = arguments[0];
              return arguments[1].compare(this._coordinates, e4._coordinates);
            }
          }, e3.prototype.apply = function() {
            if (T(arguments[0], ft)) {
              var t3 = arguments[0];
              if (this.isEmpty())
                return null;
              t3.filter(this.getCoordinate());
            } else if (T(arguments[0], Ut)) {
              var e4 = arguments[0];
              if (this.isEmpty())
                return null;
              e4.filter(this._coordinates, 0), e4.isGeometryChanged() && this.geometryChanged();
            } else if (T(arguments[0], Vt)) {
              arguments[0].filter(this);
            } else if (T(arguments[0], lt)) {
              arguments[0].filter(this);
            }
          }, e3.prototype.getBoundary = function() {
            return this.getFactory().createGeometryCollection(null);
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            return e4._coordinates = this._coordinates.clone(), e4;
          }, e3.prototype.getGeometryType = function() {
            return "Point";
          }, e3.prototype.copy = function() {
            return new e3(this._coordinates.copy(), this._factory);
          }, e3.prototype.getCoordinateSequence = function() {
            return this._coordinates;
          }, e3.prototype.getY = function() {
            if (this.getCoordinate() === null)
              throw new Error("getY called on empty Point");
            return this.getCoordinate().y;
          }, e3.prototype.isEmpty = function() {
            return this._coordinates.size() === 0;
          }, e3.prototype.init = function(t3) {
            t3 === null && (t3 = this.getFactory().getCoordinateSequenceFactory().create([])), et.isTrue(t3.size() <= 1), this._coordinates = t3;
          }, e3.prototype.isSimple = function() {
            return true;
          }, e3.prototype.interfaces_ = function() {
            return [Jt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return 4902022702746615e3;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), Zt = function() {
        };
        Zt.prototype.interfaces_ = function() {
          return [];
        }, Zt.prototype.getClass = function() {
          return Zt;
        };
        var $t = function(t2) {
          function e3(e4, n3, i2) {
            if (t2.call(this, i2), this._shell = null, this._holes = null, e4 === null && (e4 = this.getFactory().createLinearRing()), n3 === null && (n3 = []), t2.hasNullElements(n3))
              throw new m("holes must not contain null elements");
            if (e4.isEmpty() && t2.hasNonEmptyElements(n3))
              throw new m("shell is empty but holes are not");
            this._shell = e4, this._holes = n3;
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            return this._shell.getEnvelopeInternal();
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_POLYGON;
          }, e3.prototype.getCoordinates = function() {
            if (this.isEmpty())
              return [];
            for (var t3 = new Array(this.getNumPoints()).fill(null), e4 = -1, n3 = this._shell.getCoordinates(), i2 = 0; i2 < n3.length; i2++)
              t3[++e4] = n3[i2];
            for (var r2 = 0; r2 < this._holes.length; r2++)
              for (var o2 = this._holes[r2].getCoordinates(), s2 = 0; s2 < o2.length; s2++)
                t3[++e4] = o2[s2];
            return t3;
          }, e3.prototype.getArea = function() {
            var t3 = 0;
            t3 += Math.abs(at.signedArea(this._shell.getCoordinateSequence()));
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3 -= Math.abs(at.signedArea(this._holes[e4].getCoordinateSequence()));
            return t3;
          }, e3.prototype.isRectangle = function() {
            if (this.getNumInteriorRing() !== 0)
              return false;
            if (this._shell === null)
              return false;
            if (this._shell.getNumPoints() !== 5)
              return false;
            for (var t3 = this._shell.getCoordinateSequence(), e4 = this.getEnvelopeInternal(), n3 = 0; n3 < 5; n3++) {
              var i2 = t3.getX(n3);
              if (i2 !== e4.getMinX() && i2 !== e4.getMaxX())
                return false;
              var r2 = t3.getY(n3);
              if (r2 !== e4.getMinY() && r2 !== e4.getMaxY())
                return false;
            }
            for (var o2 = t3.getX(0), s2 = t3.getY(0), a2 = 1; a2 <= 4; a2++) {
              var u2 = t3.getX(a2), l2 = t3.getY(a2);
              if (u2 !== o2 === (l2 !== s2))
                return false;
              o2 = u2, s2 = l2;
            }
            return true;
          }, e3.prototype.equalsExact = function() {
            if (arguments.length === 2) {
              var e4 = arguments[0], n3 = arguments[1];
              if (!this.isEquivalentClass(e4))
                return false;
              var i2 = e4, r2 = this._shell, o2 = i2._shell;
              if (!r2.equalsExact(o2, n3))
                return false;
              if (this._holes.length !== i2._holes.length)
                return false;
              for (var s2 = 0; s2 < this._holes.length; s2++)
                if (!this._holes[s2].equalsExact(i2._holes[s2], n3))
                  return false;
              return true;
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
            if (arguments.length === 0) {
              this.normalize(this._shell, true);
              for (var t3 = 0; t3 < this._holes.length; t3++)
                this.normalize(this._holes[t3], false);
              Gt.sort(this._holes);
            } else if (arguments.length === 2) {
              var e4 = arguments[0], n3 = arguments[1];
              if (e4.isEmpty())
                return null;
              var i2 = new Array(e4.getCoordinates().length - 1).fill(null);
              Y.arraycopy(e4.getCoordinates(), 0, i2, 0, i2.length);
              var r2 = Lt.minCoordinate(e4.getCoordinates());
              Lt.scroll(i2, r2), Y.arraycopy(i2, 0, e4.getCoordinates(), 0, i2.length), e4.getCoordinates()[i2.length] = i2[0], at.isCCW(e4.getCoordinates()) === n3 && Lt.reverse(e4.getCoordinates());
            }
          }, e3.prototype.getCoordinate = function() {
            return this._shell.getCoordinate();
          }, e3.prototype.getNumInteriorRing = function() {
            return this._holes.length;
          }, e3.prototype.getBoundaryDimension = function() {
            return 1;
          }, e3.prototype.getDimension = function() {
            return 2;
          }, e3.prototype.getLength = function() {
            var t3 = 0;
            t3 += this._shell.getLength();
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3 += this._holes[e4].getLength();
            return t3;
          }, e3.prototype.getNumPoints = function() {
            for (var t3 = this._shell.getNumPoints(), e4 = 0; e4 < this._holes.length; e4++)
              t3 += this._holes[e4].getNumPoints();
            return t3;
          }, e3.prototype.reverse = function() {
            var t3 = this.copy();
            t3._shell = this._shell.copy().reverse(), t3._holes = new Array(this._holes.length).fill(null);
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3._holes[e4] = this._holes[e4].copy().reverse();
            return t3;
          }, e3.prototype.convexHull = function() {
            return this.getExteriorRing().convexHull();
          }, e3.prototype.compareToSameClass = function() {
            if (arguments.length === 1) {
              var t3 = arguments[0], e4 = this._shell, n3 = t3._shell;
              return e4.compareToSameClass(n3);
            }
            if (arguments.length === 2) {
              var i2 = arguments[0], r2 = arguments[1], o2 = i2, s2 = this._shell, a2 = o2._shell, u2 = s2.compareToSameClass(a2, r2);
              if (u2 !== 0)
                return u2;
              for (var l2 = this.getNumInteriorRing(), c2 = o2.getNumInteriorRing(), p2 = 0; p2 < l2 && p2 < c2; ) {
                var h2 = this.getInteriorRingN(p2), f2 = o2.getInteriorRingN(p2), g2 = h2.compareToSameClass(f2, r2);
                if (g2 !== 0)
                  return g2;
                p2++;
              }
              return p2 < l2 ? 1 : p2 < c2 ? -1 : 0;
            }
          }, e3.prototype.apply = function(t3) {
            if (T(t3, ft)) {
              this._shell.apply(t3);
              for (var e4 = 0; e4 < this._holes.length; e4++)
                this._holes[e4].apply(t3);
            } else if (T(t3, Ut)) {
              if (this._shell.apply(t3), !t3.isDone())
                for (var n3 = 0; n3 < this._holes.length && (this._holes[n3].apply(t3), !t3.isDone()); n3++)
                  ;
              t3.isGeometryChanged() && this.geometryChanged();
            } else if (T(t3, Vt))
              t3.filter(this);
            else if (T(t3, lt)) {
              t3.filter(this), this._shell.apply(t3);
              for (var i2 = 0; i2 < this._holes.length; i2++)
                this._holes[i2].apply(t3);
            }
          }, e3.prototype.getBoundary = function() {
            if (this.isEmpty())
              return this.getFactory().createMultiLineString();
            var t3 = new Array(this._holes.length + 1).fill(null);
            t3[0] = this._shell;
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3[e4 + 1] = this._holes[e4];
            return t3.length <= 1 ? this.getFactory().createLinearRing(t3[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t3);
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            e4._shell = this._shell.clone(), e4._holes = new Array(this._holes.length).fill(null);
            for (var n3 = 0; n3 < this._holes.length; n3++)
              e4._holes[n3] = this._holes[n3].clone();
            return e4;
          }, e3.prototype.getGeometryType = function() {
            return "Polygon";
          }, e3.prototype.copy = function() {
            for (var t3 = this._shell.copy(), n3 = new Array(this._holes.length).fill(null), i2 = 0; i2 < n3.length; i2++)
              n3[i2] = this._holes[i2].copy();
            return new e3(t3, n3, this._factory);
          }, e3.prototype.getExteriorRing = function() {
            return this._shell;
          }, e3.prototype.isEmpty = function() {
            return this._shell.isEmpty();
          }, e3.prototype.getInteriorRingN = function(t3) {
            return this._holes[t3];
          }, e3.prototype.interfaces_ = function() {
            return [Zt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -3494792200821764600;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), te = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_MULTIPOINT;
          }, e3.prototype.isValid = function() {
            return true;
          }, e3.prototype.equalsExact = function() {
            if (arguments.length === 2) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && t2.prototype.equalsExact.call(this, e4, n3);
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.getCoordinate = function() {
            if (arguments.length === 1) {
              var e4 = arguments[0];
              return this._geometries[e4].getCoordinate();
            }
            return t2.prototype.getCoordinate.apply(this, arguments);
          }, e3.prototype.getBoundaryDimension = function() {
            return qt.FALSE;
          }, e3.prototype.getDimension = function() {
            return 0;
          }, e3.prototype.getBoundary = function() {
            return this.getFactory().createGeometryCollection(null);
          }, e3.prototype.getGeometryType = function() {
            return "MultiPoint";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [Jt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -8048474874175356e3;
          }, Object.defineProperties(e3, n2), e3;
        }(zt), ee = function(t2) {
          function e3(e4, n3) {
            e4 instanceof C && n3 instanceof _e && (e4 = n3.getCoordinateSequenceFactory().create(e4)), t2.call(this, e4, n3), this.validateConstruction();
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { MINIMUM_VALID_SIZE: { configurable: true }, serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_LINEARRING;
          }, e3.prototype.getBoundaryDimension = function() {
            return qt.FALSE;
          }, e3.prototype.isClosed = function() {
            return !!this.isEmpty() || t2.prototype.isClosed.call(this);
          }, e3.prototype.reverse = function() {
            var t3 = this._points.copy();
            Wt.reverse(t3);
            return this.getFactory().createLinearRing(t3);
          }, e3.prototype.validateConstruction = function() {
            if (!this.isEmpty() && !t2.prototype.isClosed.call(this))
              throw new m("Points of LinearRing do not form a closed linestring");
            if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < e3.MINIMUM_VALID_SIZE)
              throw new m("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
          }, e3.prototype.getGeometryType = function() {
            return "LinearRing";
          }, e3.prototype.copy = function() {
            return new e3(this._points.copy(), this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.MINIMUM_VALID_SIZE.get = function() {
            return 4;
          }, n2.serialVersionUID.get = function() {
            return -4261142084085851600;
          }, Object.defineProperties(e3, n2), e3;
        }(Kt), ne = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_MULTIPOLYGON;
          }, e3.prototype.equalsExact = function() {
            if (arguments.length === 2) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && t2.prototype.equalsExact.call(this, e4, n3);
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.getBoundaryDimension = function() {
            return 1;
          }, e3.prototype.getDimension = function() {
            return 2;
          }, e3.prototype.reverse = function() {
            for (var t3 = this._geometries.length, e4 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
              e4[n3] = this._geometries[n3].reverse();
            return this.getFactory().createMultiPolygon(e4);
          }, e3.prototype.getBoundary = function() {
            if (this.isEmpty())
              return this.getFactory().createMultiLineString();
            for (var t3 = new Nt(), e4 = 0; e4 < this._geometries.length; e4++)
              for (var n3 = this._geometries[e4].getBoundary(), i2 = 0; i2 < n3.getNumGeometries(); i2++)
                t3.add(n3.getGeometryN(i2));
            var r2 = new Array(t3.size()).fill(null);
            return this.getFactory().createMultiLineString(t3.toArray(r2));
          }, e3.prototype.getGeometryType = function() {
            return "MultiPolygon";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [Zt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -551033529766975900;
          }, Object.defineProperties(e3, n2), e3;
        }(zt), ie = function(t2) {
          this._factory = t2 || null, this._isUserDataCopied = false;
        }, re = { NoOpGeometryOperation: { configurable: true }, CoordinateOperation: { configurable: true }, CoordinateSequenceOperation: { configurable: true } };
        ie.prototype.setCopyUserData = function(t2) {
          this._isUserDataCopied = t2;
        }, ie.prototype.edit = function(t2, e3) {
          if (t2 === null)
            return null;
          var n2 = this.editInternal(t2, e3);
          return this._isUserDataCopied && n2.setUserData(t2.getUserData()), n2;
        }, ie.prototype.editInternal = function(t2, e3) {
          return this._factory === null && (this._factory = t2.getFactory()), t2 instanceof zt ? this.editGeometryCollection(t2, e3) : t2 instanceof $t ? this.editPolygon(t2, e3) : t2 instanceof Qt ? e3.edit(t2, this._factory) : t2 instanceof Kt ? e3.edit(t2, this._factory) : (et.shouldNeverReachHere("Unsupported Geometry class: " + t2.getClass().getName()), null);
        }, ie.prototype.editGeometryCollection = function(t2, e3) {
          for (var n2 = e3.edit(t2, this._factory), i2 = new Nt(), r2 = 0; r2 < n2.getNumGeometries(); r2++) {
            var o2 = this.edit(n2.getGeometryN(r2), e3);
            o2 === null || o2.isEmpty() || i2.add(o2);
          }
          return n2.getClass() === te ? this._factory.createMultiPoint(i2.toArray([])) : n2.getClass() === Xt ? this._factory.createMultiLineString(i2.toArray([])) : n2.getClass() === ne ? this._factory.createMultiPolygon(i2.toArray([])) : this._factory.createGeometryCollection(i2.toArray([]));
        }, ie.prototype.editPolygon = function(t2, e3) {
          var n2 = e3.edit(t2, this._factory);
          if (n2 === null && (n2 = this._factory.createPolygon(null)), n2.isEmpty())
            return n2;
          var i2 = this.edit(n2.getExteriorRing(), e3);
          if (i2 === null || i2.isEmpty())
            return this._factory.createPolygon();
          for (var r2 = new Nt(), o2 = 0; o2 < n2.getNumInteriorRing(); o2++) {
            var s2 = this.edit(n2.getInteriorRingN(o2), e3);
            s2 === null || s2.isEmpty() || r2.add(s2);
          }
          return this._factory.createPolygon(i2, r2.toArray([]));
        }, ie.prototype.interfaces_ = function() {
          return [];
        }, ie.prototype.getClass = function() {
          return ie;
        }, ie.GeometryEditorOperation = function() {
        }, re.NoOpGeometryOperation.get = function() {
          return oe;
        }, re.CoordinateOperation.get = function() {
          return se;
        }, re.CoordinateSequenceOperation.get = function() {
          return ae;
        }, Object.defineProperties(ie, re);
        var oe = function() {
        };
        oe.prototype.edit = function(t2, e3) {
          return t2;
        }, oe.prototype.interfaces_ = function() {
          return [ie.GeometryEditorOperation];
        }, oe.prototype.getClass = function() {
          return oe;
        };
        var se = function() {
        };
        se.prototype.edit = function(t2, e3) {
          var n2 = this.editCoordinates(t2.getCoordinates(), t2);
          return n2 === null ? t2 : t2 instanceof ee ? e3.createLinearRing(n2) : t2 instanceof Kt ? e3.createLineString(n2) : t2 instanceof Qt ? n2.length > 0 ? e3.createPoint(n2[0]) : e3.createPoint() : t2;
        }, se.prototype.interfaces_ = function() {
          return [ie.GeometryEditorOperation];
        }, se.prototype.getClass = function() {
          return se;
        };
        var ae = function() {
        };
        ae.prototype.edit = function(t2, e3) {
          return t2 instanceof ee ? e3.createLinearRing(this.edit(t2.getCoordinateSequence(), t2)) : t2 instanceof Kt ? e3.createLineString(this.edit(t2.getCoordinateSequence(), t2)) : t2 instanceof Qt ? e3.createPoint(this.edit(t2.getCoordinateSequence(), t2)) : t2;
        }, ae.prototype.interfaces_ = function() {
          return [ie.GeometryEditorOperation];
        }, ae.prototype.getClass = function() {
          return ae;
        };
        var ue = function() {
          if (this._dimension = 3, this._coordinates = null, arguments.length === 1) {
            if (arguments[0] instanceof Array)
              this._coordinates = arguments[0], this._dimension = 3;
            else if (Number.isInteger(arguments[0])) {
              var t2 = arguments[0];
              this._coordinates = new Array(t2).fill(null);
              for (var e3 = 0; e3 < t2; e3++)
                this._coordinates[e3] = new C();
            } else if (T(arguments[0], V)) {
              var n2 = arguments[0];
              if (n2 === null)
                return this._coordinates = new Array(0).fill(null), null;
              this._dimension = n2.getDimension(), this._coordinates = new Array(n2.size()).fill(null);
              for (var i2 = 0; i2 < this._coordinates.length; i2++)
                this._coordinates[i2] = n2.getCoordinateCopy(i2);
            }
          } else if (arguments.length === 2) {
            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var r2 = arguments[0], o2 = arguments[1];
              this._coordinates = r2, this._dimension = o2, r2 === null && (this._coordinates = new Array(0).fill(null));
            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var s2 = arguments[0], a2 = arguments[1];
              this._coordinates = new Array(s2).fill(null), this._dimension = a2;
              for (var u2 = 0; u2 < s2; u2++)
                this._coordinates[u2] = new C();
            }
          }
        }, le = { serialVersionUID: { configurable: true } };
        ue.prototype.setOrdinate = function(t2, e3, n2) {
          switch (e3) {
            case V.X:
              this._coordinates[t2].x = n2;
              break;
            case V.Y:
              this._coordinates[t2].y = n2;
              break;
            case V.Z:
              this._coordinates[t2].z = n2;
              break;
            default:
              throw new m("invalid ordinateIndex");
          }
        }, ue.prototype.size = function() {
          return this._coordinates.length;
        }, ue.prototype.getOrdinate = function(t2, e3) {
          switch (e3) {
            case V.X:
              return this._coordinates[t2].x;
            case V.Y:
              return this._coordinates[t2].y;
            case V.Z:
              return this._coordinates[t2].z;
          }
          return v.NaN;
        }, ue.prototype.getCoordinate = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return this._coordinates[t2];
          }
          if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            n2.x = this._coordinates[e3].x, n2.y = this._coordinates[e3].y, n2.z = this._coordinates[e3].z;
          }
        }, ue.prototype.getCoordinateCopy = function(t2) {
          return new C(this._coordinates[t2]);
        }, ue.prototype.getDimension = function() {
          return this._dimension;
        }, ue.prototype.getX = function(t2) {
          return this._coordinates[t2].x;
        }, ue.prototype.clone = function() {
          for (var t2 = new Array(this.size()).fill(null), e3 = 0; e3 < this._coordinates.length; e3++)
            t2[e3] = this._coordinates[e3].clone();
          return new ue(t2, this._dimension);
        }, ue.prototype.expandEnvelope = function(t2) {
          for (var e3 = 0; e3 < this._coordinates.length; e3++)
            t2.expandToInclude(this._coordinates[e3]);
          return t2;
        }, ue.prototype.copy = function() {
          for (var t2 = new Array(this.size()).fill(null), e3 = 0; e3 < this._coordinates.length; e3++)
            t2[e3] = this._coordinates[e3].copy();
          return new ue(t2, this._dimension);
        }, ue.prototype.toString = function() {
          if (this._coordinates.length > 0) {
            var t2 = new D(17 * this._coordinates.length);
            t2.append("("), t2.append(this._coordinates[0]);
            for (var e3 = 1; e3 < this._coordinates.length; e3++)
              t2.append(", "), t2.append(this._coordinates[e3]);
            return t2.append(")"), t2.toString();
          }
          return "()";
        }, ue.prototype.getY = function(t2) {
          return this._coordinates[t2].y;
        }, ue.prototype.toCoordinateArray = function() {
          return this._coordinates;
        }, ue.prototype.interfaces_ = function() {
          return [V, e];
        }, ue.prototype.getClass = function() {
          return ue;
        }, le.serialVersionUID.get = function() {
          return -915438501601840600;
        }, Object.defineProperties(ue, le);
        var ce = function() {
        }, pe = { serialVersionUID: { configurable: true }, instanceObject: { configurable: true } };
        ce.prototype.readResolve = function() {
          return ce.instance();
        }, ce.prototype.create = function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return new ue(t2);
            }
            if (T(arguments[0], V)) {
              var e3 = arguments[0];
              return new ue(e3);
            }
          } else if (arguments.length === 2) {
            var n2 = arguments[0], i2 = arguments[1];
            return i2 > 3 && (i2 = 3), i2 < 2 ? new ue(n2) : new ue(n2, i2);
          }
        }, ce.prototype.interfaces_ = function() {
          return [b, e];
        }, ce.prototype.getClass = function() {
          return ce;
        }, ce.instance = function() {
          return ce.instanceObject;
        }, pe.serialVersionUID.get = function() {
          return -4099577099607551500;
        }, pe.instanceObject.get = function() {
          return new ce();
        }, Object.defineProperties(ce, pe);
        var he = function(t2) {
          function e3() {
            t2.call(this), this.map_ = /* @__PURE__ */ new Map();
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.get = function(t3) {
            return this.map_.get(t3) || null;
          }, e3.prototype.put = function(t3, e4) {
            return this.map_.set(t3, e4), e4;
          }, e3.prototype.values = function() {
            for (var t3 = new Nt(), e4 = this.map_.values(), n2 = e4.next(); !n2.done; )
              t3.add(n2.value), n2 = e4.next();
            return t3;
          }, e3.prototype.entrySet = function() {
            var t3 = new Pt();
            return this.map_.entries().forEach(function(e4) {
              return t3.add(e4);
            }), t3;
          }, e3.prototype.size = function() {
            return this.map_.size();
          }, e3;
        }(Tt), fe = function t2() {
          if (this._modelType = null, this._scale = null, arguments.length === 0)
            this._modelType = t2.FLOATING;
          else if (arguments.length === 1) {
            if (arguments[0] instanceof de) {
              var e3 = arguments[0];
              this._modelType = e3, e3 === t2.FIXED && this.setScale(1);
            } else if (typeof arguments[0] == "number") {
              var n2 = arguments[0];
              this._modelType = t2.FIXED, this.setScale(n2);
            } else if (arguments[0] instanceof t2) {
              var i2 = arguments[0];
              this._modelType = i2._modelType, this._scale = i2._scale;
            }
          }
        }, ge = { serialVersionUID: { configurable: true }, maximumPreciseValue: { configurable: true } };
        fe.prototype.equals = function(t2) {
          if (!(t2 instanceof fe))
            return false;
          var e3 = t2;
          return this._modelType === e3._modelType && this._scale === e3._scale;
        }, fe.prototype.compareTo = function(t2) {
          var e3 = t2, n2 = this.getMaximumSignificantDigits(), i2 = e3.getMaximumSignificantDigits();
          return new M(n2).compareTo(new M(i2));
        }, fe.prototype.getScale = function() {
          return this._scale;
        }, fe.prototype.isFloating = function() {
          return this._modelType === fe.FLOATING || this._modelType === fe.FLOATING_SINGLE;
        }, fe.prototype.getType = function() {
          return this._modelType;
        }, fe.prototype.toString = function() {
          var t2 = "UNKNOWN";
          return this._modelType === fe.FLOATING ? t2 = "Floating" : this._modelType === fe.FLOATING_SINGLE ? t2 = "Floating-Single" : this._modelType === fe.FIXED && (t2 = "Fixed (Scale=" + this.getScale() + ")"), t2;
        }, fe.prototype.makePrecise = function() {
          if (typeof arguments[0] == "number") {
            var t2 = arguments[0];
            if (v.isNaN(t2))
              return t2;
            if (this._modelType === fe.FLOATING_SINGLE) {
              return t2;
            }
            return this._modelType === fe.FIXED ? Math.round(t2 * this._scale) / this._scale : t2;
          }
          if (arguments[0] instanceof C) {
            var e3 = arguments[0];
            if (this._modelType === fe.FLOATING)
              return null;
            e3.x = this.makePrecise(e3.x), e3.y = this.makePrecise(e3.y);
          }
        }, fe.prototype.getMaximumSignificantDigits = function() {
          var t2 = 16;
          return this._modelType === fe.FLOATING ? t2 = 16 : this._modelType === fe.FLOATING_SINGLE ? t2 = 6 : this._modelType === fe.FIXED && (t2 = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t2;
        }, fe.prototype.setScale = function(t2) {
          this._scale = Math.abs(t2);
        }, fe.prototype.interfaces_ = function() {
          return [e, E];
        }, fe.prototype.getClass = function() {
          return fe;
        }, fe.mostPrecise = function(t2, e3) {
          return t2.compareTo(e3) >= 0 ? t2 : e3;
        }, ge.serialVersionUID.get = function() {
          return 7777263578777804e3;
        }, ge.maximumPreciseValue.get = function() {
          return 9007199254740992;
        }, Object.defineProperties(fe, ge);
        var de = function t2(e3) {
          this._name = e3 || null, t2.nameToTypeMap.put(e3, this);
        }, ye = { serialVersionUID: { configurable: true }, nameToTypeMap: { configurable: true } };
        de.prototype.readResolve = function() {
          return de.nameToTypeMap.get(this._name);
        }, de.prototype.toString = function() {
          return this._name;
        }, de.prototype.interfaces_ = function() {
          return [e];
        }, de.prototype.getClass = function() {
          return de;
        }, ye.serialVersionUID.get = function() {
          return -552860263173159e4;
        }, ye.nameToTypeMap.get = function() {
          return new he();
        }, Object.defineProperties(de, ye), fe.Type = de, fe.FIXED = new de("FIXED"), fe.FLOATING = new de("FLOATING"), fe.FLOATING_SINGLE = new de("FLOATING SINGLE");
        var _e = function t2() {
          this._precisionModel = new fe(), this._SRID = 0, this._coordinateSequenceFactory = t2.getDefaultCoordinateSequenceFactory(), arguments.length === 0 || (arguments.length === 1 ? T(arguments[0], b) ? this._coordinateSequenceFactory = arguments[0] : arguments[0] instanceof fe && (this._precisionModel = arguments[0]) : arguments.length === 2 ? (this._precisionModel = arguments[0], this._SRID = arguments[1]) : arguments.length === 3 && (this._precisionModel = arguments[0], this._SRID = arguments[1], this._coordinateSequenceFactory = arguments[2]));
        }, me = { serialVersionUID: { configurable: true } };
        _e.prototype.toGeometry = function(t2) {
          return t2.isNull() ? this.createPoint(null) : t2.getMinX() === t2.getMaxX() && t2.getMinY() === t2.getMaxY() ? this.createPoint(new C(t2.getMinX(), t2.getMinY())) : t2.getMinX() === t2.getMaxX() || t2.getMinY() === t2.getMaxY() ? this.createLineString([new C(t2.getMinX(), t2.getMinY()), new C(t2.getMaxX(), t2.getMaxY())]) : this.createPolygon(this.createLinearRing([new C(t2.getMinX(), t2.getMinY()), new C(t2.getMinX(), t2.getMaxY()), new C(t2.getMaxX(), t2.getMaxY()), new C(t2.getMaxX(), t2.getMinY()), new C(t2.getMinX(), t2.getMinY())]), null);
        }, _e.prototype.createLineString = function(t2) {
          return t2 ? t2 instanceof Array ? new Kt(this.getCoordinateSequenceFactory().create(t2), this) : T(t2, V) ? new Kt(t2, this) : void 0 : new Kt(this.getCoordinateSequenceFactory().create([]), this);
        }, _e.prototype.createMultiLineString = function() {
          if (arguments.length === 0)
            return new Xt(null, this);
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return new Xt(t2, this);
          }
        }, _e.prototype.buildGeometry = function(t2) {
          for (var e3 = null, n2 = false, i2 = false, r2 = t2.iterator(); r2.hasNext(); ) {
            var o2 = r2.next(), s2 = o2.getClass();
            e3 === null && (e3 = s2), s2 !== e3 && (n2 = true), o2.isGeometryCollectionOrDerived() && (i2 = true);
          }
          if (e3 === null)
            return this.createGeometryCollection();
          if (n2 || i2)
            return this.createGeometryCollection(_e.toGeometryArray(t2));
          var a2 = t2.iterator().next();
          if (t2.size() > 1) {
            if (a2 instanceof $t)
              return this.createMultiPolygon(_e.toPolygonArray(t2));
            if (a2 instanceof Kt)
              return this.createMultiLineString(_e.toLineStringArray(t2));
            if (a2 instanceof Qt)
              return this.createMultiPoint(_e.toPointArray(t2));
            et.shouldNeverReachHere("Unhandled class: " + a2.getClass().getName());
          }
          return a2;
        }, _e.prototype.createMultiPointFromCoords = function(t2) {
          return this.createMultiPoint(t2 !== null ? this.getCoordinateSequenceFactory().create(t2) : null);
        }, _e.prototype.createPoint = function() {
          if (arguments.length === 0)
            return this.createPoint(this.getCoordinateSequenceFactory().create([]));
          if (arguments.length === 1) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              return this.createPoint(t2 !== null ? this.getCoordinateSequenceFactory().create([t2]) : null);
            }
            if (T(arguments[0], V)) {
              var e3 = arguments[0];
              return new Qt(e3, this);
            }
          }
        }, _e.prototype.getCoordinateSequenceFactory = function() {
          return this._coordinateSequenceFactory;
        }, _e.prototype.createPolygon = function() {
          if (arguments.length === 0)
            return new $t(null, null, this);
          if (arguments.length === 1) {
            if (T(arguments[0], V)) {
              var t2 = arguments[0];
              return this.createPolygon(this.createLinearRing(t2));
            }
            if (arguments[0] instanceof Array) {
              var e3 = arguments[0];
              return this.createPolygon(this.createLinearRing(e3));
            }
            if (arguments[0] instanceof ee) {
              var n2 = arguments[0];
              return this.createPolygon(n2, null);
            }
          } else if (arguments.length === 2) {
            var i2 = arguments[0], r2 = arguments[1];
            return new $t(i2, r2, this);
          }
        }, _e.prototype.getSRID = function() {
          return this._SRID;
        }, _e.prototype.createGeometryCollection = function() {
          if (arguments.length === 0)
            return new zt(null, this);
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return new zt(t2, this);
          }
        }, _e.prototype.createGeometry = function(t2) {
          return new ie(this).edit(t2, { edit: function() {
            if (arguments.length === 2) {
              var t3 = arguments[0];
              return this._coordinateSequenceFactory.create(t3);
            }
          } });
        }, _e.prototype.getPrecisionModel = function() {
          return this._precisionModel;
        }, _e.prototype.createLinearRing = function() {
          if (arguments.length === 0)
            return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return this.createLinearRing(t2 !== null ? this.getCoordinateSequenceFactory().create(t2) : null);
            }
            if (T(arguments[0], V)) {
              var e3 = arguments[0];
              return new ee(e3, this);
            }
          }
        }, _e.prototype.createMultiPolygon = function() {
          if (arguments.length === 0)
            return new ne(null, this);
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return new ne(t2, this);
          }
        }, _e.prototype.createMultiPoint = function() {
          if (arguments.length === 0)
            return new te(null, this);
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return new te(t2, this);
            }
            if (arguments[0] instanceof Array) {
              var e3 = arguments[0];
              return this.createMultiPoint(e3 !== null ? this.getCoordinateSequenceFactory().create(e3) : null);
            }
            if (T(arguments[0], V)) {
              var n2 = arguments[0];
              if (n2 === null)
                return this.createMultiPoint(new Array(0).fill(null));
              for (var i2 = new Array(n2.size()).fill(null), r2 = 0; r2 < n2.size(); r2++) {
                var o2 = this.getCoordinateSequenceFactory().create(1, n2.getDimension());
                Wt.copy(n2, r2, o2, 0, 1), i2[r2] = this.createPoint(o2);
              }
              return this.createMultiPoint(i2);
            }
          }
        }, _e.prototype.interfaces_ = function() {
          return [e];
        }, _e.prototype.getClass = function() {
          return _e;
        }, _e.toMultiPolygonArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toGeometryArray = function(t2) {
          if (t2 === null)
            return null;
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.getDefaultCoordinateSequenceFactory = function() {
          return ce.instance();
        }, _e.toMultiLineStringArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toLineStringArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toMultiPointArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toLinearRingArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toPointArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toPolygonArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.createPointFromInternalCoord = function(t2, e3) {
          return e3.getPrecisionModel().makePrecise(t2), e3.getFactory().createPoint(t2);
        }, me.serialVersionUID.get = function() {
          return -6820524753094096e3;
        }, Object.defineProperties(_e, me);
        var ve = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], Ie = function(t2) {
          this.geometryFactory = t2 || new _e();
        };
        Ie.prototype.read = function(t2) {
          var e3, n2 = (e3 = typeof t2 == "string" ? JSON.parse(t2) : t2).type;
          if (!Ee[n2])
            throw new Error("Unknown GeoJSON type: " + e3.type);
          return ve.indexOf(n2) !== -1 ? Ee[n2].apply(this, [e3.coordinates]) : n2 === "GeometryCollection" ? Ee[n2].apply(this, [e3.geometries]) : Ee[n2].apply(this, [e3]);
        }, Ie.prototype.write = function(t2) {
          var e3 = t2.getGeometryType();
          if (!xe[e3])
            throw new Error("Geometry is not supported");
          return xe[e3].apply(this, [t2]);
        };
        var Ee = { Feature: function(t2) {
          var e3 = {};
          for (var n2 in t2)
            e3[n2] = t2[n2];
          if (t2.geometry) {
            var i2 = t2.geometry.type;
            if (!Ee[i2])
              throw new Error("Unknown GeoJSON type: " + t2.type);
            e3.geometry = this.read(t2.geometry);
          }
          return t2.bbox && (e3.bbox = Ee.bbox.apply(this, [t2.bbox])), e3;
        }, FeatureCollection: function(t2) {
          var e3 = {};
          if (t2.features) {
            e3.features = [];
            for (var n2 = 0; n2 < t2.features.length; ++n2)
              e3.features.push(this.read(t2.features[n2]));
          }
          return t2.bbox && (e3.bbox = this.parse.bbox.apply(this, [t2.bbox])), e3;
        }, coordinates: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
            var i2 = t2[n2];
            e3.push(new C(i2[0], i2[1]));
          }
          return e3;
        }, bbox: function(t2) {
          return this.geometryFactory.createLinearRing([new C(t2[0], t2[1]), new C(t2[2], t2[1]), new C(t2[2], t2[3]), new C(t2[0], t2[3]), new C(t2[0], t2[1])]);
        }, Point: function(t2) {
          var e3 = new C(t2[0], t2[1]);
          return this.geometryFactory.createPoint(e3);
        }, MultiPoint: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2)
            e3.push(Ee.Point.apply(this, [t2[n2]]));
          return this.geometryFactory.createMultiPoint(e3);
        }, LineString: function(t2) {
          var e3 = Ee.coordinates.apply(this, [t2]);
          return this.geometryFactory.createLineString(e3);
        }, MultiLineString: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2)
            e3.push(Ee.LineString.apply(this, [t2[n2]]));
          return this.geometryFactory.createMultiLineString(e3);
        }, Polygon: function(t2) {
          for (var e3 = Ee.coordinates.apply(this, [t2[0]]), n2 = this.geometryFactory.createLinearRing(e3), i2 = [], r2 = 1; r2 < t2.length; ++r2) {
            var o2 = t2[r2], s2 = Ee.coordinates.apply(this, [o2]), a2 = this.geometryFactory.createLinearRing(s2);
            i2.push(a2);
          }
          return this.geometryFactory.createPolygon(n2, i2);
        }, MultiPolygon: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
            var i2 = t2[n2];
            e3.push(Ee.Polygon.apply(this, [i2]));
          }
          return this.geometryFactory.createMultiPolygon(e3);
        }, GeometryCollection: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
            var i2 = t2[n2];
            e3.push(this.read(i2));
          }
          return this.geometryFactory.createGeometryCollection(e3);
        } }, xe = { coordinate: function(t2) {
          return [t2.x, t2.y];
        }, Point: function(t2) {
          return { type: "Point", coordinates: xe.coordinate.apply(this, [t2.getCoordinate()]) };
        }, MultiPoint: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = xe.Point.apply(this, [i2]);
            e3.push(r2.coordinates);
          }
          return { type: "MultiPoint", coordinates: e3 };
        }, LineString: function(t2) {
          for (var e3 = [], n2 = t2.getCoordinates(), i2 = 0; i2 < n2.length; ++i2) {
            var r2 = n2[i2];
            e3.push(xe.coordinate.apply(this, [r2]));
          }
          return { type: "LineString", coordinates: e3 };
        }, MultiLineString: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = xe.LineString.apply(this, [i2]);
            e3.push(r2.coordinates);
          }
          return { type: "MultiLineString", coordinates: e3 };
        }, Polygon: function(t2) {
          var e3 = [], n2 = xe.LineString.apply(this, [t2._shell]);
          e3.push(n2.coordinates);
          for (var i2 = 0; i2 < t2._holes.length; ++i2) {
            var r2 = t2._holes[i2], o2 = xe.LineString.apply(this, [r2]);
            e3.push(o2.coordinates);
          }
          return { type: "Polygon", coordinates: e3 };
        }, MultiPolygon: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = xe.Polygon.apply(this, [i2]);
            e3.push(r2.coordinates);
          }
          return { type: "MultiPolygon", coordinates: e3 };
        }, GeometryCollection: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = i2.getGeometryType();
            e3.push(xe[r2].apply(this, [i2]));
          }
          return { type: "GeometryCollection", geometries: e3 };
        } }, Ne = function(t2) {
          this.geometryFactory = t2 || new _e(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new Ie(this.geometryFactory);
        };
        Ne.prototype.read = function(t2) {
          var e3 = this.parser.read(t2);
          return this.precisionModel.getType() === fe.FIXED && this.reducePrecision(e3), e3;
        }, Ne.prototype.reducePrecision = function(t2) {
          var e3, n2;
          if (t2.coordinate)
            this.precisionModel.makePrecise(t2.coordinate);
          else if (t2.points)
            for (e3 = 0, n2 = t2.points.length; e3 < n2; e3++)
              this.precisionModel.makePrecise(t2.points[e3]);
          else if (t2.geometries)
            for (e3 = 0, n2 = t2.geometries.length; e3 < n2; e3++)
              this.reducePrecision(t2.geometries[e3]);
        };
        var Ce = function() {
          this.parser = new Ie(this.geometryFactory);
        };
        Ce.prototype.write = function(t2) {
          return this.parser.write(t2);
        };
        var Se = function() {
        }, Le = { ON: { configurable: true }, LEFT: { configurable: true }, RIGHT: { configurable: true } };
        Se.prototype.interfaces_ = function() {
          return [];
        }, Se.prototype.getClass = function() {
          return Se;
        }, Se.opposite = function(t2) {
          return t2 === Se.LEFT ? Se.RIGHT : t2 === Se.RIGHT ? Se.LEFT : t2;
        }, Le.ON.get = function() {
          return 0;
        }, Le.LEFT.get = function() {
          return 1;
        }, Le.RIGHT.get = function() {
          return 2;
        }, Object.defineProperties(Se, Le), (d.prototype = new Error()).name = "EmptyStackException", (y2.prototype = new xt()).add = function(t2) {
          return this.array_.push(t2), true;
        }, y2.prototype.get = function(t2) {
          if (t2 < 0 || t2 >= this.size())
            throw new Error();
          return this.array_[t2];
        }, y2.prototype.push = function(t2) {
          return this.array_.push(t2), t2;
        }, y2.prototype.pop = function(t2) {
          if (this.array_.length === 0)
            throw new d();
          return this.array_.pop();
        }, y2.prototype.peek = function() {
          if (this.array_.length === 0)
            throw new d();
          return this.array_[this.array_.length - 1];
        }, y2.prototype.empty = function() {
          return this.array_.length === 0;
        }, y2.prototype.isEmpty = function() {
          return this.empty();
        }, y2.prototype.search = function(t2) {
          return this.array_.indexOf(t2);
        }, y2.prototype.size = function() {
          return this.array_.length;
        }, y2.prototype.toArray = function() {
          for (var t2 = [], e3 = 0, n2 = this.array_.length; e3 < n2; e3++)
            t2.push(this.array_[e3]);
          return t2;
        };
        var be = function() {
          this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
        };
        be.prototype.getCoordinate = function() {
          return this._minCoord;
        }, be.prototype.getRightmostSide = function(t2, e3) {
          var n2 = this.getRightmostSideOfSegment(t2, e3);
          return n2 < 0 && (n2 = this.getRightmostSideOfSegment(t2, e3 - 1)), n2 < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t2)), n2;
        }, be.prototype.findRightmostEdgeAtVertex = function() {
          var t2 = this._minDe.getEdge().getCoordinates();
          et.isTrue(this._minIndex > 0 && this._minIndex < t2.length, "rightmost point expected to be interior vertex of edge");
          var e3 = t2[this._minIndex - 1], n2 = t2[this._minIndex + 1], i2 = at.computeOrientation(this._minCoord, n2, e3), r2 = false;
          e3.y < this._minCoord.y && n2.y < this._minCoord.y && i2 === at.COUNTERCLOCKWISE ? r2 = true : e3.y > this._minCoord.y && n2.y > this._minCoord.y && i2 === at.CLOCKWISE && (r2 = true), r2 && (this._minIndex = this._minIndex - 1);
        }, be.prototype.getRightmostSideOfSegment = function(t2, e3) {
          var n2 = t2.getEdge().getCoordinates();
          if (e3 < 0 || e3 + 1 >= n2.length)
            return -1;
          if (n2[e3].y === n2[e3 + 1].y)
            return -1;
          var i2 = Se.LEFT;
          return n2[e3].y < n2[e3 + 1].y && (i2 = Se.RIGHT), i2;
        }, be.prototype.getEdge = function() {
          return this._orientedDe;
        }, be.prototype.checkForRightmostCoordinate = function(t2) {
          for (var e3 = t2.getEdge().getCoordinates(), n2 = 0; n2 < e3.length - 1; n2++)
            (this._minCoord === null || e3[n2].x > this._minCoord.x) && (this._minDe = t2, this._minIndex = n2, this._minCoord = e3[n2]);
        }, be.prototype.findRightmostEdgeAtNode = function() {
          var t2 = this._minDe.getNode().getEdges();
          this._minDe = t2.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
        }, be.prototype.findEdge = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            n2.isForward() && this.checkForRightmostCoordinate(n2);
          }
          et.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), this._minIndex === 0 ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe;
          this.getRightmostSide(this._minDe, this._minIndex) === Se.LEFT && (this._orientedDe = this._minDe.getSym());
        }, be.prototype.interfaces_ = function() {
          return [];
        }, be.prototype.getClass = function() {
          return be;
        };
        var we = function(t2) {
          function e3(n2, i2) {
            t2.call(this, e3.msgWithCoord(n2, i2)), this.pt = i2 ? new C(i2) : null, this.name = "TopologyException";
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.getCoordinate = function() {
            return this.pt;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.msgWithCoord = function(t3, e4) {
            return e4 ? t3 : t3 + " [ " + e4 + " ]";
          }, e3;
        }($), Oe = function() {
          this.array_ = [];
        };
        Oe.prototype.addLast = function(t2) {
          this.array_.push(t2);
        }, Oe.prototype.removeFirst = function() {
          return this.array_.shift();
        }, Oe.prototype.isEmpty = function() {
          return this.array_.length === 0;
        };
        var Te = function() {
          this._finder = null, this._dirEdgeList = new Nt(), this._nodes = new Nt(), this._rightMostCoord = null, this._env = null, this._finder = new be();
        };
        Te.prototype.clearVisitedEdges = function() {
          for (var t2 = this._dirEdgeList.iterator(); t2.hasNext(); ) {
            t2.next().setVisited(false);
          }
        }, Te.prototype.getRightmostCoordinate = function() {
          return this._rightMostCoord;
        }, Te.prototype.computeNodeDepth = function(t2) {
          for (var e3 = null, n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (i2.isVisited() || i2.getSym().isVisited()) {
              e3 = i2;
              break;
            }
          }
          if (e3 === null)
            throw new we("unable to find edge to compute depths at " + t2.getCoordinate());
          t2.getEdges().computeDepths(e3);
          for (var r2 = t2.getEdges().iterator(); r2.hasNext(); ) {
            var o2 = r2.next();
            o2.setVisited(true), this.copySymDepths(o2);
          }
        }, Te.prototype.computeDepth = function(t2) {
          this.clearVisitedEdges();
          var e3 = this._finder.getEdge();
          e3.setEdgeDepths(Se.RIGHT, t2), this.copySymDepths(e3), this.computeDepths(e3);
        }, Te.prototype.create = function(t2) {
          this.addReachable(t2), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
        }, Te.prototype.findResultEdges = function() {
          for (var t2 = this._dirEdgeList.iterator(); t2.hasNext(); ) {
            var e3 = t2.next();
            e3.getDepth(Se.RIGHT) >= 1 && e3.getDepth(Se.LEFT) <= 0 && !e3.isInteriorAreaEdge() && e3.setInResult(true);
          }
        }, Te.prototype.computeDepths = function(t2) {
          var e3 = new Pt(), n2 = new Oe(), i2 = t2.getNode();
          for (n2.addLast(i2), e3.add(i2), t2.setVisited(true); !n2.isEmpty(); ) {
            var r2 = n2.removeFirst();
            e3.add(r2), this.computeNodeDepth(r2);
            for (var o2 = r2.getEdges().iterator(); o2.hasNext(); ) {
              var s2 = o2.next().getSym();
              if (!s2.isVisited()) {
                var a2 = s2.getNode();
                e3.contains(a2) || (n2.addLast(a2), e3.add(a2));
              }
            }
          }
        }, Te.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._rightMostCoord.x < e3._rightMostCoord.x ? -1 : this._rightMostCoord.x > e3._rightMostCoord.x ? 1 : 0;
        }, Te.prototype.getEnvelope = function() {
          if (this._env === null) {
            for (var t2 = new j(), e3 = this._dirEdgeList.iterator(); e3.hasNext(); )
              for (var n2 = e3.next().getEdge().getCoordinates(), i2 = 0; i2 < n2.length - 1; i2++)
                t2.expandToInclude(n2[i2]);
            this._env = t2;
          }
          return this._env;
        }, Te.prototype.addReachable = function(t2) {
          var e3 = new y2();
          for (e3.add(t2); !e3.empty(); ) {
            var n2 = e3.pop();
            this.add(n2, e3);
          }
        }, Te.prototype.copySymDepths = function(t2) {
          var e3 = t2.getSym();
          e3.setDepth(Se.LEFT, t2.getDepth(Se.RIGHT)), e3.setDepth(Se.RIGHT, t2.getDepth(Se.LEFT));
        }, Te.prototype.add = function(t2, e3) {
          t2.setVisited(true), this._nodes.add(t2);
          for (var n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            this._dirEdgeList.add(i2);
            var r2 = i2.getSym().getNode();
            r2.isVisited() || e3.push(r2);
          }
        }, Te.prototype.getNodes = function() {
          return this._nodes;
        }, Te.prototype.getDirectedEdges = function() {
          return this._dirEdgeList;
        }, Te.prototype.interfaces_ = function() {
          return [E];
        }, Te.prototype.getClass = function() {
          return Te;
        };
        var Re = function t2() {
          if (this.location = null, arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var e3 = arguments[0];
              this.init(e3.length);
            } else if (Number.isInteger(arguments[0])) {
              var n2 = arguments[0];
              this.init(1), this.location[Se.ON] = n2;
            } else if (arguments[0] instanceof t2) {
              var i2 = arguments[0];
              if (this.init(i2.location.length), i2 !== null)
                for (var r2 = 0; r2 < this.location.length; r2++)
                  this.location[r2] = i2.location[r2];
            }
          } else if (arguments.length === 3) {
            var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            this.init(3), this.location[Se.ON] = o2, this.location[Se.LEFT] = s2, this.location[Se.RIGHT] = a2;
          }
        };
        Re.prototype.setAllLocations = function(t2) {
          for (var e3 = 0; e3 < this.location.length; e3++)
            this.location[e3] = t2;
        }, Re.prototype.isNull = function() {
          for (var t2 = 0; t2 < this.location.length; t2++)
            if (this.location[t2] !== w.NONE)
              return false;
          return true;
        }, Re.prototype.setAllLocationsIfNull = function(t2) {
          for (var e3 = 0; e3 < this.location.length; e3++)
            this.location[e3] === w.NONE && (this.location[e3] = t2);
        }, Re.prototype.isLine = function() {
          return this.location.length === 1;
        }, Re.prototype.merge = function(t2) {
          if (t2.location.length > this.location.length) {
            var e3 = new Array(3).fill(null);
            e3[Se.ON] = this.location[Se.ON], e3[Se.LEFT] = w.NONE, e3[Se.RIGHT] = w.NONE, this.location = e3;
          }
          for (var n2 = 0; n2 < this.location.length; n2++)
            this.location[n2] === w.NONE && n2 < t2.location.length && (this.location[n2] = t2.location[n2]);
        }, Re.prototype.getLocations = function() {
          return this.location;
        }, Re.prototype.flip = function() {
          if (this.location.length <= 1)
            return null;
          var t2 = this.location[Se.LEFT];
          this.location[Se.LEFT] = this.location[Se.RIGHT], this.location[Se.RIGHT] = t2;
        }, Re.prototype.toString = function() {
          var t2 = new D();
          return this.location.length > 1 && t2.append(w.toLocationSymbol(this.location[Se.LEFT])), t2.append(w.toLocationSymbol(this.location[Se.ON])), this.location.length > 1 && t2.append(w.toLocationSymbol(this.location[Se.RIGHT])), t2.toString();
        }, Re.prototype.setLocations = function(t2, e3, n2) {
          this.location[Se.ON] = t2, this.location[Se.LEFT] = e3, this.location[Se.RIGHT] = n2;
        }, Re.prototype.get = function(t2) {
          return t2 < this.location.length ? this.location[t2] : w.NONE;
        }, Re.prototype.isArea = function() {
          return this.location.length > 1;
        }, Re.prototype.isAnyNull = function() {
          for (var t2 = 0; t2 < this.location.length; t2++)
            if (this.location[t2] === w.NONE)
              return true;
          return false;
        }, Re.prototype.setLocation = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            this.setLocation(Se.ON, t2);
          } else if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            this.location[e3] = n2;
          }
        }, Re.prototype.init = function(t2) {
          this.location = new Array(t2).fill(null), this.setAllLocations(w.NONE);
        }, Re.prototype.isEqualOnSide = function(t2, e3) {
          return this.location[e3] === t2.location[e3];
        }, Re.prototype.allPositionsEqual = function(t2) {
          for (var e3 = 0; e3 < this.location.length; e3++)
            if (this.location[e3] !== t2)
              return false;
          return true;
        }, Re.prototype.interfaces_ = function() {
          return [];
        }, Re.prototype.getClass = function() {
          return Re;
        };
        var Pe = function t2() {
          if (this.elt = new Array(2).fill(null), arguments.length === 1) {
            if (Number.isInteger(arguments[0])) {
              var e3 = arguments[0];
              this.elt[0] = new Re(e3), this.elt[1] = new Re(e3);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.elt[0] = new Re(n2.elt[0]), this.elt[1] = new Re(n2.elt[1]);
            }
          } else if (arguments.length === 2) {
            var i2 = arguments[0], r2 = arguments[1];
            this.elt[0] = new Re(w.NONE), this.elt[1] = new Re(w.NONE), this.elt[i2].setLocation(r2);
          } else if (arguments.length === 3) {
            var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            this.elt[0] = new Re(o2, s2, a2), this.elt[1] = new Re(o2, s2, a2);
          } else if (arguments.length === 4) {
            var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2], p2 = arguments[3];
            this.elt[0] = new Re(w.NONE, w.NONE, w.NONE), this.elt[1] = new Re(w.NONE, w.NONE, w.NONE), this.elt[u2].setLocations(l2, c2, p2);
          }
        };
        Pe.prototype.getGeometryCount = function() {
          var t2 = 0;
          return this.elt[0].isNull() || t2++, this.elt[1].isNull() || t2++, t2;
        }, Pe.prototype.setAllLocations = function(t2, e3) {
          this.elt[t2].setAllLocations(e3);
        }, Pe.prototype.isNull = function(t2) {
          return this.elt[t2].isNull();
        }, Pe.prototype.setAllLocationsIfNull = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            this.setAllLocationsIfNull(0, t2), this.setAllLocationsIfNull(1, t2);
          } else if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            this.elt[e3].setAllLocationsIfNull(n2);
          }
        }, Pe.prototype.isLine = function(t2) {
          return this.elt[t2].isLine();
        }, Pe.prototype.merge = function(t2) {
          for (var e3 = 0; e3 < 2; e3++)
            this.elt[e3] === null && t2.elt[e3] !== null ? this.elt[e3] = new Re(t2.elt[e3]) : this.elt[e3].merge(t2.elt[e3]);
        }, Pe.prototype.flip = function() {
          this.elt[0].flip(), this.elt[1].flip();
        }, Pe.prototype.getLocation = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return this.elt[t2].get(Se.ON);
          }
          if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            return this.elt[e3].get(n2);
          }
        }, Pe.prototype.toString = function() {
          var t2 = new D();
          return this.elt[0] !== null && (t2.append("A:"), t2.append(this.elt[0].toString())), this.elt[1] !== null && (t2.append(" B:"), t2.append(this.elt[1].toString())), t2.toString();
        }, Pe.prototype.isArea = function() {
          if (arguments.length === 0)
            return this.elt[0].isArea() || this.elt[1].isArea();
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return this.elt[t2].isArea();
          }
        }, Pe.prototype.isAnyNull = function(t2) {
          return this.elt[t2].isAnyNull();
        }, Pe.prototype.setLocation = function() {
          if (arguments.length === 2) {
            var t2 = arguments[0], e3 = arguments[1];
            this.elt[t2].setLocation(Se.ON, e3);
          } else if (arguments.length === 3) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this.elt[n2].setLocation(i2, r2);
          }
        }, Pe.prototype.isEqualOnSide = function(t2, e3) {
          return this.elt[0].isEqualOnSide(t2.elt[0], e3) && this.elt[1].isEqualOnSide(t2.elt[1], e3);
        }, Pe.prototype.allPositionsEqual = function(t2, e3) {
          return this.elt[t2].allPositionsEqual(e3);
        }, Pe.prototype.toLine = function(t2) {
          this.elt[t2].isArea() && (this.elt[t2] = new Re(this.elt[t2].location[0]));
        }, Pe.prototype.interfaces_ = function() {
          return [];
        }, Pe.prototype.getClass = function() {
          return Pe;
        }, Pe.toLineLabel = function(t2) {
          for (var e3 = new Pe(w.NONE), n2 = 0; n2 < 2; n2++)
            e3.setLocation(n2, t2.getLocation(n2));
          return e3;
        };
        var De = function() {
          this._startDe = null, this._maxNodeDegree = -1, this._edges = new Nt(), this._pts = new Nt(), this._label = new Pe(w.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new Nt(), this._geometryFactory = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._geometryFactory = e3, this.computePoints(t2), this.computeRing();
        };
        De.prototype.computeRing = function() {
          if (this._ring !== null)
            return null;
          for (var t2 = new Array(this._pts.size()).fill(null), e3 = 0; e3 < this._pts.size(); e3++)
            t2[e3] = this._pts.get(e3);
          this._ring = this._geometryFactory.createLinearRing(t2), this._isHole = at.isCCW(this._ring.getCoordinates());
        }, De.prototype.isIsolated = function() {
          return this._label.getGeometryCount() === 1;
        }, De.prototype.computePoints = function(t2) {
          this._startDe = t2;
          var e3 = t2, n2 = true;
          do {
            if (e3 === null)
              throw new we("Found null DirectedEdge");
            if (e3.getEdgeRing() === this)
              throw new we("Directed Edge visited twice during ring-building at " + e3.getCoordinate());
            this._edges.add(e3);
            var i2 = e3.getLabel();
            et.isTrue(i2.isArea()), this.mergeLabel(i2), this.addPoints(e3.getEdge(), e3.isForward(), n2), n2 = false, this.setEdgeRing(e3, this), e3 = this.getNext(e3);
          } while (e3 !== this._startDe);
        }, De.prototype.getLinearRing = function() {
          return this._ring;
        }, De.prototype.getCoordinate = function(t2) {
          return this._pts.get(t2);
        }, De.prototype.computeMaxNodeDegree = function() {
          this._maxNodeDegree = 0;
          var t2 = this._startDe;
          do {
            var e3 = t2.getNode().getEdges().getOutgoingDegree(this);
            e3 > this._maxNodeDegree && (this._maxNodeDegree = e3), t2 = this.getNext(t2);
          } while (t2 !== this._startDe);
          this._maxNodeDegree *= 2;
        }, De.prototype.addPoints = function(t2, e3, n2) {
          var i2 = t2.getCoordinates();
          if (e3) {
            var r2 = 1;
            n2 && (r2 = 0);
            for (var o2 = r2; o2 < i2.length; o2++)
              this._pts.add(i2[o2]);
          } else {
            var s2 = i2.length - 2;
            n2 && (s2 = i2.length - 1);
            for (var a2 = s2; a2 >= 0; a2--)
              this._pts.add(i2[a2]);
          }
        }, De.prototype.isHole = function() {
          return this._isHole;
        }, De.prototype.setInResult = function() {
          var t2 = this._startDe;
          do {
            t2.getEdge().setInResult(true), t2 = t2.getNext();
          } while (t2 !== this._startDe);
        }, De.prototype.containsPoint = function(t2) {
          var e3 = this.getLinearRing();
          if (!e3.getEnvelopeInternal().contains(t2))
            return false;
          if (!at.isPointInRing(t2, e3.getCoordinates()))
            return false;
          for (var n2 = this._holes.iterator(); n2.hasNext(); ) {
            if (n2.next().containsPoint(t2))
              return false;
          }
          return true;
        }, De.prototype.addHole = function(t2) {
          this._holes.add(t2);
        }, De.prototype.isShell = function() {
          return this._shell === null;
        }, De.prototype.getLabel = function() {
          return this._label;
        }, De.prototype.getEdges = function() {
          return this._edges;
        }, De.prototype.getMaxNodeDegree = function() {
          return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
        }, De.prototype.getShell = function() {
          return this._shell;
        }, De.prototype.mergeLabel = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            this.mergeLabel(t2, 0), this.mergeLabel(t2, 1);
          } else if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1], i2 = e3.getLocation(n2, Se.RIGHT);
            if (i2 === w.NONE)
              return null;
            if (this._label.getLocation(n2) === w.NONE)
              return this._label.setLocation(n2, i2), null;
          }
        }, De.prototype.setShell = function(t2) {
          this._shell = t2, t2 !== null && t2.addHole(this);
        }, De.prototype.toPolygon = function(t2) {
          for (var e3 = new Array(this._holes.size()).fill(null), n2 = 0; n2 < this._holes.size(); n2++)
            e3[n2] = this._holes.get(n2).getLinearRing();
          return t2.createPolygon(this.getLinearRing(), e3);
        }, De.prototype.interfaces_ = function() {
          return [];
        }, De.prototype.getClass = function() {
          return De;
        };
        var Me = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            t2.call(this, e4, n2);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.setEdgeRing = function(t3, e4) {
            t3.setMinEdgeRing(e4);
          }, e3.prototype.getNext = function(t3) {
            return t3.getNextMin();
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(De), Ae = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            t2.call(this, e4, n2);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.buildMinimalRings = function() {
            var t3 = new Nt(), e4 = this._startDe;
            do {
              if (e4.getMinEdgeRing() === null) {
                var n2 = new Me(e4, this._geometryFactory);
                t3.add(n2);
              }
              e4 = e4.getNext();
            } while (e4 !== this._startDe);
            return t3;
          }, e3.prototype.setEdgeRing = function(t3, e4) {
            t3.setEdgeRing(e4);
          }, e3.prototype.linkDirectedEdgesForMinimalEdgeRings = function() {
            var t3 = this._startDe;
            do {
              t3.getNode().getEdges().linkMinimalDirectedEdges(this), t3 = t3.getNext();
            } while (t3 !== this._startDe);
          }, e3.prototype.getNext = function(t3) {
            return t3.getNext();
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(De), Fe = function() {
          if (this._label = null, this._isInResult = false, this._isCovered = false, this._isCoveredSet = false, this._isVisited = false, arguments.length === 0)
            ;
          else if (arguments.length === 1) {
            var t2 = arguments[0];
            this._label = t2;
          }
        };
        Fe.prototype.setVisited = function(t2) {
          this._isVisited = t2;
        }, Fe.prototype.setInResult = function(t2) {
          this._isInResult = t2;
        }, Fe.prototype.isCovered = function() {
          return this._isCovered;
        }, Fe.prototype.isCoveredSet = function() {
          return this._isCoveredSet;
        }, Fe.prototype.setLabel = function(t2) {
          this._label = t2;
        }, Fe.prototype.getLabel = function() {
          return this._label;
        }, Fe.prototype.setCovered = function(t2) {
          this._isCovered = t2, this._isCoveredSet = true;
        }, Fe.prototype.updateIM = function(t2) {
          et.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t2);
        }, Fe.prototype.isInResult = function() {
          return this._isInResult;
        }, Fe.prototype.isVisited = function() {
          return this._isVisited;
        }, Fe.prototype.interfaces_ = function() {
          return [];
        }, Fe.prototype.getClass = function() {
          return Fe;
        };
        var Ge = function(t2) {
          function e3() {
            t2.call(this), this._coord = null, this._edges = null;
            var e4 = arguments[0], n2 = arguments[1];
            this._coord = e4, this._edges = n2, this._label = new Pe(0, w.NONE);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.isIncidentEdgeInResult = function() {
            for (var t3 = this.getEdges().getEdges().iterator(); t3.hasNext(); ) {
              if (t3.next().getEdge().isInResult())
                return true;
            }
            return false;
          }, e3.prototype.isIsolated = function() {
            return this._label.getGeometryCount() === 1;
          }, e3.prototype.getCoordinate = function() {
            return this._coord;
          }, e3.prototype.print = function(t3) {
            t3.println("node " + this._coord + " lbl: " + this._label);
          }, e3.prototype.computeIM = function(t3) {
          }, e3.prototype.computeMergedLocation = function(t3, e4) {
            var n2 = w.NONE;
            if (n2 = this._label.getLocation(e4), !t3.isNull(e4)) {
              var i2 = t3.getLocation(e4);
              n2 !== w.BOUNDARY && (n2 = i2);
            }
            return n2;
          }, e3.prototype.setLabel = function() {
            if (arguments.length !== 2)
              return t2.prototype.setLabel.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1];
            this._label === null ? this._label = new Pe(e4, n2) : this._label.setLocation(e4, n2);
          }, e3.prototype.getEdges = function() {
            return this._edges;
          }, e3.prototype.mergeLabel = function() {
            if (arguments[0] instanceof e3) {
              var t3 = arguments[0];
              this.mergeLabel(t3._label);
            } else if (arguments[0] instanceof Pe)
              for (var n2 = arguments[0], i2 = 0; i2 < 2; i2++) {
                var r2 = this.computeMergedLocation(n2, i2);
                this._label.getLocation(i2) === w.NONE && this._label.setLocation(i2, r2);
              }
          }, e3.prototype.add = function(t3) {
            this._edges.insert(t3), t3.setNode(this);
          }, e3.prototype.setLabelBoundary = function(t3) {
            if (this._label === null)
              return null;
            var e4 = w.NONE;
            this._label !== null && (e4 = this._label.getLocation(t3));
            var n2 = null;
            switch (e4) {
              case w.BOUNDARY:
                n2 = w.INTERIOR;
                break;
              case w.INTERIOR:
              default:
                n2 = w.BOUNDARY;
            }
            this._label.setLocation(t3, n2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Fe), qe = function() {
          this.nodeMap = new p(), this.nodeFact = null;
          var t2 = arguments[0];
          this.nodeFact = t2;
        };
        qe.prototype.find = function(t2) {
          return this.nodeMap.get(t2);
        }, qe.prototype.addNode = function() {
          if (arguments[0] instanceof C) {
            var t2 = arguments[0], e3 = this.nodeMap.get(t2);
            return e3 === null && (e3 = this.nodeFact.createNode(t2), this.nodeMap.put(t2, e3)), e3;
          }
          if (arguments[0] instanceof Ge) {
            var n2 = arguments[0], i2 = this.nodeMap.get(n2.getCoordinate());
            return i2 === null ? (this.nodeMap.put(n2.getCoordinate(), n2), n2) : (i2.mergeLabel(n2), i2);
          }
        }, qe.prototype.print = function(t2) {
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, qe.prototype.iterator = function() {
          return this.nodeMap.values().iterator();
        }, qe.prototype.values = function() {
          return this.nodeMap.values();
        }, qe.prototype.getBoundaryNodes = function(t2) {
          for (var e3 = new Nt(), n2 = this.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            i2.getLabel().getLocation(t2) === w.BOUNDARY && e3.add(i2);
          }
          return e3;
        }, qe.prototype.add = function(t2) {
          var e3 = t2.getCoordinate();
          this.addNode(e3).add(t2);
        }, qe.prototype.interfaces_ = function() {
          return [];
        }, qe.prototype.getClass = function() {
          return qe;
        };
        var Be = function() {
        }, Ve = { NE: { configurable: true }, NW: { configurable: true }, SW: { configurable: true }, SE: { configurable: true } };
        Be.prototype.interfaces_ = function() {
          return [];
        }, Be.prototype.getClass = function() {
          return Be;
        }, Be.isNorthern = function(t2) {
          return t2 === Be.NE || t2 === Be.NW;
        }, Be.isOpposite = function(t2, e3) {
          if (t2 === e3)
            return false;
          return (t2 - e3 + 4) % 4 === 2;
        }, Be.commonHalfPlane = function(t2, e3) {
          if (t2 === e3)
            return t2;
          if ((t2 - e3 + 4) % 4 === 2)
            return -1;
          var n2 = t2 < e3 ? t2 : e3;
          return n2 === 0 && (t2 > e3 ? t2 : e3) === 3 ? 3 : n2;
        }, Be.isInHalfPlane = function(t2, e3) {
          return e3 === Be.SE ? t2 === Be.SE || t2 === Be.SW : t2 === e3 || t2 === e3 + 1;
        }, Be.quadrant = function() {
          if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var t2 = arguments[0], e3 = arguments[1];
            if (t2 === 0 && e3 === 0)
              throw new m("Cannot compute the quadrant for point ( " + t2 + ", " + e3 + " )");
            return t2 >= 0 ? e3 >= 0 ? Be.NE : Be.SE : e3 >= 0 ? Be.NW : Be.SW;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof C) {
            var n2 = arguments[0], i2 = arguments[1];
            if (i2.x === n2.x && i2.y === n2.y)
              throw new m("Cannot compute the quadrant for two identical points " + n2);
            return i2.x >= n2.x ? i2.y >= n2.y ? Be.NE : Be.SE : i2.y >= n2.y ? Be.NW : Be.SW;
          }
        }, Ve.NE.get = function() {
          return 0;
        }, Ve.NW.get = function() {
          return 1;
        }, Ve.SW.get = function() {
          return 2;
        }, Ve.SE.get = function() {
          return 3;
        }, Object.defineProperties(Be, Ve);
        var Ue = function() {
          if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, arguments.length === 1) {
            var t2 = arguments[0];
            this._edge = t2;
          } else if (arguments.length === 3) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            this._edge = e3, this.init(n2, i2), this._label = null;
          } else if (arguments.length === 4) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
            this._edge = r2, this.init(o2, s2), this._label = a2;
          }
        };
        Ue.prototype.compareDirection = function(t2) {
          return this._dx === t2._dx && this._dy === t2._dy ? 0 : this._quadrant > t2._quadrant ? 1 : this._quadrant < t2._quadrant ? -1 : at.computeOrientation(t2._p0, t2._p1, this._p1);
        }, Ue.prototype.getDy = function() {
          return this._dy;
        }, Ue.prototype.getCoordinate = function() {
          return this._p0;
        }, Ue.prototype.setNode = function(t2) {
          this._node = t2;
        }, Ue.prototype.print = function(t2) {
          var e3 = Math.atan2(this._dy, this._dx), n2 = this.getClass().getName(), i2 = n2.lastIndexOf("."), r2 = n2.substring(i2 + 1);
          t2.print("  " + r2 + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e3 + "   " + this._label);
        }, Ue.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.compareDirection(e3);
        }, Ue.prototype.getDirectedCoordinate = function() {
          return this._p1;
        }, Ue.prototype.getDx = function() {
          return this._dx;
        }, Ue.prototype.getLabel = function() {
          return this._label;
        }, Ue.prototype.getEdge = function() {
          return this._edge;
        }, Ue.prototype.getQuadrant = function() {
          return this._quadrant;
        }, Ue.prototype.getNode = function() {
          return this._node;
        }, Ue.prototype.toString = function() {
          var t2 = Math.atan2(this._dy, this._dx), e3 = this.getClass().getName(), n2 = e3.lastIndexOf(".");
          return "  " + e3.substring(n2 + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t2 + "   " + this._label;
        }, Ue.prototype.computeLabel = function(t2) {
        }, Ue.prototype.init = function(t2, e3) {
          this._p0 = t2, this._p1 = e3, this._dx = e3.x - t2.x, this._dy = e3.y - t2.y, this._quadrant = Be.quadrant(this._dx, this._dy), et.isTrue(!(this._dx === 0 && this._dy === 0), "EdgeEnd with identical endpoints found");
        }, Ue.prototype.interfaces_ = function() {
          return [E];
        }, Ue.prototype.getClass = function() {
          return Ue;
        };
        var ze = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            if (t2.call(this, e4), this._isForward = null, this._isInResult = false, this._isVisited = false, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999], this._isForward = n2, n2)
              this.init(e4.getCoordinate(0), e4.getCoordinate(1));
            else {
              var i2 = e4.getNumPoints() - 1;
              this.init(e4.getCoordinate(i2), e4.getCoordinate(i2 - 1));
            }
            this.computeDirectedLabel();
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.getNextMin = function() {
            return this._nextMin;
          }, e3.prototype.getDepth = function(t3) {
            return this._depth[t3];
          }, e3.prototype.setVisited = function(t3) {
            this._isVisited = t3;
          }, e3.prototype.computeDirectedLabel = function() {
            this._label = new Pe(this._edge.getLabel()), this._isForward || this._label.flip();
          }, e3.prototype.getNext = function() {
            return this._next;
          }, e3.prototype.setDepth = function(t3, e4) {
            if (this._depth[t3] !== -999 && this._depth[t3] !== e4)
              throw new we("assigned depths do not match", this.getCoordinate());
            this._depth[t3] = e4;
          }, e3.prototype.isInteriorAreaEdge = function() {
            for (var t3 = true, e4 = 0; e4 < 2; e4++)
              this._label.isArea(e4) && this._label.getLocation(e4, Se.LEFT) === w.INTERIOR && this._label.getLocation(e4, Se.RIGHT) === w.INTERIOR || (t3 = false);
            return t3;
          }, e3.prototype.setNextMin = function(t3) {
            this._nextMin = t3;
          }, e3.prototype.print = function(e4) {
            t2.prototype.print.call(this, e4), e4.print(" " + this._depth[Se.LEFT] + "/" + this._depth[Se.RIGHT]), e4.print(" (" + this.getDepthDelta() + ")"), this._isInResult && e4.print(" inResult");
          }, e3.prototype.setMinEdgeRing = function(t3) {
            this._minEdgeRing = t3;
          }, e3.prototype.isLineEdge = function() {
            var t3 = this._label.isLine(0) || this._label.isLine(1), e4 = !this._label.isArea(0) || this._label.allPositionsEqual(0, w.EXTERIOR), n2 = !this._label.isArea(1) || this._label.allPositionsEqual(1, w.EXTERIOR);
            return t3 && e4 && n2;
          }, e3.prototype.setEdgeRing = function(t3) {
            this._edgeRing = t3;
          }, e3.prototype.getMinEdgeRing = function() {
            return this._minEdgeRing;
          }, e3.prototype.getDepthDelta = function() {
            var t3 = this._edge.getDepthDelta();
            return this._isForward || (t3 = -t3), t3;
          }, e3.prototype.setInResult = function(t3) {
            this._isInResult = t3;
          }, e3.prototype.getSym = function() {
            return this._sym;
          }, e3.prototype.isForward = function() {
            return this._isForward;
          }, e3.prototype.getEdge = function() {
            return this._edge;
          }, e3.prototype.printEdge = function(t3) {
            this.print(t3), t3.print(" "), this._isForward ? this._edge.print(t3) : this._edge.printReverse(t3);
          }, e3.prototype.setSym = function(t3) {
            this._sym = t3;
          }, e3.prototype.setVisitedEdge = function(t3) {
            this.setVisited(t3), this._sym.setVisited(t3);
          }, e3.prototype.setEdgeDepths = function(t3, e4) {
            var n2 = this.getEdge().getDepthDelta();
            this._isForward || (n2 = -n2);
            var i2 = 1;
            t3 === Se.LEFT && (i2 = -1);
            var r2 = Se.opposite(t3), o2 = e4 + n2 * i2;
            this.setDepth(t3, e4), this.setDepth(r2, o2);
          }, e3.prototype.getEdgeRing = function() {
            return this._edgeRing;
          }, e3.prototype.isInResult = function() {
            return this._isInResult;
          }, e3.prototype.setNext = function(t3) {
            this._next = t3;
          }, e3.prototype.isVisited = function() {
            return this._isVisited;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.depthFactor = function(t3, e4) {
            return t3 === w.EXTERIOR && e4 === w.INTERIOR ? 1 : t3 === w.INTERIOR && e4 === w.EXTERIOR ? -1 : 0;
          }, e3;
        }(Ue), Xe = function() {
        };
        Xe.prototype.createNode = function(t2) {
          return new Ge(t2, null);
        }, Xe.prototype.interfaces_ = function() {
          return [];
        }, Xe.prototype.getClass = function() {
          return Xe;
        };
        var Ye = function() {
          if (this._edges = new Nt(), this._nodes = null, this._edgeEndList = new Nt(), arguments.length === 0)
            this._nodes = new qe(new Xe());
          else if (arguments.length === 1) {
            var t2 = arguments[0];
            this._nodes = new qe(t2);
          }
        };
        Ye.prototype.printEdges = function(t2) {
          t2.println("Edges:");
          for (var e3 = 0; e3 < this._edges.size(); e3++) {
            t2.println("edge " + e3 + ":");
            var n2 = this._edges.get(e3);
            n2.print(t2), n2.eiList.print(t2);
          }
        }, Ye.prototype.find = function(t2) {
          return this._nodes.find(t2);
        }, Ye.prototype.addNode = function() {
          if (arguments[0] instanceof Ge) {
            var t2 = arguments[0];
            return this._nodes.addNode(t2);
          }
          if (arguments[0] instanceof C) {
            var e3 = arguments[0];
            return this._nodes.addNode(e3);
          }
        }, Ye.prototype.getNodeIterator = function() {
          return this._nodes.iterator();
        }, Ye.prototype.linkResultDirectedEdges = function() {
          for (var t2 = this._nodes.iterator(); t2.hasNext(); ) {
            t2.next().getEdges().linkResultDirectedEdges();
          }
        }, Ye.prototype.debugPrintln = function(t2) {
          Y.out.println(t2);
        }, Ye.prototype.isBoundaryNode = function(t2, e3) {
          var n2 = this._nodes.find(e3);
          if (n2 === null)
            return false;
          var i2 = n2.getLabel();
          return i2 !== null && i2.getLocation(t2) === w.BOUNDARY;
        }, Ye.prototype.linkAllDirectedEdges = function() {
          for (var t2 = this._nodes.iterator(); t2.hasNext(); ) {
            t2.next().getEdges().linkAllDirectedEdges();
          }
        }, Ye.prototype.matchInSameDirection = function(t2, e3, n2, i2) {
          return !!t2.equals(n2) && (at.computeOrientation(t2, e3, i2) === at.COLLINEAR && Be.quadrant(t2, e3) === Be.quadrant(n2, i2));
        }, Ye.prototype.getEdgeEnds = function() {
          return this._edgeEndList;
        }, Ye.prototype.debugPrint = function(t2) {
          Y.out.print(t2);
        }, Ye.prototype.getEdgeIterator = function() {
          return this._edges.iterator();
        }, Ye.prototype.findEdgeInSameDirection = function(t2, e3) {
          for (var n2 = 0; n2 < this._edges.size(); n2++) {
            var i2 = this._edges.get(n2), r2 = i2.getCoordinates();
            if (this.matchInSameDirection(t2, e3, r2[0], r2[1]))
              return i2;
            if (this.matchInSameDirection(t2, e3, r2[r2.length - 1], r2[r2.length - 2]))
              return i2;
          }
          return null;
        }, Ye.prototype.insertEdge = function(t2) {
          this._edges.add(t2);
        }, Ye.prototype.findEdgeEnd = function(t2) {
          for (var e3 = this.getEdgeEnds().iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            if (n2.getEdge() === t2)
              return n2;
          }
          return null;
        }, Ye.prototype.addEdges = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this._edges.add(n2);
            var i2 = new ze(n2, true), r2 = new ze(n2, false);
            i2.setSym(r2), r2.setSym(i2), this.add(i2), this.add(r2);
          }
        }, Ye.prototype.add = function(t2) {
          this._nodes.add(t2), this._edgeEndList.add(t2);
        }, Ye.prototype.getNodes = function() {
          return this._nodes.values();
        }, Ye.prototype.findEdge = function(t2, e3) {
          for (var n2 = 0; n2 < this._edges.size(); n2++) {
            var i2 = this._edges.get(n2), r2 = i2.getCoordinates();
            if (t2.equals(r2[0]) && e3.equals(r2[1]))
              return i2;
          }
          return null;
        }, Ye.prototype.interfaces_ = function() {
          return [];
        }, Ye.prototype.getClass = function() {
          return Ye;
        }, Ye.linkResultDirectedEdges = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            e3.next().getEdges().linkResultDirectedEdges();
          }
        };
        var ke = function() {
          this._geometryFactory = null, this._shellList = new Nt();
          var t2 = arguments[0];
          this._geometryFactory = t2;
        };
        ke.prototype.sortShellsAndHoles = function(t2, e3, n2) {
          for (var i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2.isHole() ? n2.add(r2) : e3.add(r2);
          }
        }, ke.prototype.computePolygons = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().toPolygon(this._geometryFactory);
            e3.add(i2);
          }
          return e3;
        }, ke.prototype.placeFreeHoles = function(t2, e3) {
          for (var n2 = e3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (i2.getShell() === null) {
              var r2 = this.findEdgeRingContaining(i2, t2);
              if (r2 === null)
                throw new we("unable to assign hole to a shell", i2.getCoordinate(0));
              i2.setShell(r2);
            }
          }
        }, ke.prototype.buildMinimalEdgeRings = function(t2, e3, n2) {
          for (var i2 = new Nt(), r2 = t2.iterator(); r2.hasNext(); ) {
            var o2 = r2.next();
            if (o2.getMaxNodeDegree() > 2) {
              o2.linkDirectedEdgesForMinimalEdgeRings();
              var s2 = o2.buildMinimalRings(), a2 = this.findShell(s2);
              a2 !== null ? (this.placePolygonHoles(a2, s2), e3.add(a2)) : n2.addAll(s2);
            } else
              i2.add(o2);
          }
          return i2;
        }, ke.prototype.containsPoint = function(t2) {
          for (var e3 = this._shellList.iterator(); e3.hasNext(); ) {
            if (e3.next().containsPoint(t2))
              return true;
          }
          return false;
        }, ke.prototype.buildMaximalEdgeRings = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (i2.isInResult() && i2.getLabel().isArea() && i2.getEdgeRing() === null) {
              var r2 = new Ae(i2, this._geometryFactory);
              e3.add(r2), r2.setInResult();
            }
          }
          return e3;
        }, ke.prototype.placePolygonHoles = function(t2, e3) {
          for (var n2 = e3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            i2.isHole() && i2.setShell(t2);
          }
        }, ke.prototype.getPolygons = function() {
          return this.computePolygons(this._shellList);
        }, ke.prototype.findEdgeRingContaining = function(t2, e3) {
          for (var n2 = t2.getLinearRing(), i2 = n2.getEnvelopeInternal(), r2 = n2.getCoordinateN(0), o2 = null, s2 = null, a2 = e3.iterator(); a2.hasNext(); ) {
            var u2 = a2.next(), l2 = u2.getLinearRing(), c2 = l2.getEnvelopeInternal();
            o2 !== null && (s2 = o2.getLinearRing().getEnvelopeInternal());
            var p2 = false;
            c2.contains(i2) && at.isPointInRing(r2, l2.getCoordinates()) && (p2 = true), p2 && (o2 === null || s2.contains(c2)) && (o2 = u2);
          }
          return o2;
        }, ke.prototype.findShell = function(t2) {
          for (var e3 = 0, n2 = null, i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2.isHole() || (n2 = r2, e3++);
          }
          return et.isTrue(e3 <= 1, "found two shells in MinimalEdgeRing list"), n2;
        }, ke.prototype.add = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            this.add(t2.getEdgeEnds(), t2.getNodes());
          } else if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            Ye.linkResultDirectedEdges(n2);
            var i2 = this.buildMaximalEdgeRings(e3), r2 = new Nt(), o2 = this.buildMinimalEdgeRings(i2, this._shellList, r2);
            this.sortShellsAndHoles(o2, this._shellList, r2), this.placeFreeHoles(this._shellList, r2);
          }
        }, ke.prototype.interfaces_ = function() {
          return [];
        }, ke.prototype.getClass = function() {
          return ke;
        };
        var je = function() {
        };
        je.prototype.getBounds = function() {
        }, je.prototype.interfaces_ = function() {
          return [];
        }, je.prototype.getClass = function() {
          return je;
        };
        var He = function() {
          this._bounds = null, this._item = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._bounds = t2, this._item = e3;
        };
        He.prototype.getItem = function() {
          return this._item;
        }, He.prototype.getBounds = function() {
          return this._bounds;
        }, He.prototype.interfaces_ = function() {
          return [je, e];
        }, He.prototype.getClass = function() {
          return He;
        };
        var We = function() {
          this._size = null, this._items = null, this._size = 0, this._items = new Nt(), this._items.add(null);
        };
        We.prototype.poll = function() {
          if (this.isEmpty())
            return null;
          var t2 = this._items.get(1);
          return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t2;
        }, We.prototype.size = function() {
          return this._size;
        }, We.prototype.reorder = function(t2) {
          for (var e3 = null, n2 = this._items.get(t2); 2 * t2 <= this._size && ((e3 = 2 * t2) !== this._size && this._items.get(e3 + 1).compareTo(this._items.get(e3)) < 0 && e3++, this._items.get(e3).compareTo(n2) < 0); t2 = e3)
            this._items.set(t2, this._items.get(e3));
          this._items.set(t2, n2);
        }, We.prototype.clear = function() {
          this._size = 0, this._items.clear();
        }, We.prototype.isEmpty = function() {
          return this._size === 0;
        }, We.prototype.add = function(t2) {
          this._items.add(null), this._size += 1;
          var e3 = this._size;
          for (this._items.set(0, t2); t2.compareTo(this._items.get(Math.trunc(e3 / 2))) < 0; e3 /= 2)
            this._items.set(e3, this._items.get(Math.trunc(e3 / 2)));
          this._items.set(e3, t2);
        }, We.prototype.interfaces_ = function() {
          return [];
        }, We.prototype.getClass = function() {
          return We;
        };
        var Ke = function() {
        };
        Ke.prototype.visitItem = function(t2) {
        }, Ke.prototype.interfaces_ = function() {
          return [];
        }, Ke.prototype.getClass = function() {
          return Ke;
        };
        var Je = function() {
        };
        Je.prototype.insert = function(t2, e3) {
        }, Je.prototype.remove = function(t2, e3) {
        }, Je.prototype.query = function() {
        }, Je.prototype.interfaces_ = function() {
          return [];
        }, Je.prototype.getClass = function() {
          return Je;
        };
        var Qe = function() {
          if (this._childBoundables = new Nt(), this._bounds = null, this._level = null, arguments.length === 0)
            ;
          else if (arguments.length === 1) {
            var t2 = arguments[0];
            this._level = t2;
          }
        }, Ze = { serialVersionUID: { configurable: true } };
        Qe.prototype.getLevel = function() {
          return this._level;
        }, Qe.prototype.size = function() {
          return this._childBoundables.size();
        }, Qe.prototype.getChildBoundables = function() {
          return this._childBoundables;
        }, Qe.prototype.addChildBoundable = function(t2) {
          et.isTrue(this._bounds === null), this._childBoundables.add(t2);
        }, Qe.prototype.isEmpty = function() {
          return this._childBoundables.isEmpty();
        }, Qe.prototype.getBounds = function() {
          return this._bounds === null && (this._bounds = this.computeBounds()), this._bounds;
        }, Qe.prototype.interfaces_ = function() {
          return [je, e];
        }, Qe.prototype.getClass = function() {
          return Qe;
        }, Ze.serialVersionUID.get = function() {
          return 6493722185909574e3;
        }, Object.defineProperties(Qe, Ze);
        var $e = function() {
        };
        $e.reverseOrder = function() {
          return { compare: function(t2, e3) {
            return e3.compareTo(t2);
          } };
        }, $e.min = function(t2) {
          return $e.sort(t2), t2.get(0);
        }, $e.sort = function(t2, e3) {
          var n2 = t2.toArray();
          e3 ? Gt.sort(n2, e3) : Gt.sort(n2);
          for (var i2 = t2.iterator(), r2 = 0, o2 = n2.length; r2 < o2; r2++)
            i2.next(), i2.set(n2[r2]);
        }, $e.singletonList = function(t2) {
          var e3 = new Nt();
          return e3.add(t2), e3;
        };
        var tn = function() {
          this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._boundable1 = t2, this._boundable2 = e3, this._itemDistance = n2, this._distance = this.distance();
        };
        tn.prototype.expandToQueue = function(t2, e3) {
          var n2 = tn.isComposite(this._boundable1), i2 = tn.isComposite(this._boundable2);
          if (n2 && i2)
            return tn.area(this._boundable1) > tn.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, t2, e3), null) : (this.expand(this._boundable2, this._boundable1, t2, e3), null);
          if (n2)
            return this.expand(this._boundable1, this._boundable2, t2, e3), null;
          if (i2)
            return this.expand(this._boundable2, this._boundable1, t2, e3), null;
          throw new m("neither boundable is composite");
        }, tn.prototype.isLeaves = function() {
          return !(tn.isComposite(this._boundable1) || tn.isComposite(this._boundable2));
        }, tn.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._distance < e3._distance ? -1 : this._distance > e3._distance ? 1 : 0;
        }, tn.prototype.expand = function(t2, e3, n2, i2) {
          for (var r2 = t2.getChildBoundables().iterator(); r2.hasNext(); ) {
            var o2 = r2.next(), s2 = new tn(o2, e3, this._itemDistance);
            s2.getDistance() < i2 && n2.add(s2);
          }
        }, tn.prototype.getBoundable = function(t2) {
          return t2 === 0 ? this._boundable1 : this._boundable2;
        }, tn.prototype.getDistance = function() {
          return this._distance;
        }, tn.prototype.distance = function() {
          return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
        }, tn.prototype.interfaces_ = function() {
          return [E];
        }, tn.prototype.getClass = function() {
          return tn;
        }, tn.area = function(t2) {
          return t2.getBounds().getArea();
        }, tn.isComposite = function(t2) {
          return t2 instanceof Qe;
        };
        var en = function t2() {
          if (this._root = null, this._built = false, this._itemBoundables = new Nt(), this._nodeCapacity = null, arguments.length === 0) {
            var e3 = t2.DEFAULT_NODE_CAPACITY;
            this._nodeCapacity = e3;
          } else if (arguments.length === 1) {
            var n2 = arguments[0];
            et.isTrue(n2 > 1, "Node capacity must be greater than 1"), this._nodeCapacity = n2;
          }
        }, nn = { IntersectsOp: { configurable: true }, serialVersionUID: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
        en.prototype.getNodeCapacity = function() {
          return this._nodeCapacity;
        }, en.prototype.lastNode = function(t2) {
          return t2.get(t2.size() - 1);
        }, en.prototype.size = function() {
          if (arguments.length === 0)
            return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
          if (arguments.length === 1) {
            for (var t2 = 0, e3 = arguments[0].getChildBoundables().iterator(); e3.hasNext(); ) {
              var n2 = e3.next();
              n2 instanceof Qe ? t2 += this.size(n2) : n2 instanceof He && (t2 += 1);
            }
            return t2;
          }
        }, en.prototype.removeItem = function(t2, e3) {
          for (var n2 = null, i2 = t2.getChildBoundables().iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2 instanceof He && r2.getItem() === e3 && (n2 = r2);
          }
          return n2 !== null && (t2.getChildBoundables().remove(n2), true);
        }, en.prototype.itemsTree = function() {
          if (arguments.length === 0) {
            this.build();
            var t2 = this.itemsTree(this._root);
            return t2 === null ? new Nt() : t2;
          }
          if (arguments.length === 1) {
            for (var e3 = arguments[0], n2 = new Nt(), i2 = e3.getChildBoundables().iterator(); i2.hasNext(); ) {
              var r2 = i2.next();
              if (r2 instanceof Qe) {
                var o2 = this.itemsTree(r2);
                o2 !== null && n2.add(o2);
              } else
                r2 instanceof He ? n2.add(r2.getItem()) : et.shouldNeverReachHere();
            }
            return n2.size() <= 0 ? null : n2;
          }
        }, en.prototype.insert = function(t2, e3) {
          et.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new He(t2, e3));
        }, en.prototype.boundablesAtLevel = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0], e3 = new Nt();
            return this.boundablesAtLevel(t2, this._root, e3), e3;
          }
          if (arguments.length === 3) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            if (et.isTrue(n2 > -2), i2.getLevel() === n2)
              return r2.add(i2), null;
            for (var o2 = i2.getChildBoundables().iterator(); o2.hasNext(); ) {
              var s2 = o2.next();
              s2 instanceof Qe ? this.boundablesAtLevel(n2, s2, r2) : (et.isTrue(s2 instanceof He), n2 === -1 && r2.add(s2));
            }
            return null;
          }
        }, en.prototype.query = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            this.build();
            var e3 = new Nt();
            return this.isEmpty() ? e3 : (this.getIntersectsOp().intersects(this._root.getBounds(), t2) && this.query(t2, this._root, e3), e3);
          }
          if (arguments.length === 2) {
            var n2 = arguments[0], i2 = arguments[1];
            if (this.build(), this.isEmpty())
              return null;
            this.getIntersectsOp().intersects(this._root.getBounds(), n2) && this.query(n2, this._root, i2);
          } else if (arguments.length === 3) {
            if (T(arguments[2], Ke) && arguments[0] instanceof Object && arguments[1] instanceof Qe)
              for (var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = o2.getChildBoundables(), u2 = 0; u2 < a2.size(); u2++) {
                var l2 = a2.get(u2);
                this.getIntersectsOp().intersects(l2.getBounds(), r2) && (l2 instanceof Qe ? this.query(r2, l2, s2) : l2 instanceof He ? s2.visitItem(l2.getItem()) : et.shouldNeverReachHere());
              }
            else if (T(arguments[2], xt) && arguments[0] instanceof Object && arguments[1] instanceof Qe)
              for (var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = p2.getChildBoundables(), g2 = 0; g2 < f2.size(); g2++) {
                var d2 = f2.get(g2);
                this.getIntersectsOp().intersects(d2.getBounds(), c2) && (d2 instanceof Qe ? this.query(c2, d2, h2) : d2 instanceof He ? h2.add(d2.getItem()) : et.shouldNeverReachHere());
              }
          }
        }, en.prototype.build = function() {
          if (this._built)
            return null;
          this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = true;
        }, en.prototype.getRoot = function() {
          return this.build(), this._root;
        }, en.prototype.remove = function() {
          if (arguments.length === 2) {
            var t2 = arguments[0], e3 = arguments[1];
            return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t2) && this.remove(t2, this._root, e3);
          }
          if (arguments.length === 3) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = this.removeItem(i2, r2);
            if (o2)
              return true;
            for (var s2 = null, a2 = i2.getChildBoundables().iterator(); a2.hasNext(); ) {
              var u2 = a2.next();
              if (this.getIntersectsOp().intersects(u2.getBounds(), n2) && (u2 instanceof Qe && (o2 = this.remove(n2, u2, r2)))) {
                s2 = u2;
                break;
              }
            }
            return s2 !== null && s2.getChildBoundables().isEmpty() && i2.getChildBoundables().remove(s2), o2;
          }
        }, en.prototype.createHigherLevels = function(t2, e3) {
          et.isTrue(!t2.isEmpty());
          var n2 = this.createParentBoundables(t2, e3 + 1);
          return n2.size() === 1 ? n2.get(0) : this.createHigherLevels(n2, e3 + 1);
        }, en.prototype.depth = function() {
          if (arguments.length === 0)
            return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
          if (arguments.length === 1) {
            for (var t2 = 0, e3 = arguments[0].getChildBoundables().iterator(); e3.hasNext(); ) {
              var n2 = e3.next();
              if (n2 instanceof Qe) {
                var i2 = this.depth(n2);
                i2 > t2 && (t2 = i2);
              }
            }
            return t2 + 1;
          }
        }, en.prototype.createParentBoundables = function(t2, e3) {
          et.isTrue(!t2.isEmpty());
          var n2 = new Nt();
          n2.add(this.createNode(e3));
          var i2 = new Nt(t2);
          $e.sort(i2, this.getComparator());
          for (var r2 = i2.iterator(); r2.hasNext(); ) {
            var o2 = r2.next();
            this.lastNode(n2).getChildBoundables().size() === this.getNodeCapacity() && n2.add(this.createNode(e3)), this.lastNode(n2).addChildBoundable(o2);
          }
          return n2;
        }, en.prototype.isEmpty = function() {
          return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
        }, en.prototype.interfaces_ = function() {
          return [e];
        }, en.prototype.getClass = function() {
          return en;
        }, en.compareDoubles = function(t2, e3) {
          return t2 > e3 ? 1 : t2 < e3 ? -1 : 0;
        }, nn.IntersectsOp.get = function() {
          return rn;
        }, nn.serialVersionUID.get = function() {
          return -3886435814360241e3;
        }, nn.DEFAULT_NODE_CAPACITY.get = function() {
          return 10;
        }, Object.defineProperties(en, nn);
        var rn = function() {
        }, on = function() {
        };
        on.prototype.distance = function(t2, e3) {
        }, on.prototype.interfaces_ = function() {
          return [];
        }, on.prototype.getClass = function() {
          return on;
        };
        var sn = function(t2) {
          function n2(e3) {
            e3 = e3 || n2.DEFAULT_NODE_CAPACITY, t2.call(this, e3);
          }
          t2 && (n2.__proto__ = t2), (n2.prototype = Object.create(t2 && t2.prototype)).constructor = n2;
          var i2 = { STRtreeNode: { configurable: true }, serialVersionUID: { configurable: true }, xComparator: { configurable: true }, yComparator: { configurable: true }, intersectsOp: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
          return n2.prototype.createParentBoundablesFromVerticalSlices = function(t3, e3) {
            et.isTrue(t3.length > 0);
            for (var n3 = new Nt(), i3 = 0; i3 < t3.length; i3++)
              n3.addAll(this.createParentBoundablesFromVerticalSlice(t3[i3], e3));
            return n3;
          }, n2.prototype.createNode = function(t3) {
            return new an(t3);
          }, n2.prototype.size = function() {
            return arguments.length === 0 ? t2.prototype.size.call(this) : t2.prototype.size.apply(this, arguments);
          }, n2.prototype.insert = function() {
            if (arguments.length !== 2)
              return t2.prototype.insert.apply(this, arguments);
            var e3 = arguments[0], n3 = arguments[1];
            if (e3.isNull())
              return null;
            t2.prototype.insert.call(this, e3, n3);
          }, n2.prototype.getIntersectsOp = function() {
            return n2.intersectsOp;
          }, n2.prototype.verticalSlices = function(t3, e3) {
            for (var n3 = Math.trunc(Math.ceil(t3.size() / e3)), i3 = new Array(e3).fill(null), r2 = t3.iterator(), o2 = 0; o2 < e3; o2++) {
              i3[o2] = new Nt();
              for (var s2 = 0; r2.hasNext() && s2 < n3; ) {
                var a2 = r2.next();
                i3[o2].add(a2), s2++;
              }
            }
            return i3;
          }, n2.prototype.query = function() {
            if (arguments.length === 1) {
              var e3 = arguments[0];
              return t2.prototype.query.call(this, e3);
            }
            if (arguments.length === 2) {
              var n3 = arguments[0], i3 = arguments[1];
              t2.prototype.query.call(this, n3, i3);
            } else if (arguments.length === 3) {
              if (T(arguments[2], Ke) && arguments[0] instanceof Object && arguments[1] instanceof Qe) {
                var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
                t2.prototype.query.call(this, r2, o2, s2);
              } else if (T(arguments[2], xt) && arguments[0] instanceof Object && arguments[1] instanceof Qe) {
                var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2];
                t2.prototype.query.call(this, a2, u2, l2);
              }
            }
          }, n2.prototype.getComparator = function() {
            return n2.yComparator;
          }, n2.prototype.createParentBoundablesFromVerticalSlice = function(e3, n3) {
            return t2.prototype.createParentBoundables.call(this, e3, n3);
          }, n2.prototype.remove = function() {
            if (arguments.length === 2) {
              var e3 = arguments[0], n3 = arguments[1];
              return t2.prototype.remove.call(this, e3, n3);
            }
            return t2.prototype.remove.apply(this, arguments);
          }, n2.prototype.depth = function() {
            return arguments.length === 0 ? t2.prototype.depth.call(this) : t2.prototype.depth.apply(this, arguments);
          }, n2.prototype.createParentBoundables = function(t3, e3) {
            et.isTrue(!t3.isEmpty());
            var i3 = Math.trunc(Math.ceil(t3.size() / this.getNodeCapacity())), r2 = new Nt(t3);
            $e.sort(r2, n2.xComparator);
            var o2 = this.verticalSlices(r2, Math.trunc(Math.ceil(Math.sqrt(i3))));
            return this.createParentBoundablesFromVerticalSlices(o2, e3);
          }, n2.prototype.nearestNeighbour = function() {
            if (arguments.length === 1) {
              if (T(arguments[0], on)) {
                var t3 = arguments[0], e3 = new tn(this.getRoot(), this.getRoot(), t3);
                return this.nearestNeighbour(e3);
              }
              if (arguments[0] instanceof tn) {
                var i3 = arguments[0];
                return this.nearestNeighbour(i3, v.POSITIVE_INFINITY);
              }
            } else if (arguments.length === 2) {
              if (arguments[0] instanceof n2 && T(arguments[1], on)) {
                var r2 = arguments[0], o2 = arguments[1], s2 = new tn(this.getRoot(), r2.getRoot(), o2);
                return this.nearestNeighbour(s2);
              }
              if (arguments[0] instanceof tn && typeof arguments[1] == "number") {
                var a2 = arguments[0], u2 = arguments[1], l2 = null, c2 = new We();
                for (c2.add(a2); !c2.isEmpty() && u2 > 0; ) {
                  var p2 = c2.poll(), h2 = p2.getDistance();
                  if (h2 >= u2)
                    break;
                  p2.isLeaves() ? (u2 = h2, l2 = p2) : p2.expandToQueue(c2, u2);
                }
                return [l2.getBoundable(0).getItem(), l2.getBoundable(1).getItem()];
              }
            } else if (arguments.length === 3) {
              var f2 = arguments[0], g2 = arguments[1], d2 = arguments[2], y3 = new He(f2, g2), _2 = new tn(this.getRoot(), y3, d2);
              return this.nearestNeighbour(_2)[0];
            }
          }, n2.prototype.interfaces_ = function() {
            return [Je, e];
          }, n2.prototype.getClass = function() {
            return n2;
          }, n2.centreX = function(t3) {
            return n2.avg(t3.getMinX(), t3.getMaxX());
          }, n2.avg = function(t3, e3) {
            return (t3 + e3) / 2;
          }, n2.centreY = function(t3) {
            return n2.avg(t3.getMinY(), t3.getMaxY());
          }, i2.STRtreeNode.get = function() {
            return an;
          }, i2.serialVersionUID.get = function() {
            return 259274702368956900;
          }, i2.xComparator.get = function() {
            return { interfaces_: function() {
              return [N];
            }, compare: function(e3, i3) {
              return t2.compareDoubles(n2.centreX(e3.getBounds()), n2.centreX(i3.getBounds()));
            } };
          }, i2.yComparator.get = function() {
            return { interfaces_: function() {
              return [N];
            }, compare: function(e3, i3) {
              return t2.compareDoubles(n2.centreY(e3.getBounds()), n2.centreY(i3.getBounds()));
            } };
          }, i2.intersectsOp.get = function() {
            return { interfaces_: function() {
              return [t2.IntersectsOp];
            }, intersects: function(t3, e3) {
              return t3.intersects(e3);
            } };
          }, i2.DEFAULT_NODE_CAPACITY.get = function() {
            return 10;
          }, Object.defineProperties(n2, i2), n2;
        }(en), an = function(t2) {
          function e3() {
            var e4 = arguments[0];
            t2.call(this, e4);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.computeBounds = function() {
            for (var t3 = null, e4 = this.getChildBoundables().iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              t3 === null ? t3 = new j(n2.getBounds()) : t3.expandToInclude(n2.getBounds());
            }
            return t3;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Qe), un = function() {
        };
        un.prototype.interfaces_ = function() {
          return [];
        }, un.prototype.getClass = function() {
          return un;
        }, un.relativeSign = function(t2, e3) {
          return t2 < e3 ? -1 : t2 > e3 ? 1 : 0;
        }, un.compare = function(t2, e3, n2) {
          if (e3.equals2D(n2))
            return 0;
          var i2 = un.relativeSign(e3.x, n2.x), r2 = un.relativeSign(e3.y, n2.y);
          switch (t2) {
            case 0:
              return un.compareValue(i2, r2);
            case 1:
              return un.compareValue(r2, i2);
            case 2:
              return un.compareValue(r2, -i2);
            case 3:
              return un.compareValue(-i2, r2);
            case 4:
              return un.compareValue(-i2, -r2);
            case 5:
              return un.compareValue(-r2, -i2);
            case 6:
              return un.compareValue(-r2, i2);
            case 7:
              return un.compareValue(i2, -r2);
          }
          return et.shouldNeverReachHere("invalid octant value"), 0;
        }, un.compareValue = function(t2, e3) {
          return t2 < 0 ? -1 : t2 > 0 ? 1 : e3 < 0 ? -1 : e3 > 0 ? 1 : 0;
        };
        var ln = function() {
          this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
          this._segString = t2, this.coord = new C(e3), this.segmentIndex = n2, this._segmentOctant = i2, this._isInterior = !e3.equals2D(t2.getCoordinate(n2));
        };
        ln.prototype.getCoordinate = function() {
          return this.coord;
        }, ln.prototype.print = function(t2) {
          t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex);
        }, ln.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.segmentIndex < e3.segmentIndex ? -1 : this.segmentIndex > e3.segmentIndex ? 1 : this.coord.equals2D(e3.coord) ? 0 : un.compare(this._segmentOctant, this.coord, e3.coord);
        }, ln.prototype.isEndPoint = function(t2) {
          return this.segmentIndex === 0 && !this._isInterior || this.segmentIndex === t2;
        }, ln.prototype.isInterior = function() {
          return this._isInterior;
        }, ln.prototype.interfaces_ = function() {
          return [E];
        }, ln.prototype.getClass = function() {
          return ln;
        };
        var cn = function() {
          this._nodeMap = new p(), this._edge = null;
          var t2 = arguments[0];
          this._edge = t2;
        };
        cn.prototype.getSplitCoordinates = function() {
          var t2 = new St();
          this.addEndpoints();
          for (var e3 = this.iterator(), n2 = e3.next(); e3.hasNext(); ) {
            var i2 = e3.next();
            this.addEdgeCoordinates(n2, i2, t2), n2 = i2;
          }
          return t2.toCoordinateArray();
        }, cn.prototype.addCollapsedNodes = function() {
          var t2 = new Nt();
          this.findCollapsesFromInsertedNodes(t2), this.findCollapsesFromExistingVertices(t2);
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next().intValue();
            this.add(this._edge.getCoordinate(n2), n2);
          }
        }, cn.prototype.print = function(t2) {
          t2.println("Intersections:");
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, cn.prototype.findCollapsesFromExistingVertices = function(t2) {
          for (var e3 = 0; e3 < this._edge.size() - 2; e3++) {
            var n2 = this._edge.getCoordinate(e3), i2 = this._edge.getCoordinate(e3 + 2);
            n2.equals2D(i2) && t2.add(new M(e3 + 1));
          }
        }, cn.prototype.addEdgeCoordinates = function(t2, e3, n2) {
          var i2 = this._edge.getCoordinate(e3.segmentIndex), r2 = e3.isInterior() || !e3.coord.equals2D(i2);
          n2.add(new C(t2.coord), false);
          for (var o2 = t2.segmentIndex + 1; o2 <= e3.segmentIndex; o2++)
            n2.add(this._edge.getCoordinate(o2));
          r2 && n2.add(new C(e3.coord));
        }, cn.prototype.iterator = function() {
          return this._nodeMap.values().iterator();
        }, cn.prototype.addSplitEdges = function(t2) {
          this.addEndpoints(), this.addCollapsedNodes();
          for (var e3 = this.iterator(), n2 = e3.next(); e3.hasNext(); ) {
            var i2 = e3.next(), r2 = this.createSplitEdge(n2, i2);
            t2.add(r2), n2 = i2;
          }
        }, cn.prototype.findCollapseIndex = function(t2, e3, n2) {
          if (!t2.coord.equals2D(e3.coord))
            return false;
          var i2 = e3.segmentIndex - t2.segmentIndex;
          return e3.isInterior() || i2--, i2 === 1 && (n2[0] = t2.segmentIndex + 1, true);
        }, cn.prototype.findCollapsesFromInsertedNodes = function(t2) {
          for (var e3 = new Array(1).fill(null), n2 = this.iterator(), i2 = n2.next(); n2.hasNext(); ) {
            var r2 = n2.next();
            this.findCollapseIndex(i2, r2, e3) && t2.add(new M(e3[0])), i2 = r2;
          }
        }, cn.prototype.getEdge = function() {
          return this._edge;
        }, cn.prototype.addEndpoints = function() {
          var t2 = this._edge.size() - 1;
          this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t2), t2);
        }, cn.prototype.createSplitEdge = function(t2, e3) {
          var n2 = e3.segmentIndex - t2.segmentIndex + 2, i2 = this._edge.getCoordinate(e3.segmentIndex), r2 = e3.isInterior() || !e3.coord.equals2D(i2);
          r2 || n2--;
          var o2 = new Array(n2).fill(null), s2 = 0;
          o2[s2++] = new C(t2.coord);
          for (var a2 = t2.segmentIndex + 1; a2 <= e3.segmentIndex; a2++)
            o2[s2++] = this._edge.getCoordinate(a2);
          return r2 && (o2[s2] = new C(e3.coord)), new gn(o2, this._edge.getData());
        }, cn.prototype.add = function(t2, e3) {
          var n2 = new ln(this._edge, t2, e3, this._edge.getSegmentOctant(e3)), i2 = this._nodeMap.get(n2);
          return i2 !== null ? (et.isTrue(i2.coord.equals2D(t2), "Found equal nodes with different coordinates"), i2) : (this._nodeMap.put(n2, n2), n2);
        }, cn.prototype.checkSplitEdgesCorrectness = function(t2) {
          var e3 = this._edge.getCoordinates(), n2 = t2.get(0).getCoordinate(0);
          if (!n2.equals2D(e3[0]))
            throw new $("bad split edge start point at " + n2);
          var i2 = t2.get(t2.size() - 1).getCoordinates(), r2 = i2[i2.length - 1];
          if (!r2.equals2D(e3[e3.length - 1]))
            throw new $("bad split edge end point at " + r2);
        }, cn.prototype.interfaces_ = function() {
          return [];
        }, cn.prototype.getClass = function() {
          return cn;
        };
        var pn = function() {
        };
        pn.prototype.interfaces_ = function() {
          return [];
        }, pn.prototype.getClass = function() {
          return pn;
        }, pn.octant = function() {
          if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var t2 = arguments[0], e3 = arguments[1];
            if (t2 === 0 && e3 === 0)
              throw new m("Cannot compute the octant for point ( " + t2 + ", " + e3 + " )");
            var n2 = Math.abs(t2), i2 = Math.abs(e3);
            return t2 >= 0 ? e3 >= 0 ? n2 >= i2 ? 0 : 1 : n2 >= i2 ? 7 : 6 : e3 >= 0 ? n2 >= i2 ? 3 : 2 : n2 >= i2 ? 4 : 5;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof C) {
            var r2 = arguments[0], o2 = arguments[1], s2 = o2.x - r2.x, a2 = o2.y - r2.y;
            if (s2 === 0 && a2 === 0)
              throw new m("Cannot compute the octant for two identical points " + r2);
            return pn.octant(s2, a2);
          }
        };
        var hn = function() {
        };
        hn.prototype.getCoordinates = function() {
        }, hn.prototype.size = function() {
        }, hn.prototype.getCoordinate = function(t2) {
        }, hn.prototype.isClosed = function() {
        }, hn.prototype.setData = function(t2) {
        }, hn.prototype.getData = function() {
        }, hn.prototype.interfaces_ = function() {
          return [];
        }, hn.prototype.getClass = function() {
          return hn;
        };
        var fn = function() {
        };
        fn.prototype.addIntersection = function(t2, e3) {
        }, fn.prototype.interfaces_ = function() {
          return [hn];
        }, fn.prototype.getClass = function() {
          return fn;
        };
        var gn = function() {
          this._nodeList = new cn(this), this._pts = null, this._data = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._pts = t2, this._data = e3;
        };
        gn.prototype.getCoordinates = function() {
          return this._pts;
        }, gn.prototype.size = function() {
          return this._pts.length;
        }, gn.prototype.getCoordinate = function(t2) {
          return this._pts[t2];
        }, gn.prototype.isClosed = function() {
          return this._pts[0].equals(this._pts[this._pts.length - 1]);
        }, gn.prototype.getSegmentOctant = function(t2) {
          return t2 === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t2), this.getCoordinate(t2 + 1));
        }, gn.prototype.setData = function(t2) {
          this._data = t2;
        }, gn.prototype.safeOctant = function(t2, e3) {
          return t2.equals2D(e3) ? 0 : pn.octant(t2, e3);
        }, gn.prototype.getData = function() {
          return this._data;
        }, gn.prototype.addIntersection = function() {
          if (arguments.length === 2) {
            var t2 = arguments[0], e3 = arguments[1];
            this.addIntersectionNode(t2, e3);
          } else if (arguments.length === 4) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[3], o2 = new C(n2.getIntersection(r2));
            this.addIntersection(o2, i2);
          }
        }, gn.prototype.toString = function() {
          return Z.toLineString(new ue(this._pts));
        }, gn.prototype.getNodeList = function() {
          return this._nodeList;
        }, gn.prototype.addIntersectionNode = function(t2, e3) {
          var n2 = e3, i2 = n2 + 1;
          if (i2 < this._pts.length) {
            var r2 = this._pts[i2];
            t2.equals2D(r2) && (n2 = i2);
          }
          return this._nodeList.add(t2, n2);
        }, gn.prototype.addIntersections = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.getIntersectionNum(); i2++)
            this.addIntersection(t2, e3, n2, i2);
        }, gn.prototype.interfaces_ = function() {
          return [fn];
        }, gn.prototype.getClass = function() {
          return gn;
        }, gn.getNodedSubstrings = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0], e3 = new Nt();
            return gn.getNodedSubstrings(t2, e3), e3;
          }
          if (arguments.length === 2)
            for (var n2 = arguments[0], i2 = arguments[1], r2 = n2.iterator(); r2.hasNext(); ) {
              r2.next().getNodeList().addSplitEdges(i2);
            }
        };
        var dn = function() {
          if (this.p0 = null, this.p1 = null, arguments.length === 0)
            this.p0 = new C(), this.p1 = new C();
          else if (arguments.length === 1) {
            var t2 = arguments[0];
            this.p0 = new C(t2.p0), this.p1 = new C(t2.p1);
          } else if (arguments.length === 2)
            this.p0 = arguments[0], this.p1 = arguments[1];
          else if (arguments.length === 4) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = arguments[3];
            this.p0 = new C(e3, n2), this.p1 = new C(i2, r2);
          }
        }, yn = { serialVersionUID: { configurable: true } };
        dn.prototype.minX = function() {
          return Math.min(this.p0.x, this.p1.x);
        }, dn.prototype.orientationIndex = function() {
          if (arguments[0] instanceof dn) {
            var t2 = arguments[0], e3 = at.orientationIndex(this.p0, this.p1, t2.p0), n2 = at.orientationIndex(this.p0, this.p1, t2.p1);
            return e3 >= 0 && n2 >= 0 ? Math.max(e3, n2) : e3 <= 0 && n2 <= 0 ? Math.max(e3, n2) : 0;
          }
          if (arguments[0] instanceof C) {
            var i2 = arguments[0];
            return at.orientationIndex(this.p0, this.p1, i2);
          }
        }, dn.prototype.toGeometry = function(t2) {
          return t2.createLineString([this.p0, this.p1]);
        }, dn.prototype.isVertical = function() {
          return this.p0.x === this.p1.x;
        }, dn.prototype.equals = function(t2) {
          if (!(t2 instanceof dn))
            return false;
          var e3 = t2;
          return this.p0.equals(e3.p0) && this.p1.equals(e3.p1);
        }, dn.prototype.intersection = function(t2) {
          var e3 = new rt();
          return e3.computeIntersection(this.p0, this.p1, t2.p0, t2.p1), e3.hasIntersection() ? e3.getIntersection(0) : null;
        }, dn.prototype.project = function() {
          if (arguments[0] instanceof C) {
            var t2 = arguments[0];
            if (t2.equals(this.p0) || t2.equals(this.p1))
              return new C(t2);
            var e3 = this.projectionFactor(t2), n2 = new C();
            return n2.x = this.p0.x + e3 * (this.p1.x - this.p0.x), n2.y = this.p0.y + e3 * (this.p1.y - this.p0.y), n2;
          }
          if (arguments[0] instanceof dn) {
            var i2 = arguments[0], r2 = this.projectionFactor(i2.p0), o2 = this.projectionFactor(i2.p1);
            if (r2 >= 1 && o2 >= 1)
              return null;
            if (r2 <= 0 && o2 <= 0)
              return null;
            var s2 = this.project(i2.p0);
            r2 < 0 && (s2 = this.p0), r2 > 1 && (s2 = this.p1);
            var a2 = this.project(i2.p1);
            return o2 < 0 && (a2 = this.p0), o2 > 1 && (a2 = this.p1), new dn(s2, a2);
          }
        }, dn.prototype.normalize = function() {
          this.p1.compareTo(this.p0) < 0 && this.reverse();
        }, dn.prototype.angle = function() {
          return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
        }, dn.prototype.getCoordinate = function(t2) {
          return t2 === 0 ? this.p0 : this.p1;
        }, dn.prototype.distancePerpendicular = function(t2) {
          return at.distancePointLinePerpendicular(t2, this.p0, this.p1);
        }, dn.prototype.minY = function() {
          return Math.min(this.p0.y, this.p1.y);
        }, dn.prototype.midPoint = function() {
          return dn.midPoint(this.p0, this.p1);
        }, dn.prototype.projectionFactor = function(t2) {
          if (t2.equals(this.p0))
            return 0;
          if (t2.equals(this.p1))
            return 1;
          var e3 = this.p1.x - this.p0.x, n2 = this.p1.y - this.p0.y, i2 = e3 * e3 + n2 * n2;
          if (i2 <= 0)
            return v.NaN;
          return ((t2.x - this.p0.x) * e3 + (t2.y - this.p0.y) * n2) / i2;
        }, dn.prototype.closestPoints = function(t2) {
          var e3 = this.intersection(t2);
          if (e3 !== null)
            return [e3, e3];
          var n2 = new Array(2).fill(null), i2 = v.MAX_VALUE, r2 = null, o2 = this.closestPoint(t2.p0);
          i2 = o2.distance(t2.p0), n2[0] = o2, n2[1] = t2.p0;
          var s2 = this.closestPoint(t2.p1);
          (r2 = s2.distance(t2.p1)) < i2 && (i2 = r2, n2[0] = s2, n2[1] = t2.p1);
          var a2 = t2.closestPoint(this.p0);
          (r2 = a2.distance(this.p0)) < i2 && (i2 = r2, n2[0] = this.p0, n2[1] = a2);
          var u2 = t2.closestPoint(this.p1);
          return (r2 = u2.distance(this.p1)) < i2 && (i2 = r2, n2[0] = this.p1, n2[1] = u2), n2;
        }, dn.prototype.closestPoint = function(t2) {
          var e3 = this.projectionFactor(t2);
          if (e3 > 0 && e3 < 1)
            return this.project(t2);
          return this.p0.distance(t2) < this.p1.distance(t2) ? this.p0 : this.p1;
        }, dn.prototype.maxX = function() {
          return Math.max(this.p0.x, this.p1.x);
        }, dn.prototype.getLength = function() {
          return this.p0.distance(this.p1);
        }, dn.prototype.compareTo = function(t2) {
          var e3 = t2, n2 = this.p0.compareTo(e3.p0);
          return n2 !== 0 ? n2 : this.p1.compareTo(e3.p1);
        }, dn.prototype.reverse = function() {
          var t2 = this.p0;
          this.p0 = this.p1, this.p1 = t2;
        }, dn.prototype.equalsTopo = function(t2) {
          return this.p0.equals(t2.p0) && (this.p1.equals(t2.p1) || this.p0.equals(t2.p1)) && this.p1.equals(t2.p0);
        }, dn.prototype.lineIntersection = function(t2) {
          try {
            return k.intersection(this.p0, this.p1, t2.p0, t2.p1);
          } catch (t3) {
            if (!(t3 instanceof X))
              throw t3;
          }
          return null;
        }, dn.prototype.maxY = function() {
          return Math.max(this.p0.y, this.p1.y);
        }, dn.prototype.pointAlongOffset = function(t2, e3) {
          var n2 = this.p0.x + t2 * (this.p1.x - this.p0.x), i2 = this.p0.y + t2 * (this.p1.y - this.p0.y), r2 = this.p1.x - this.p0.x, o2 = this.p1.y - this.p0.y, s2 = Math.sqrt(r2 * r2 + o2 * o2), a2 = 0, u2 = 0;
          if (e3 !== 0) {
            if (s2 <= 0)
              throw new Error("Cannot compute offset from zero-length line segment");
            a2 = e3 * r2 / s2, u2 = e3 * o2 / s2;
          }
          return new C(n2 - u2, i2 + a2);
        }, dn.prototype.setCoordinates = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            this.setCoordinates(t2.p0, t2.p1);
          } else if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            this.p0.x = e3.x, this.p0.y = e3.y, this.p1.x = n2.x, this.p1.y = n2.y;
          }
        }, dn.prototype.segmentFraction = function(t2) {
          var e3 = this.projectionFactor(t2);
          return e3 < 0 ? e3 = 0 : (e3 > 1 || v.isNaN(e3)) && (e3 = 1), e3;
        }, dn.prototype.toString = function() {
          return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
        }, dn.prototype.isHorizontal = function() {
          return this.p0.y === this.p1.y;
        }, dn.prototype.distance = function() {
          if (arguments[0] instanceof dn) {
            var t2 = arguments[0];
            return at.distanceLineLine(this.p0, this.p1, t2.p0, t2.p1);
          }
          if (arguments[0] instanceof C) {
            var e3 = arguments[0];
            return at.distancePointLine(e3, this.p0, this.p1);
          }
        }, dn.prototype.pointAlong = function(t2) {
          var e3 = new C();
          return e3.x = this.p0.x + t2 * (this.p1.x - this.p0.x), e3.y = this.p0.y + t2 * (this.p1.y - this.p0.y), e3;
        }, dn.prototype.hashCode = function() {
          var t2 = v.doubleToLongBits(this.p0.x);
          t2 ^= 31 * v.doubleToLongBits(this.p0.y);
          var e3 = Math.trunc(t2) ^ Math.trunc(t2 >> 32), n2 = v.doubleToLongBits(this.p1.x);
          n2 ^= 31 * v.doubleToLongBits(this.p1.y);
          return e3 ^ (Math.trunc(n2) ^ Math.trunc(n2 >> 32));
        }, dn.prototype.interfaces_ = function() {
          return [E, e];
        }, dn.prototype.getClass = function() {
          return dn;
        }, dn.midPoint = function(t2, e3) {
          return new C((t2.x + e3.x) / 2, (t2.y + e3.y) / 2);
        }, yn.serialVersionUID.get = function() {
          return 3252005833466256400;
        }, Object.defineProperties(dn, yn);
        var _n = function() {
          this.tempEnv1 = new j(), this.tempEnv2 = new j(), this._overlapSeg1 = new dn(), this._overlapSeg2 = new dn();
        };
        _n.prototype.overlap = function() {
          if (arguments.length === 2)
            ;
          else if (arguments.length === 4) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
            t2.getLineSegment(e3, this._overlapSeg1), n2.getLineSegment(i2, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
          }
        }, _n.prototype.interfaces_ = function() {
          return [];
        }, _n.prototype.getClass = function() {
          return _n;
        };
        var mn = function() {
          this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
          this._pts = t2, this._start = e3, this._end = n2, this._context = i2;
        };
        mn.prototype.getLineSegment = function(t2, e3) {
          e3.p0 = this._pts[t2], e3.p1 = this._pts[t2 + 1];
        }, mn.prototype.computeSelect = function(t2, e3, n2, i2) {
          var r2 = this._pts[e3], o2 = this._pts[n2];
          if (i2.tempEnv1.init(r2, o2), n2 - e3 == 1)
            return i2.select(this, e3), null;
          if (!t2.intersects(i2.tempEnv1))
            return null;
          var s2 = Math.trunc((e3 + n2) / 2);
          e3 < s2 && this.computeSelect(t2, e3, s2, i2), s2 < n2 && this.computeSelect(t2, s2, n2, i2);
        }, mn.prototype.getCoordinates = function() {
          for (var t2 = new Array(this._end - this._start + 1).fill(null), e3 = 0, n2 = this._start; n2 <= this._end; n2++)
            t2[e3++] = this._pts[n2];
          return t2;
        }, mn.prototype.computeOverlaps = function(t2, e3) {
          this.computeOverlapsInternal(this._start, this._end, t2, t2._start, t2._end, e3);
        }, mn.prototype.setId = function(t2) {
          this._id = t2;
        }, mn.prototype.select = function(t2, e3) {
          this.computeSelect(t2, this._start, this._end, e3);
        }, mn.prototype.getEnvelope = function() {
          if (this._env === null) {
            var t2 = this._pts[this._start], e3 = this._pts[this._end];
            this._env = new j(t2, e3);
          }
          return this._env;
        }, mn.prototype.getEndIndex = function() {
          return this._end;
        }, mn.prototype.getStartIndex = function() {
          return this._start;
        }, mn.prototype.getContext = function() {
          return this._context;
        }, mn.prototype.getId = function() {
          return this._id;
        }, mn.prototype.computeOverlapsInternal = function(t2, e3, n2, i2, r2, o2) {
          var s2 = this._pts[t2], a2 = this._pts[e3], u2 = n2._pts[i2], l2 = n2._pts[r2];
          if (e3 - t2 == 1 && r2 - i2 == 1)
            return o2.overlap(this, t2, n2, i2), null;
          if (o2.tempEnv1.init(s2, a2), o2.tempEnv2.init(u2, l2), !o2.tempEnv1.intersects(o2.tempEnv2))
            return null;
          var c2 = Math.trunc((t2 + e3) / 2), p2 = Math.trunc((i2 + r2) / 2);
          t2 < c2 && (i2 < p2 && this.computeOverlapsInternal(t2, c2, n2, i2, p2, o2), p2 < r2 && this.computeOverlapsInternal(t2, c2, n2, p2, r2, o2)), c2 < e3 && (i2 < p2 && this.computeOverlapsInternal(c2, e3, n2, i2, p2, o2), p2 < r2 && this.computeOverlapsInternal(c2, e3, n2, p2, r2, o2));
        }, mn.prototype.interfaces_ = function() {
          return [];
        }, mn.prototype.getClass = function() {
          return mn;
        };
        var vn = function() {
        };
        vn.prototype.interfaces_ = function() {
          return [];
        }, vn.prototype.getClass = function() {
          return vn;
        }, vn.getChainStartIndices = function(t2) {
          var e3 = 0, n2 = new Nt();
          n2.add(new M(e3));
          do {
            var i2 = vn.findChainEnd(t2, e3);
            n2.add(new M(i2)), e3 = i2;
          } while (e3 < t2.length - 1);
          return vn.toIntArray(n2);
        }, vn.findChainEnd = function(t2, e3) {
          for (var n2 = e3; n2 < t2.length - 1 && t2[n2].equals2D(t2[n2 + 1]); )
            n2++;
          if (n2 >= t2.length - 1)
            return t2.length - 1;
          for (var i2 = Be.quadrant(t2[n2], t2[n2 + 1]), r2 = e3 + 1; r2 < t2.length; ) {
            if (!t2[r2 - 1].equals2D(t2[r2])) {
              if (Be.quadrant(t2[r2 - 1], t2[r2]) !== i2)
                break;
            }
            r2++;
          }
          return r2 - 1;
        }, vn.getChains = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return vn.getChains(t2, null);
          }
          if (arguments.length === 2) {
            for (var e3 = arguments[0], n2 = arguments[1], i2 = new Nt(), r2 = vn.getChainStartIndices(e3), o2 = 0; o2 < r2.length - 1; o2++) {
              var s2 = new mn(e3, r2[o2], r2[o2 + 1], n2);
              i2.add(s2);
            }
            return i2;
          }
        }, vn.toIntArray = function(t2) {
          for (var e3 = new Array(t2.size()).fill(null), n2 = 0; n2 < e3.length; n2++)
            e3[n2] = t2.get(n2).intValue();
          return e3;
        };
        var In = function() {
        };
        In.prototype.computeNodes = function(t2) {
        }, In.prototype.getNodedSubstrings = function() {
        }, In.prototype.interfaces_ = function() {
          return [];
        }, In.prototype.getClass = function() {
          return In;
        };
        var En = function() {
          if (this._segInt = null, arguments.length === 0)
            ;
          else if (arguments.length === 1) {
            var t2 = arguments[0];
            this.setSegmentIntersector(t2);
          }
        };
        En.prototype.setSegmentIntersector = function(t2) {
          this._segInt = t2;
        }, En.prototype.interfaces_ = function() {
          return [In];
        }, En.prototype.getClass = function() {
          return En;
        };
        var xn = function(t2) {
          function e3(e4) {
            e4 ? t2.call(this, e4) : t2.call(this), this._monoChains = new Nt(), this._index = new sn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0;
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { SegmentOverlapAction: { configurable: true } };
          return e3.prototype.getMonotoneChains = function() {
            return this._monoChains;
          }, e3.prototype.getNodedSubstrings = function() {
            return gn.getNodedSubstrings(this._nodedSegStrings);
          }, e3.prototype.getIndex = function() {
            return this._index;
          }, e3.prototype.add = function(t3) {
            for (var e4 = vn.getChains(t3.getCoordinates(), t3).iterator(); e4.hasNext(); ) {
              var n3 = e4.next();
              n3.setId(this._idCounter++), this._index.insert(n3.getEnvelope(), n3), this._monoChains.add(n3);
            }
          }, e3.prototype.computeNodes = function(t3) {
            this._nodedSegStrings = t3;
            for (var e4 = t3.iterator(); e4.hasNext(); )
              this.add(e4.next());
            this.intersectChains();
          }, e3.prototype.intersectChains = function() {
            for (var t3 = new Nn(this._segInt), e4 = this._monoChains.iterator(); e4.hasNext(); )
              for (var n3 = e4.next(), i2 = this._index.query(n3.getEnvelope()).iterator(); i2.hasNext(); ) {
                var r2 = i2.next();
                if (r2.getId() > n3.getId() && (n3.computeOverlaps(r2, t3), this._nOverlaps++), this._segInt.isDone())
                  return null;
              }
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.SegmentOverlapAction.get = function() {
            return Nn;
          }, Object.defineProperties(e3, n2), e3;
        }(En), Nn = function(t2) {
          function e3() {
            t2.call(this), this._si = null;
            var e4 = arguments[0];
            this._si = e4;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.overlap = function() {
            if (arguments.length !== 4)
              return t2.prototype.overlap.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = arguments[3], o2 = e4.getContext(), s2 = i2.getContext();
            this._si.processIntersections(o2, n2, s2, r2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(_n), Cn = function t2() {
          if (this._quadrantSegments = t2.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = t2.CAP_ROUND, this._joinStyle = t2.JOIN_ROUND, this._mitreLimit = t2.DEFAULT_MITRE_LIMIT, this._isSingleSided = false, this._simplifyFactor = t2.DEFAULT_SIMPLIFY_FACTOR, arguments.length === 0)
            ;
          else if (arguments.length === 1) {
            var e3 = arguments[0];
            this.setQuadrantSegments(e3);
          } else if (arguments.length === 2) {
            var n2 = arguments[0], i2 = arguments[1];
            this.setQuadrantSegments(n2), this.setEndCapStyle(i2);
          } else if (arguments.length === 4) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
            this.setQuadrantSegments(r2), this.setEndCapStyle(o2), this.setJoinStyle(s2), this.setMitreLimit(a2);
          }
        }, Sn = { CAP_ROUND: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, JOIN_ROUND: { configurable: true }, JOIN_MITRE: { configurable: true }, JOIN_BEVEL: { configurable: true }, DEFAULT_QUADRANT_SEGMENTS: { configurable: true }, DEFAULT_MITRE_LIMIT: { configurable: true }, DEFAULT_SIMPLIFY_FACTOR: { configurable: true } };
        Cn.prototype.getEndCapStyle = function() {
          return this._endCapStyle;
        }, Cn.prototype.isSingleSided = function() {
          return this._isSingleSided;
        }, Cn.prototype.setQuadrantSegments = function(t2) {
          this._quadrantSegments = t2, this._quadrantSegments === 0 && (this._joinStyle = Cn.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = Cn.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t2 <= 0 && (this._quadrantSegments = 1), this._joinStyle !== Cn.JOIN_ROUND && (this._quadrantSegments = Cn.DEFAULT_QUADRANT_SEGMENTS);
        }, Cn.prototype.getJoinStyle = function() {
          return this._joinStyle;
        }, Cn.prototype.setJoinStyle = function(t2) {
          this._joinStyle = t2;
        }, Cn.prototype.setSimplifyFactor = function(t2) {
          this._simplifyFactor = t2 < 0 ? 0 : t2;
        }, Cn.prototype.getSimplifyFactor = function() {
          return this._simplifyFactor;
        }, Cn.prototype.getQuadrantSegments = function() {
          return this._quadrantSegments;
        }, Cn.prototype.setEndCapStyle = function(t2) {
          this._endCapStyle = t2;
        }, Cn.prototype.getMitreLimit = function() {
          return this._mitreLimit;
        }, Cn.prototype.setMitreLimit = function(t2) {
          this._mitreLimit = t2;
        }, Cn.prototype.setSingleSided = function(t2) {
          this._isSingleSided = t2;
        }, Cn.prototype.interfaces_ = function() {
          return [];
        }, Cn.prototype.getClass = function() {
          return Cn;
        }, Cn.bufferDistanceError = function(t2) {
          var e3 = Math.PI / 2 / t2;
          return 1 - Math.cos(e3 / 2);
        }, Sn.CAP_ROUND.get = function() {
          return 1;
        }, Sn.CAP_FLAT.get = function() {
          return 2;
        }, Sn.CAP_SQUARE.get = function() {
          return 3;
        }, Sn.JOIN_ROUND.get = function() {
          return 1;
        }, Sn.JOIN_MITRE.get = function() {
          return 2;
        }, Sn.JOIN_BEVEL.get = function() {
          return 3;
        }, Sn.DEFAULT_QUADRANT_SEGMENTS.get = function() {
          return 8;
        }, Sn.DEFAULT_MITRE_LIMIT.get = function() {
          return 5;
        }, Sn.DEFAULT_SIMPLIFY_FACTOR.get = function() {
          return 0.01;
        }, Object.defineProperties(Cn, Sn);
        var Ln = function(t2) {
          this._distanceTol = null, this._isDeleted = null, this._angleOrientation = at.COUNTERCLOCKWISE, this._inputLine = t2 || null;
        }, bn = { INIT: { configurable: true }, DELETE: { configurable: true }, KEEP: { configurable: true }, NUM_PTS_TO_CHECK: { configurable: true } };
        Ln.prototype.isDeletable = function(t2, e3, n2, i2) {
          var r2 = this._inputLine[t2], o2 = this._inputLine[e3], s2 = this._inputLine[n2];
          return !!this.isConcave(r2, o2, s2) && (!!this.isShallow(r2, o2, s2, i2) && this.isShallowSampled(r2, o2, t2, n2, i2));
        }, Ln.prototype.deleteShallowConcavities = function() {
          for (var t2 = 1, e3 = this.findNextNonDeletedIndex(t2), n2 = this.findNextNonDeletedIndex(e3), i2 = false; n2 < this._inputLine.length; ) {
            var r2 = false;
            this.isDeletable(t2, e3, n2, this._distanceTol) && (this._isDeleted[e3] = Ln.DELETE, r2 = true, i2 = true), t2 = r2 ? n2 : e3, e3 = this.findNextNonDeletedIndex(t2), n2 = this.findNextNonDeletedIndex(e3);
          }
          return i2;
        }, Ln.prototype.isShallowConcavity = function(t2, e3, n2, i2) {
          if (!(at.computeOrientation(t2, e3, n2) === this._angleOrientation))
            return false;
          return at.distancePointLine(e3, t2, n2) < i2;
        }, Ln.prototype.isShallowSampled = function(t2, e3, n2, i2, r2) {
          var o2 = Math.trunc((i2 - n2) / Ln.NUM_PTS_TO_CHECK);
          o2 <= 0 && (o2 = 1);
          for (var s2 = n2; s2 < i2; s2 += o2)
            if (!this.isShallow(t2, e3, this._inputLine[s2], r2))
              return false;
          return true;
        }, Ln.prototype.isConcave = function(t2, e3, n2) {
          var i2 = at.computeOrientation(t2, e3, n2) === this._angleOrientation;
          return i2;
        }, Ln.prototype.simplify = function(t2) {
          this._distanceTol = Math.abs(t2), t2 < 0 && (this._angleOrientation = at.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
          var e3 = false;
          do {
            e3 = this.deleteShallowConcavities();
          } while (e3);
          return this.collapseLine();
        }, Ln.prototype.findNextNonDeletedIndex = function(t2) {
          for (var e3 = t2 + 1; e3 < this._inputLine.length && this._isDeleted[e3] === Ln.DELETE; )
            e3++;
          return e3;
        }, Ln.prototype.isShallow = function(t2, e3, n2, i2) {
          return at.distancePointLine(e3, t2, n2) < i2;
        }, Ln.prototype.collapseLine = function() {
          for (var t2 = new St(), e3 = 0; e3 < this._inputLine.length; e3++)
            this._isDeleted[e3] !== Ln.DELETE && t2.add(this._inputLine[e3]);
          return t2.toCoordinateArray();
        }, Ln.prototype.interfaces_ = function() {
          return [];
        }, Ln.prototype.getClass = function() {
          return Ln;
        }, Ln.simplify = function(t2, e3) {
          return new Ln(t2).simplify(e3);
        }, bn.INIT.get = function() {
          return 0;
        }, bn.DELETE.get = function() {
          return 1;
        }, bn.KEEP.get = function() {
          return 1;
        }, bn.NUM_PTS_TO_CHECK.get = function() {
          return 10;
        }, Object.defineProperties(Ln, bn);
        var wn = function() {
          this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new Nt();
        }, On = { COORDINATE_ARRAY_TYPE: { configurable: true } };
        wn.prototype.getCoordinates = function() {
          return this._ptList.toArray(wn.COORDINATE_ARRAY_TYPE);
        }, wn.prototype.setPrecisionModel = function(t2) {
          this._precisionModel = t2;
        }, wn.prototype.addPt = function(t2) {
          var e3 = new C(t2);
          if (this._precisionModel.makePrecise(e3), this.isRedundant(e3))
            return null;
          this._ptList.add(e3);
        }, wn.prototype.revere = function() {
        }, wn.prototype.addPts = function(t2, e3) {
          if (e3)
            for (var n2 = 0; n2 < t2.length; n2++)
              this.addPt(t2[n2]);
          else
            for (var i2 = t2.length - 1; i2 >= 0; i2--)
              this.addPt(t2[i2]);
        }, wn.prototype.isRedundant = function(t2) {
          if (this._ptList.size() < 1)
            return false;
          var e3 = this._ptList.get(this._ptList.size() - 1);
          return t2.distance(e3) < this._minimimVertexDistance;
        }, wn.prototype.toString = function() {
          return new _e().createLineString(this.getCoordinates()).toString();
        }, wn.prototype.closeRing = function() {
          if (this._ptList.size() < 1)
            return null;
          var t2 = new C(this._ptList.get(0)), e3 = this._ptList.get(this._ptList.size() - 1);
          if (t2.equals(e3))
            return null;
          this._ptList.add(t2);
        }, wn.prototype.setMinimumVertexDistance = function(t2) {
          this._minimimVertexDistance = t2;
        }, wn.prototype.interfaces_ = function() {
          return [];
        }, wn.prototype.getClass = function() {
          return wn;
        }, On.COORDINATE_ARRAY_TYPE.get = function() {
          return new Array(0).fill(null);
        }, Object.defineProperties(wn, On);
        var Tn = function() {
        }, Rn = { PI_TIMES_2: { configurable: true }, PI_OVER_2: { configurable: true }, PI_OVER_4: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, CLOCKWISE: { configurable: true }, NONE: { configurable: true } };
        Tn.prototype.interfaces_ = function() {
          return [];
        }, Tn.prototype.getClass = function() {
          return Tn;
        }, Tn.toDegrees = function(t2) {
          return 180 * t2 / Math.PI;
        }, Tn.normalize = function(t2) {
          for (; t2 > Math.PI; )
            t2 -= Tn.PI_TIMES_2;
          for (; t2 <= -Math.PI; )
            t2 += Tn.PI_TIMES_2;
          return t2;
        }, Tn.angle = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return Math.atan2(t2.y, t2.x);
          }
          if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1], i2 = n2.x - e3.x, r2 = n2.y - e3.y;
            return Math.atan2(r2, i2);
          }
        }, Tn.isAcute = function(t2, e3, n2) {
          var i2 = t2.x - e3.x, r2 = t2.y - e3.y;
          return i2 * (n2.x - e3.x) + r2 * (n2.y - e3.y) > 0;
        }, Tn.isObtuse = function(t2, e3, n2) {
          var i2 = t2.x - e3.x, r2 = t2.y - e3.y;
          return i2 * (n2.x - e3.x) + r2 * (n2.y - e3.y) < 0;
        }, Tn.interiorAngle = function(t2, e3, n2) {
          var i2 = Tn.angle(e3, t2), r2 = Tn.angle(e3, n2);
          return Math.abs(r2 - i2);
        }, Tn.normalizePositive = function(t2) {
          if (t2 < 0) {
            for (; t2 < 0; )
              t2 += Tn.PI_TIMES_2;
            t2 >= Tn.PI_TIMES_2 && (t2 = 0);
          } else {
            for (; t2 >= Tn.PI_TIMES_2; )
              t2 -= Tn.PI_TIMES_2;
            t2 < 0 && (t2 = 0);
          }
          return t2;
        }, Tn.angleBetween = function(t2, e3, n2) {
          var i2 = Tn.angle(e3, t2), r2 = Tn.angle(e3, n2);
          return Tn.diff(i2, r2);
        }, Tn.diff = function(t2, e3) {
          var n2 = null;
          return (n2 = t2 < e3 ? e3 - t2 : t2 - e3) > Math.PI && (n2 = 2 * Math.PI - n2), n2;
        }, Tn.toRadians = function(t2) {
          return t2 * Math.PI / 180;
        }, Tn.getTurn = function(t2, e3) {
          var n2 = Math.sin(e3 - t2);
          return n2 > 0 ? Tn.COUNTERCLOCKWISE : n2 < 0 ? Tn.CLOCKWISE : Tn.NONE;
        }, Tn.angleBetweenOriented = function(t2, e3, n2) {
          var i2 = Tn.angle(e3, t2), r2 = Tn.angle(e3, n2) - i2;
          return r2 <= -Math.PI ? r2 + Tn.PI_TIMES_2 : r2 > Math.PI ? r2 - Tn.PI_TIMES_2 : r2;
        }, Rn.PI_TIMES_2.get = function() {
          return 2 * Math.PI;
        }, Rn.PI_OVER_2.get = function() {
          return Math.PI / 2;
        }, Rn.PI_OVER_4.get = function() {
          return Math.PI / 4;
        }, Rn.COUNTERCLOCKWISE.get = function() {
          return at.COUNTERCLOCKWISE;
        }, Rn.CLOCKWISE.get = function() {
          return at.CLOCKWISE;
        }, Rn.NONE.get = function() {
          return at.COLLINEAR;
        }, Object.defineProperties(Tn, Rn);
        var Pn = function t2() {
          this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new dn(), this._seg1 = new dn(), this._offset0 = new dn(), this._offset1 = new dn(), this._side = 0, this._hasNarrowConcaveAngle = false;
          var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          this._precisionModel = e3, this._bufParams = n2, this._li = new rt(), this._filletAngleQuantum = Math.PI / 2 / n2.getQuadrantSegments(), n2.getQuadrantSegments() >= 8 && n2.getJoinStyle() === Cn.JOIN_ROUND && (this._closingSegLengthFactor = t2.MAX_CLOSING_SEG_LEN_FACTOR), this.init(i2);
        }, Dn = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: true }, INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, MAX_CLOSING_SEG_LEN_FACTOR: { configurable: true } };
        Pn.prototype.addNextSegment = function(t2, e3) {
          if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t2, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2))
            return null;
          var n2 = at.computeOrientation(this._s0, this._s1, this._s2), i2 = n2 === at.CLOCKWISE && this._side === Se.LEFT || n2 === at.COUNTERCLOCKWISE && this._side === Se.RIGHT;
          n2 === 0 ? this.addCollinear(e3) : i2 ? this.addOutsideTurn(n2, e3) : this.addInsideTurn(n2, e3);
        }, Pn.prototype.addLineEndCap = function(t2, e3) {
          var n2 = new dn(t2, e3), i2 = new dn();
          this.computeOffsetSegment(n2, Se.LEFT, this._distance, i2);
          var r2 = new dn();
          this.computeOffsetSegment(n2, Se.RIGHT, this._distance, r2);
          var o2 = e3.x - t2.x, s2 = e3.y - t2.y, a2 = Math.atan2(s2, o2);
          switch (this._bufParams.getEndCapStyle()) {
            case Cn.CAP_ROUND:
              this._segList.addPt(i2.p1), this.addFilletArc(e3, a2 + Math.PI / 2, a2 - Math.PI / 2, at.CLOCKWISE, this._distance), this._segList.addPt(r2.p1);
              break;
            case Cn.CAP_FLAT:
              this._segList.addPt(i2.p1), this._segList.addPt(r2.p1);
              break;
            case Cn.CAP_SQUARE:
              var u2 = new C();
              u2.x = Math.abs(this._distance) * Math.cos(a2), u2.y = Math.abs(this._distance) * Math.sin(a2);
              var l2 = new C(i2.p1.x + u2.x, i2.p1.y + u2.y), c2 = new C(r2.p1.x + u2.x, r2.p1.y + u2.y);
              this._segList.addPt(l2), this._segList.addPt(c2);
          }
        }, Pn.prototype.getCoordinates = function() {
          return this._segList.getCoordinates();
        }, Pn.prototype.addMitreJoin = function(t2, e3, n2, i2) {
          var r2 = true, o2 = null;
          try {
            o2 = k.intersection(e3.p0, e3.p1, n2.p0, n2.p1);
            (i2 <= 0 ? 1 : o2.distance(t2) / Math.abs(i2)) > this._bufParams.getMitreLimit() && (r2 = false);
          } catch (t3) {
            if (!(t3 instanceof X))
              throw t3;
            o2 = new C(0, 0), r2 = false;
          }
          r2 ? this._segList.addPt(o2) : this.addLimitedMitreJoin(e3, n2, i2, this._bufParams.getMitreLimit());
        }, Pn.prototype.addFilletCorner = function(t2, e3, n2, i2, r2) {
          var o2 = e3.x - t2.x, s2 = e3.y - t2.y, a2 = Math.atan2(s2, o2), u2 = n2.x - t2.x, l2 = n2.y - t2.y, c2 = Math.atan2(l2, u2);
          i2 === at.CLOCKWISE ? a2 <= c2 && (a2 += 2 * Math.PI) : a2 >= c2 && (a2 -= 2 * Math.PI), this._segList.addPt(e3), this.addFilletArc(t2, a2, c2, i2, r2), this._segList.addPt(n2);
        }, Pn.prototype.addOutsideTurn = function(t2, e3) {
          if (this._offset0.p1.distance(this._offset1.p0) < this._distance * Pn.OFFSET_SEGMENT_SEPARATION_FACTOR)
            return this._segList.addPt(this._offset0.p1), null;
          this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e3 && this._segList.addPt(this._offset0.p1), this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, t2, this._distance), this._segList.addPt(this._offset1.p0));
        }, Pn.prototype.createSquare = function(t2) {
          this._segList.addPt(new C(t2.x + this._distance, t2.y + this._distance)), this._segList.addPt(new C(t2.x + this._distance, t2.y - this._distance)), this._segList.addPt(new C(t2.x - this._distance, t2.y - this._distance)), this._segList.addPt(new C(t2.x - this._distance, t2.y + this._distance)), this._segList.closeRing();
        }, Pn.prototype.addSegments = function(t2, e3) {
          this._segList.addPts(t2, e3);
        }, Pn.prototype.addFirstSegment = function() {
          this._segList.addPt(this._offset1.p0);
        }, Pn.prototype.addLastSegment = function() {
          this._segList.addPt(this._offset1.p1);
        }, Pn.prototype.initSideSegments = function(t2, e3, n2) {
          this._s1 = t2, this._s2 = e3, this._side = n2, this._seg1.setCoordinates(t2, e3), this.computeOffsetSegment(this._seg1, n2, this._distance, this._offset1);
        }, Pn.prototype.addLimitedMitreJoin = function(t2, e3, n2, i2) {
          var r2 = this._seg0.p1, o2 = Tn.angle(r2, this._seg0.p0), s2 = Tn.angleBetweenOriented(this._seg0.p0, r2, this._seg1.p1) / 2, a2 = Tn.normalize(o2 + s2), u2 = Tn.normalize(a2 + Math.PI), l2 = i2 * n2, c2 = n2 - l2 * Math.abs(Math.sin(s2)), p2 = r2.x + l2 * Math.cos(u2), h2 = r2.y + l2 * Math.sin(u2), f2 = new C(p2, h2), g2 = new dn(r2, f2), d2 = g2.pointAlongOffset(1, c2), y3 = g2.pointAlongOffset(1, -c2);
          this._side === Se.LEFT ? (this._segList.addPt(d2), this._segList.addPt(y3)) : (this._segList.addPt(y3), this._segList.addPt(d2));
        }, Pn.prototype.computeOffsetSegment = function(t2, e3, n2, i2) {
          var r2 = e3 === Se.LEFT ? 1 : -1, o2 = t2.p1.x - t2.p0.x, s2 = t2.p1.y - t2.p0.y, a2 = Math.sqrt(o2 * o2 + s2 * s2), u2 = r2 * n2 * o2 / a2, l2 = r2 * n2 * s2 / a2;
          i2.p0.x = t2.p0.x - l2, i2.p0.y = t2.p0.y + u2, i2.p1.x = t2.p1.x - l2, i2.p1.y = t2.p1.y + u2;
        }, Pn.prototype.addFilletArc = function(t2, e3, n2, i2, r2) {
          var o2 = i2 === at.CLOCKWISE ? -1 : 1, s2 = Math.abs(e3 - n2), a2 = Math.trunc(s2 / this._filletAngleQuantum + 0.5);
          if (a2 < 1)
            return null;
          for (var u2 = s2 / a2, l2 = 0, c2 = new C(); l2 < s2; ) {
            var p2 = e3 + o2 * l2;
            c2.x = t2.x + r2 * Math.cos(p2), c2.y = t2.y + r2 * Math.sin(p2), this._segList.addPt(c2), l2 += u2;
          }
        }, Pn.prototype.addInsideTurn = function(t2, e3) {
          if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection())
            this._segList.addPt(this._li.getIntersection(0));
          else if (this._hasNarrowConcaveAngle = true, this._offset0.p1.distance(this._offset1.p0) < this._distance * Pn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)
            this._segList.addPt(this._offset0.p1);
          else {
            if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
              var n2 = new C((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(n2);
              var i2 = new C((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(i2);
            } else
              this._segList.addPt(this._s1);
            this._segList.addPt(this._offset1.p0);
          }
        }, Pn.prototype.createCircle = function(t2) {
          var e3 = new C(t2.x + this._distance, t2.y);
          this._segList.addPt(e3), this.addFilletArc(t2, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
        }, Pn.prototype.addBevelJoin = function(t2, e3) {
          this._segList.addPt(t2.p1), this._segList.addPt(e3.p0);
        }, Pn.prototype.init = function(t2) {
          this._distance = t2, this._maxCurveSegmentError = t2 * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new wn(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t2 * Pn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
        }, Pn.prototype.addCollinear = function(t2) {
          this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
          this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL || this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? (t2 && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, at.CLOCKWISE, this._distance));
        }, Pn.prototype.closeRing = function() {
          this._segList.closeRing();
        }, Pn.prototype.hasNarrowConcaveAngle = function() {
          return this._hasNarrowConcaveAngle;
        }, Pn.prototype.interfaces_ = function() {
          return [];
        }, Pn.prototype.getClass = function() {
          return Pn;
        }, Dn.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function() {
          return 1e-3;
        }, Dn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
          return 1e-3;
        }, Dn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
          return 1e-6;
        }, Dn.MAX_CLOSING_SEG_LEN_FACTOR.get = function() {
          return 80;
        }, Object.defineProperties(Pn, Dn);
        var Mn = function() {
          this._distance = 0, this._precisionModel = null, this._bufParams = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._precisionModel = t2, this._bufParams = e3;
        };
        Mn.prototype.getOffsetCurve = function(t2, e3) {
          if (this._distance = e3, e3 === 0)
            return null;
          var n2 = e3 < 0, i2 = Math.abs(e3), r2 = this.getSegGen(i2);
          t2.length <= 1 ? this.computePointCurve(t2[0], r2) : this.computeOffsetCurve(t2, n2, r2);
          var o2 = r2.getCoordinates();
          return n2 && Lt.reverse(o2), o2;
        }, Mn.prototype.computeSingleSidedBufferCurve = function(t2, e3, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          if (e3) {
            n2.addSegments(t2, true);
            var r2 = Ln.simplify(t2, -i2), o2 = r2.length - 1;
            n2.initSideSegments(r2[o2], r2[o2 - 1], Se.LEFT), n2.addFirstSegment();
            for (var s2 = o2 - 2; s2 >= 0; s2--)
              n2.addNextSegment(r2[s2], true);
          } else {
            n2.addSegments(t2, false);
            var a2 = Ln.simplify(t2, i2), u2 = a2.length - 1;
            n2.initSideSegments(a2[0], a2[1], Se.LEFT), n2.addFirstSegment();
            for (var l2 = 2; l2 <= u2; l2++)
              n2.addNextSegment(a2[l2], true);
          }
          n2.addLastSegment(), n2.closeRing();
        }, Mn.prototype.computeRingBufferCurve = function(t2, e3, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          e3 === Se.RIGHT && (i2 = -i2);
          var r2 = Ln.simplify(t2, i2), o2 = r2.length - 1;
          n2.initSideSegments(r2[o2 - 1], r2[0], e3);
          for (var s2 = 1; s2 <= o2; s2++) {
            var a2 = s2 !== 1;
            n2.addNextSegment(r2[s2], a2);
          }
          n2.closeRing();
        }, Mn.prototype.computeLineBufferCurve = function(t2, e3) {
          var n2 = this.simplifyTolerance(this._distance), i2 = Ln.simplify(t2, n2), r2 = i2.length - 1;
          e3.initSideSegments(i2[0], i2[1], Se.LEFT);
          for (var o2 = 2; o2 <= r2; o2++)
            e3.addNextSegment(i2[o2], true);
          e3.addLastSegment(), e3.addLineEndCap(i2[r2 - 1], i2[r2]);
          var s2 = Ln.simplify(t2, -n2), a2 = s2.length - 1;
          e3.initSideSegments(s2[a2], s2[a2 - 1], Se.LEFT);
          for (var u2 = a2 - 2; u2 >= 0; u2--)
            e3.addNextSegment(s2[u2], true);
          e3.addLastSegment(), e3.addLineEndCap(s2[1], s2[0]), e3.closeRing();
        }, Mn.prototype.computePointCurve = function(t2, e3) {
          switch (this._bufParams.getEndCapStyle()) {
            case Cn.CAP_ROUND:
              e3.createCircle(t2);
              break;
            case Cn.CAP_SQUARE:
              e3.createSquare(t2);
          }
        }, Mn.prototype.getLineCurve = function(t2, e3) {
          if (this._distance = e3, e3 < 0 && !this._bufParams.isSingleSided())
            return null;
          if (e3 === 0)
            return null;
          var n2 = Math.abs(e3), i2 = this.getSegGen(n2);
          if (t2.length <= 1)
            this.computePointCurve(t2[0], i2);
          else if (this._bufParams.isSingleSided()) {
            var r2 = e3 < 0;
            this.computeSingleSidedBufferCurve(t2, r2, i2);
          } else
            this.computeLineBufferCurve(t2, i2);
          return i2.getCoordinates();
        }, Mn.prototype.getBufferParameters = function() {
          return this._bufParams;
        }, Mn.prototype.simplifyTolerance = function(t2) {
          return t2 * this._bufParams.getSimplifyFactor();
        }, Mn.prototype.getRingCurve = function(t2, e3, n2) {
          if (this._distance = n2, t2.length <= 2)
            return this.getLineCurve(t2, n2);
          if (n2 === 0)
            return Mn.copyCoordinates(t2);
          var i2 = this.getSegGen(n2);
          return this.computeRingBufferCurve(t2, e3, i2), i2.getCoordinates();
        }, Mn.prototype.computeOffsetCurve = function(t2, e3, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          if (e3) {
            var r2 = Ln.simplify(t2, -i2), o2 = r2.length - 1;
            n2.initSideSegments(r2[o2], r2[o2 - 1], Se.LEFT), n2.addFirstSegment();
            for (var s2 = o2 - 2; s2 >= 0; s2--)
              n2.addNextSegment(r2[s2], true);
          } else {
            var a2 = Ln.simplify(t2, i2), u2 = a2.length - 1;
            n2.initSideSegments(a2[0], a2[1], Se.LEFT), n2.addFirstSegment();
            for (var l2 = 2; l2 <= u2; l2++)
              n2.addNextSegment(a2[l2], true);
          }
          n2.addLastSegment();
        }, Mn.prototype.getSegGen = function(t2) {
          return new Pn(this._precisionModel, this._bufParams, t2);
        }, Mn.prototype.interfaces_ = function() {
          return [];
        }, Mn.prototype.getClass = function() {
          return Mn;
        }, Mn.copyCoordinates = function(t2) {
          for (var e3 = new Array(t2.length).fill(null), n2 = 0; n2 < e3.length; n2++)
            e3[n2] = new C(t2[n2]);
          return e3;
        };
        var An = function() {
          this._subgraphs = null, this._seg = new dn(), this._cga = new at();
          var t2 = arguments[0];
          this._subgraphs = t2;
        }, Fn = { DepthSegment: { configurable: true } };
        An.prototype.findStabbedSegments = function() {
          if (arguments.length === 1) {
            for (var t2 = arguments[0], e3 = new Nt(), n2 = this._subgraphs.iterator(); n2.hasNext(); ) {
              var i2 = n2.next(), r2 = i2.getEnvelope();
              t2.y < r2.getMinY() || t2.y > r2.getMaxY() || this.findStabbedSegments(t2, i2.getDirectedEdges(), e3);
            }
            return e3;
          }
          if (arguments.length === 3) {
            if (T(arguments[2], xt) && arguments[0] instanceof C && arguments[1] instanceof ze)
              for (var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2], u2 = s2.getEdge().getCoordinates(), l2 = 0; l2 < u2.length - 1; l2++) {
                this._seg.p0 = u2[l2], this._seg.p1 = u2[l2 + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse();
                if (!(Math.max(this._seg.p0.x, this._seg.p1.x) < o2.x) && !(this._seg.isHorizontal() || o2.y < this._seg.p0.y || o2.y > this._seg.p1.y || at.computeOrientation(this._seg.p0, this._seg.p1, o2) === at.RIGHT)) {
                  var c2 = s2.getDepth(Se.LEFT);
                  this._seg.p0.equals(u2[l2]) || (c2 = s2.getDepth(Se.RIGHT));
                  var p2 = new Gn(this._seg, c2);
                  a2.add(p2);
                }
              }
            else if (T(arguments[2], xt) && arguments[0] instanceof C && T(arguments[1], xt))
              for (var h2 = arguments[0], f2 = arguments[1], g2 = arguments[2], d2 = f2.iterator(); d2.hasNext(); ) {
                var y3 = d2.next();
                y3.isForward() && this.findStabbedSegments(h2, y3, g2);
              }
          }
        }, An.prototype.getDepth = function(t2) {
          var e3 = this.findStabbedSegments(t2);
          if (e3.size() === 0)
            return 0;
          return $e.min(e3)._leftDepth;
        }, An.prototype.interfaces_ = function() {
          return [];
        }, An.prototype.getClass = function() {
          return An;
        }, Fn.DepthSegment.get = function() {
          return Gn;
        }, Object.defineProperties(An, Fn);
        var Gn = function() {
          this._upwardSeg = null, this._leftDepth = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._upwardSeg = new dn(t2), this._leftDepth = e3;
        };
        Gn.prototype.compareTo = function(t2) {
          var e3 = t2;
          if (this._upwardSeg.minX() >= e3._upwardSeg.maxX())
            return 1;
          if (this._upwardSeg.maxX() <= e3._upwardSeg.minX())
            return -1;
          var n2 = this._upwardSeg.orientationIndex(e3._upwardSeg);
          return n2 !== 0 ? n2 : (n2 = -1 * e3._upwardSeg.orientationIndex(this._upwardSeg)) != 0 ? n2 : this._upwardSeg.compareTo(e3._upwardSeg);
        }, Gn.prototype.compareX = function(t2, e3) {
          var n2 = t2.p0.compareTo(e3.p0);
          return n2 !== 0 ? n2 : t2.p1.compareTo(e3.p1);
        }, Gn.prototype.toString = function() {
          return this._upwardSeg.toString();
        }, Gn.prototype.interfaces_ = function() {
          return [E];
        }, Gn.prototype.getClass = function() {
          return Gn;
        };
        var qn = function(t2, e3, n2) {
          this.p0 = t2 || null, this.p1 = e3 || null, this.p2 = n2 || null;
        };
        qn.prototype.area = function() {
          return qn.area(this.p0, this.p1, this.p2);
        }, qn.prototype.signedArea = function() {
          return qn.signedArea(this.p0, this.p1, this.p2);
        }, qn.prototype.interpolateZ = function(t2) {
          if (t2 === null)
            throw new m("Supplied point is null.");
          return qn.interpolateZ(t2, this.p0, this.p1, this.p2);
        }, qn.prototype.longestSideLength = function() {
          return qn.longestSideLength(this.p0, this.p1, this.p2);
        }, qn.prototype.isAcute = function() {
          return qn.isAcute(this.p0, this.p1, this.p2);
        }, qn.prototype.circumcentre = function() {
          return qn.circumcentre(this.p0, this.p1, this.p2);
        }, qn.prototype.area3D = function() {
          return qn.area3D(this.p0, this.p1, this.p2);
        }, qn.prototype.centroid = function() {
          return qn.centroid(this.p0, this.p1, this.p2);
        }, qn.prototype.inCentre = function() {
          return qn.inCentre(this.p0, this.p1, this.p2);
        }, qn.prototype.interfaces_ = function() {
          return [];
        }, qn.prototype.getClass = function() {
          return qn;
        }, qn.area = function(t2, e3, n2) {
          return Math.abs(((n2.x - t2.x) * (e3.y - t2.y) - (e3.x - t2.x) * (n2.y - t2.y)) / 2);
        }, qn.signedArea = function(t2, e3, n2) {
          return ((n2.x - t2.x) * (e3.y - t2.y) - (e3.x - t2.x) * (n2.y - t2.y)) / 2;
        }, qn.det = function(t2, e3, n2, i2) {
          return t2 * i2 - e3 * n2;
        }, qn.interpolateZ = function(t2, e3, n2, i2) {
          var r2 = e3.x, o2 = e3.y, s2 = n2.x - r2, a2 = i2.x - r2, u2 = n2.y - o2, l2 = i2.y - o2, c2 = s2 * l2 - a2 * u2, p2 = t2.x - r2, h2 = t2.y - o2, f2 = (l2 * p2 - a2 * h2) / c2, g2 = (-u2 * p2 + s2 * h2) / c2;
          return e3.z + f2 * (n2.z - e3.z) + g2 * (i2.z - e3.z);
        }, qn.longestSideLength = function(t2, e3, n2) {
          var i2 = t2.distance(e3), r2 = e3.distance(n2), o2 = n2.distance(t2), s2 = i2;
          return r2 > s2 && (s2 = r2), o2 > s2 && (s2 = o2), s2;
        }, qn.isAcute = function(t2, e3, n2) {
          return !!Tn.isAcute(t2, e3, n2) && (!!Tn.isAcute(e3, n2, t2) && !!Tn.isAcute(n2, t2, e3));
        }, qn.circumcentre = function(t2, e3, n2) {
          var i2 = n2.x, r2 = n2.y, o2 = t2.x - i2, s2 = t2.y - r2, a2 = e3.x - i2, u2 = e3.y - r2, l2 = 2 * qn.det(o2, s2, a2, u2), c2 = qn.det(s2, o2 * o2 + s2 * s2, u2, a2 * a2 + u2 * u2), p2 = qn.det(o2, o2 * o2 + s2 * s2, a2, a2 * a2 + u2 * u2);
          return new C(i2 - c2 / l2, r2 + p2 / l2);
        }, qn.perpendicularBisector = function(t2, e3) {
          var n2 = e3.x - t2.x, i2 = e3.y - t2.y, r2 = new k(t2.x + n2 / 2, t2.y + i2 / 2, 1), o2 = new k(t2.x - i2 + n2 / 2, t2.y + n2 + i2 / 2, 1);
          return new k(r2, o2);
        }, qn.angleBisector = function(t2, e3, n2) {
          var i2 = e3.distance(t2), r2 = i2 / (i2 + e3.distance(n2)), o2 = n2.x - t2.x, s2 = n2.y - t2.y;
          return new C(t2.x + r2 * o2, t2.y + r2 * s2);
        }, qn.area3D = function(t2, e3, n2) {
          var i2 = e3.x - t2.x, r2 = e3.y - t2.y, o2 = e3.z - t2.z, s2 = n2.x - t2.x, a2 = n2.y - t2.y, u2 = n2.z - t2.z, l2 = r2 * u2 - o2 * a2, c2 = o2 * s2 - i2 * u2, p2 = i2 * a2 - r2 * s2, h2 = l2 * l2 + c2 * c2 + p2 * p2, f2 = Math.sqrt(h2) / 2;
          return f2;
        }, qn.centroid = function(t2, e3, n2) {
          var i2 = (t2.x + e3.x + n2.x) / 3, r2 = (t2.y + e3.y + n2.y) / 3;
          return new C(i2, r2);
        }, qn.inCentre = function(t2, e3, n2) {
          var i2 = e3.distance(n2), r2 = t2.distance(n2), o2 = t2.distance(e3), s2 = i2 + r2 + o2, a2 = (i2 * t2.x + r2 * e3.x + o2 * n2.x) / s2, u2 = (i2 * t2.y + r2 * e3.y + o2 * n2.y) / s2;
          return new C(a2, u2);
        };
        var Bn = function() {
          this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new Nt();
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._inputGeom = t2, this._distance = e3, this._curveBuilder = n2;
        };
        Bn.prototype.addPoint = function(t2) {
          if (this._distance <= 0)
            return null;
          var e3 = t2.getCoordinates(), n2 = this._curveBuilder.getLineCurve(e3, this._distance);
          this.addCurve(n2, w.EXTERIOR, w.INTERIOR);
        }, Bn.prototype.addPolygon = function(t2) {
          var e3 = this._distance, n2 = Se.LEFT;
          this._distance < 0 && (e3 = -this._distance, n2 = Se.RIGHT);
          var i2 = t2.getExteriorRing(), r2 = Lt.removeRepeatedPoints(i2.getCoordinates());
          if (this._distance < 0 && this.isErodedCompletely(i2, this._distance))
            return null;
          if (this._distance <= 0 && r2.length < 3)
            return null;
          this.addPolygonRing(r2, e3, n2, w.EXTERIOR, w.INTERIOR);
          for (var o2 = 0; o2 < t2.getNumInteriorRing(); o2++) {
            var s2 = t2.getInteriorRingN(o2), a2 = Lt.removeRepeatedPoints(s2.getCoordinates());
            this._distance > 0 && this.isErodedCompletely(s2, -this._distance) || this.addPolygonRing(a2, e3, Se.opposite(n2), w.INTERIOR, w.EXTERIOR);
          }
        }, Bn.prototype.isTriangleErodedCompletely = function(t2, e3) {
          var n2 = new qn(t2[0], t2[1], t2[2]), i2 = n2.inCentre();
          return at.distancePointLine(i2, n2.p0, n2.p1) < Math.abs(e3);
        }, Bn.prototype.addLineString = function(t2) {
          if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided())
            return null;
          var e3 = Lt.removeRepeatedPoints(t2.getCoordinates()), n2 = this._curveBuilder.getLineCurve(e3, this._distance);
          this.addCurve(n2, w.EXTERIOR, w.INTERIOR);
        }, Bn.prototype.addCurve = function(t2, e3, n2) {
          if (t2 === null || t2.length < 2)
            return null;
          var i2 = new gn(t2, new Pe(0, w.BOUNDARY, e3, n2));
          this._curveList.add(i2);
        }, Bn.prototype.getCurves = function() {
          return this.add(this._inputGeom), this._curveList;
        }, Bn.prototype.addPolygonRing = function(t2, e3, n2, i2, r2) {
          if (e3 === 0 && t2.length < ee.MINIMUM_VALID_SIZE)
            return null;
          var o2 = i2, s2 = r2;
          t2.length >= ee.MINIMUM_VALID_SIZE && at.isCCW(t2) && (o2 = r2, s2 = i2, n2 = Se.opposite(n2));
          var a2 = this._curveBuilder.getRingCurve(t2, n2, e3);
          this.addCurve(a2, o2, s2);
        }, Bn.prototype.add = function(t2) {
          if (t2.isEmpty())
            return null;
          t2 instanceof $t ? this.addPolygon(t2) : t2 instanceof Kt ? this.addLineString(t2) : t2 instanceof Qt ? this.addPoint(t2) : t2 instanceof te ? this.addCollection(t2) : t2 instanceof Xt ? this.addCollection(t2) : t2 instanceof ne ? this.addCollection(t2) : t2 instanceof zt && this.addCollection(t2);
        }, Bn.prototype.isErodedCompletely = function(t2, e3) {
          var n2 = t2.getCoordinates();
          if (n2.length < 4)
            return e3 < 0;
          if (n2.length === 4)
            return this.isTriangleErodedCompletely(n2, e3);
          var i2 = t2.getEnvelopeInternal(), r2 = Math.min(i2.getHeight(), i2.getWidth());
          return e3 < 0 && 2 * Math.abs(e3) > r2;
        }, Bn.prototype.addCollection = function(t2) {
          for (var e3 = 0; e3 < t2.getNumGeometries(); e3++) {
            var n2 = t2.getGeometryN(e3);
            this.add(n2);
          }
        }, Bn.prototype.interfaces_ = function() {
          return [];
        }, Bn.prototype.getClass = function() {
          return Bn;
        };
        var Vn = function() {
        };
        Vn.prototype.locate = function(t2) {
        }, Vn.prototype.interfaces_ = function() {
          return [];
        }, Vn.prototype.getClass = function() {
          return Vn;
        };
        var Un = function() {
          this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
          var t2 = arguments[0];
          this._parent = t2, this._atStart = true, this._index = 0, this._max = t2.getNumGeometries();
        };
        Un.prototype.next = function() {
          if (this._atStart)
            return this._atStart = false, Un.isAtomic(this._parent) && this._index++, this._parent;
          if (this._subcollectionIterator !== null) {
            if (this._subcollectionIterator.hasNext())
              return this._subcollectionIterator.next();
            this._subcollectionIterator = null;
          }
          if (this._index >= this._max)
            throw new i();
          var t2 = this._parent.getGeometryN(this._index++);
          return t2 instanceof zt ? (this._subcollectionIterator = new Un(t2), this._subcollectionIterator.next()) : t2;
        }, Un.prototype.remove = function() {
          throw new Error(this.getClass().getName());
        }, Un.prototype.hasNext = function() {
          if (this._atStart)
            return true;
          if (this._subcollectionIterator !== null) {
            if (this._subcollectionIterator.hasNext())
              return true;
            this._subcollectionIterator = null;
          }
          return !(this._index >= this._max);
        }, Un.prototype.interfaces_ = function() {
          return [Et];
        }, Un.prototype.getClass = function() {
          return Un;
        }, Un.isAtomic = function(t2) {
          return !(t2 instanceof zt);
        };
        var zn = function() {
          this._geom = null;
          var t2 = arguments[0];
          this._geom = t2;
        };
        zn.prototype.locate = function(t2) {
          return zn.locate(t2, this._geom);
        }, zn.prototype.interfaces_ = function() {
          return [Vn];
        }, zn.prototype.getClass = function() {
          return zn;
        }, zn.isPointInRing = function(t2, e3) {
          return !!e3.getEnvelopeInternal().intersects(t2) && at.isPointInRing(t2, e3.getCoordinates());
        }, zn.containsPointInPolygon = function(t2, e3) {
          if (e3.isEmpty())
            return false;
          var n2 = e3.getExteriorRing();
          if (!zn.isPointInRing(t2, n2))
            return false;
          for (var i2 = 0; i2 < e3.getNumInteriorRing(); i2++) {
            var r2 = e3.getInteriorRingN(i2);
            if (zn.isPointInRing(t2, r2))
              return false;
          }
          return true;
        }, zn.containsPoint = function(t2, e3) {
          if (e3 instanceof $t)
            return zn.containsPointInPolygon(t2, e3);
          if (e3 instanceof zt)
            for (var n2 = new Un(e3); n2.hasNext(); ) {
              var i2 = n2.next();
              if (i2 !== e3 && zn.containsPoint(t2, i2))
                return true;
            }
          return false;
        }, zn.locate = function(t2, e3) {
          return e3.isEmpty() ? w.EXTERIOR : zn.containsPoint(t2, e3) ? w.INTERIOR : w.EXTERIOR;
        };
        var Xn = function() {
          this._edgeMap = new p(), this._edgeList = null, this._ptInAreaLocation = [w.NONE, w.NONE];
        };
        Xn.prototype.getNextCW = function(t2) {
          this.getEdges();
          var e3 = this._edgeList.indexOf(t2), n2 = e3 - 1;
          return e3 === 0 && (n2 = this._edgeList.size() - 1), this._edgeList.get(n2);
        }, Xn.prototype.propagateSideLabels = function(t2) {
          for (var e3 = w.NONE, n2 = this.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().getLabel();
            i2.isArea(t2) && i2.getLocation(t2, Se.LEFT) !== w.NONE && (e3 = i2.getLocation(t2, Se.LEFT));
          }
          if (e3 === w.NONE)
            return null;
          for (var r2 = e3, o2 = this.iterator(); o2.hasNext(); ) {
            var s2 = o2.next(), a2 = s2.getLabel();
            if (a2.getLocation(t2, Se.ON) === w.NONE && a2.setLocation(t2, Se.ON, r2), a2.isArea(t2)) {
              var u2 = a2.getLocation(t2, Se.LEFT), l2 = a2.getLocation(t2, Se.RIGHT);
              if (l2 !== w.NONE) {
                if (l2 !== r2)
                  throw new we("side location conflict", s2.getCoordinate());
                u2 === w.NONE && et.shouldNeverReachHere("found single null side (at " + s2.getCoordinate() + ")"), r2 = u2;
              } else
                et.isTrue(a2.getLocation(t2, Se.LEFT) === w.NONE, "found single null side"), a2.setLocation(t2, Se.RIGHT, r2), a2.setLocation(t2, Se.LEFT, r2);
            }
          }
        }, Xn.prototype.getCoordinate = function() {
          var t2 = this.iterator();
          if (!t2.hasNext())
            return null;
          return t2.next().getCoordinate();
        }, Xn.prototype.print = function(t2) {
          Y.out.println("EdgeEndStar:   " + this.getCoordinate());
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, Xn.prototype.isAreaLabelsConsistent = function(t2) {
          return this.computeEdgeEndLabels(t2.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
        }, Xn.prototype.checkAreaLabelsConsistent = function(t2) {
          var e3 = this.getEdges();
          if (e3.size() <= 0)
            return true;
          var n2 = e3.size() - 1, i2 = e3.get(n2).getLabel().getLocation(t2, Se.LEFT);
          et.isTrue(i2 !== w.NONE, "Found unlabelled area edge");
          for (var r2 = i2, o2 = this.iterator(); o2.hasNext(); ) {
            var s2 = o2.next().getLabel();
            et.isTrue(s2.isArea(t2), "Found non-area edge");
            var a2 = s2.getLocation(t2, Se.LEFT), u2 = s2.getLocation(t2, Se.RIGHT);
            if (a2 === u2)
              return false;
            if (u2 !== r2)
              return false;
            r2 = a2;
          }
          return true;
        }, Xn.prototype.findIndex = function(t2) {
          this.iterator();
          for (var e3 = 0; e3 < this._edgeList.size(); e3++) {
            if (this._edgeList.get(e3) === t2)
              return e3;
          }
          return -1;
        }, Xn.prototype.iterator = function() {
          return this.getEdges().iterator();
        }, Xn.prototype.getEdges = function() {
          return this._edgeList === null && (this._edgeList = new Nt(this._edgeMap.values())), this._edgeList;
        }, Xn.prototype.getLocation = function(t2, e3, n2) {
          return this._ptInAreaLocation[t2] === w.NONE && (this._ptInAreaLocation[t2] = zn.locate(e3, n2[t2].getGeometry())), this._ptInAreaLocation[t2];
        }, Xn.prototype.toString = function() {
          var t2 = new D();
          t2.append("EdgeEndStar:   " + this.getCoordinate()), t2.append("\n");
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            t2.append(n2), t2.append("\n");
          }
          return t2.toString();
        }, Xn.prototype.computeEdgeEndLabels = function(t2) {
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().computeLabel(t2);
          }
        }, Xn.prototype.computeLabelling = function(t2) {
          this.computeEdgeEndLabels(t2[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
          for (var e3 = [false, false], n2 = this.iterator(); n2.hasNext(); )
            for (var i2 = n2.next().getLabel(), r2 = 0; r2 < 2; r2++)
              i2.isLine(r2) && i2.getLocation(r2) === w.BOUNDARY && (e3[r2] = true);
          for (var o2 = this.iterator(); o2.hasNext(); )
            for (var s2 = o2.next(), a2 = s2.getLabel(), u2 = 0; u2 < 2; u2++)
              if (a2.isAnyNull(u2)) {
                var l2 = w.NONE;
                if (e3[u2])
                  l2 = w.EXTERIOR;
                else {
                  var c2 = s2.getCoordinate();
                  l2 = this.getLocation(u2, c2, t2);
                }
                a2.setAllLocationsIfNull(u2, l2);
              }
        }, Xn.prototype.getDegree = function() {
          return this._edgeMap.size();
        }, Xn.prototype.insertEdgeEnd = function(t2, e3) {
          this._edgeMap.put(t2, e3), this._edgeList = null;
        }, Xn.prototype.interfaces_ = function() {
          return [];
        }, Xn.prototype.getClass = function() {
          return Xn;
        };
        var Yn = function(t2) {
          function e3() {
            t2.call(this), this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.linkResultDirectedEdges = function() {
            this.getResultAreaEdges();
            for (var t3 = null, e4 = null, n2 = this._SCANNING_FOR_INCOMING, i2 = 0; i2 < this._resultAreaEdgeList.size(); i2++) {
              var r2 = this._resultAreaEdgeList.get(i2), o2 = r2.getSym();
              if (r2.getLabel().isArea())
                switch (t3 === null && r2.isInResult() && (t3 = r2), n2) {
                  case this._SCANNING_FOR_INCOMING:
                    if (!o2.isInResult())
                      continue;
                    e4 = o2, n2 = this._LINKING_TO_OUTGOING;
                    break;
                  case this._LINKING_TO_OUTGOING:
                    if (!r2.isInResult())
                      continue;
                    e4.setNext(r2), n2 = this._SCANNING_FOR_INCOMING;
                }
            }
            if (n2 === this._LINKING_TO_OUTGOING) {
              if (t3 === null)
                throw new we("no outgoing dirEdge found", this.getCoordinate());
              et.isTrue(t3.isInResult(), "unable to link last incoming dirEdge"), e4.setNext(t3);
            }
          }, e3.prototype.insert = function(t3) {
            var e4 = t3;
            this.insertEdgeEnd(e4, e4);
          }, e3.prototype.getRightmostEdge = function() {
            var t3 = this.getEdges(), e4 = t3.size();
            if (e4 < 1)
              return null;
            var n2 = t3.get(0);
            if (e4 === 1)
              return n2;
            var i2 = t3.get(e4 - 1), r2 = n2.getQuadrant(), o2 = i2.getQuadrant();
            return Be.isNorthern(r2) && Be.isNorthern(o2) ? n2 : Be.isNorthern(r2) || Be.isNorthern(o2) ? n2.getDy() !== 0 ? n2 : i2.getDy() !== 0 ? i2 : (et.shouldNeverReachHere("found two horizontal edges incident on node"), null) : i2;
          }, e3.prototype.print = function(t3) {
            Y.out.println("DirectedEdgeStar: " + this.getCoordinate());
            for (var e4 = this.iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              t3.print("out "), n2.print(t3), t3.println(), t3.print("in "), n2.getSym().print(t3), t3.println();
            }
          }, e3.prototype.getResultAreaEdges = function() {
            if (this._resultAreaEdgeList !== null)
              return this._resultAreaEdgeList;
            this._resultAreaEdgeList = new Nt();
            for (var t3 = this.iterator(); t3.hasNext(); ) {
              var e4 = t3.next();
              (e4.isInResult() || e4.getSym().isInResult()) && this._resultAreaEdgeList.add(e4);
            }
            return this._resultAreaEdgeList;
          }, e3.prototype.updateLabelling = function(t3) {
            for (var e4 = this.iterator(); e4.hasNext(); ) {
              var n2 = e4.next().getLabel();
              n2.setAllLocationsIfNull(0, t3.getLocation(0)), n2.setAllLocationsIfNull(1, t3.getLocation(1));
            }
          }, e3.prototype.linkAllDirectedEdges = function() {
            this.getEdges();
            for (var t3 = null, e4 = null, n2 = this._edgeList.size() - 1; n2 >= 0; n2--) {
              var i2 = this._edgeList.get(n2), r2 = i2.getSym();
              e4 === null && (e4 = r2), t3 !== null && r2.setNext(t3), t3 = i2;
            }
            e4.setNext(t3);
          }, e3.prototype.computeDepths = function() {
            if (arguments.length === 1) {
              var t3 = arguments[0], e4 = this.findIndex(t3), n2 = t3.getDepth(Se.LEFT), i2 = t3.getDepth(Se.RIGHT), r2 = this.computeDepths(e4 + 1, this._edgeList.size(), n2);
              if (this.computeDepths(0, e4, r2) !== i2)
                throw new we("depth mismatch at " + t3.getCoordinate());
            } else if (arguments.length === 3) {
              for (var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2], u2 = o2; u2 < s2; u2++) {
                var l2 = this._edgeList.get(u2);
                l2.setEdgeDepths(Se.RIGHT, a2), a2 = l2.getDepth(Se.LEFT);
              }
              return a2;
            }
          }, e3.prototype.mergeSymLabels = function() {
            for (var t3 = this.iterator(); t3.hasNext(); ) {
              var e4 = t3.next();
              e4.getLabel().merge(e4.getSym().getLabel());
            }
          }, e3.prototype.linkMinimalDirectedEdges = function(t3) {
            for (var e4 = null, n2 = null, i2 = this._SCANNING_FOR_INCOMING, r2 = this._resultAreaEdgeList.size() - 1; r2 >= 0; r2--) {
              var o2 = this._resultAreaEdgeList.get(r2), s2 = o2.getSym();
              switch (e4 === null && o2.getEdgeRing() === t3 && (e4 = o2), i2) {
                case this._SCANNING_FOR_INCOMING:
                  if (s2.getEdgeRing() !== t3)
                    continue;
                  n2 = s2, i2 = this._LINKING_TO_OUTGOING;
                  break;
                case this._LINKING_TO_OUTGOING:
                  if (o2.getEdgeRing() !== t3)
                    continue;
                  n2.setNextMin(o2), i2 = this._SCANNING_FOR_INCOMING;
              }
            }
            i2 === this._LINKING_TO_OUTGOING && (et.isTrue(e4 !== null, "found null for first outgoing dirEdge"), et.isTrue(e4.getEdgeRing() === t3, "unable to link last incoming dirEdge"), n2.setNextMin(e4));
          }, e3.prototype.getOutgoingDegree = function() {
            if (arguments.length === 0) {
              for (var t3 = 0, e4 = this.iterator(); e4.hasNext(); ) {
                e4.next().isInResult() && t3++;
              }
              return t3;
            }
            if (arguments.length === 1) {
              for (var n2 = arguments[0], i2 = 0, r2 = this.iterator(); r2.hasNext(); ) {
                r2.next().getEdgeRing() === n2 && i2++;
              }
              return i2;
            }
          }, e3.prototype.getLabel = function() {
            return this._label;
          }, e3.prototype.findCoveredLineEdges = function() {
            for (var t3 = w.NONE, e4 = this.iterator(); e4.hasNext(); ) {
              var n2 = e4.next(), i2 = n2.getSym();
              if (!n2.isLineEdge()) {
                if (n2.isInResult()) {
                  t3 = w.INTERIOR;
                  break;
                }
                if (i2.isInResult()) {
                  t3 = w.EXTERIOR;
                  break;
                }
              }
            }
            if (t3 === w.NONE)
              return null;
            for (var r2 = t3, o2 = this.iterator(); o2.hasNext(); ) {
              var s2 = o2.next(), a2 = s2.getSym();
              s2.isLineEdge() ? s2.getEdge().setCovered(r2 === w.INTERIOR) : (s2.isInResult() && (r2 = w.EXTERIOR), a2.isInResult() && (r2 = w.INTERIOR));
            }
          }, e3.prototype.computeLabelling = function(e4) {
            t2.prototype.computeLabelling.call(this, e4), this._label = new Pe(w.NONE);
            for (var n2 = this.iterator(); n2.hasNext(); )
              for (var i2 = n2.next().getEdge().getLabel(), r2 = 0; r2 < 2; r2++) {
                var o2 = i2.getLocation(r2);
                o2 !== w.INTERIOR && o2 !== w.BOUNDARY || this._label.setLocation(r2, w.INTERIOR);
              }
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Xn), kn = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.createNode = function(t3) {
            return new Ge(t3, new Yn());
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Xe), jn = function t2() {
          this._pts = null, this._orientation = null;
          var e3 = arguments[0];
          this._pts = e3, this._orientation = t2.orientation(e3);
        };
        jn.prototype.compareTo = function(t2) {
          var e3 = t2;
          return jn.compareOriented(this._pts, this._orientation, e3._pts, e3._orientation);
        }, jn.prototype.interfaces_ = function() {
          return [E];
        }, jn.prototype.getClass = function() {
          return jn;
        }, jn.orientation = function(t2) {
          return Lt.increasingDirection(t2) === 1;
        }, jn.compareOriented = function(t2, e3, n2, i2) {
          for (var r2 = e3 ? 1 : -1, o2 = i2 ? 1 : -1, s2 = e3 ? t2.length : -1, a2 = i2 ? n2.length : -1, u2 = e3 ? 0 : t2.length - 1, l2 = i2 ? 0 : n2.length - 1; ; ) {
            var c2 = t2[u2].compareTo(n2[l2]);
            if (c2 !== 0)
              return c2;
            var p2 = (u2 += r2) === s2, h2 = (l2 += o2) === a2;
            if (p2 && !h2)
              return -1;
            if (!p2 && h2)
              return 1;
            if (p2 && h2)
              return 0;
          }
        };
        var Hn = function() {
          this._edges = new Nt(), this._ocaMap = new p();
        };
        Hn.prototype.print = function(t2) {
          t2.print("MULTILINESTRING ( ");
          for (var e3 = 0; e3 < this._edges.size(); e3++) {
            var n2 = this._edges.get(e3);
            e3 > 0 && t2.print(","), t2.print("(");
            for (var i2 = n2.getCoordinates(), r2 = 0; r2 < i2.length; r2++)
              r2 > 0 && t2.print(","), t2.print(i2[r2].x + " " + i2[r2].y);
            t2.println(")");
          }
          t2.print(")  ");
        }, Hn.prototype.addAll = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); )
            this.add(e3.next());
        }, Hn.prototype.findEdgeIndex = function(t2) {
          for (var e3 = 0; e3 < this._edges.size(); e3++)
            if (this._edges.get(e3).equals(t2))
              return e3;
          return -1;
        }, Hn.prototype.iterator = function() {
          return this._edges.iterator();
        }, Hn.prototype.getEdges = function() {
          return this._edges;
        }, Hn.prototype.get = function(t2) {
          return this._edges.get(t2);
        }, Hn.prototype.findEqualEdge = function(t2) {
          var e3 = new jn(t2.getCoordinates());
          return this._ocaMap.get(e3);
        }, Hn.prototype.add = function(t2) {
          this._edges.add(t2);
          var e3 = new jn(t2.getCoordinates());
          this._ocaMap.put(e3, t2);
        }, Hn.prototype.interfaces_ = function() {
          return [];
        }, Hn.prototype.getClass = function() {
          return Hn;
        };
        var Wn = function() {
        };
        Wn.prototype.processIntersections = function(t2, e3, n2, i2) {
        }, Wn.prototype.isDone = function() {
        }, Wn.prototype.interfaces_ = function() {
          return [];
        }, Wn.prototype.getClass = function() {
          return Wn;
        };
        var Kn = function() {
          this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._hasInterior = false, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
          var t2 = arguments[0];
          this._li = t2;
        };
        Kn.prototype.isTrivialIntersection = function(t2, e3, n2, i2) {
          if (t2 === n2 && this._li.getIntersectionNum() === 1) {
            if (Kn.isAdjacentSegments(e3, i2))
              return true;
            if (t2.isClosed()) {
              var r2 = t2.size() - 1;
              if (e3 === 0 && i2 === r2 || i2 === 0 && e3 === r2)
                return true;
            }
          }
          return false;
        }, Kn.prototype.getProperIntersectionPoint = function() {
          return this._properIntersectionPoint;
        }, Kn.prototype.hasProperInteriorIntersection = function() {
          return this._hasProperInterior;
        }, Kn.prototype.getLineIntersector = function() {
          return this._li;
        }, Kn.prototype.hasProperIntersection = function() {
          return this._hasProper;
        }, Kn.prototype.processIntersections = function(t2, e3, n2, i2) {
          if (t2 === n2 && e3 === i2)
            return null;
          this.numTests++;
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = true), this.isTrivialIntersection(t2, e3, n2, i2) || (this._hasIntersection = true, t2.addIntersections(this._li, e3, 0), n2.addIntersections(this._li, i2, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = true, this._hasProperInterior = true)));
        }, Kn.prototype.hasIntersection = function() {
          return this._hasIntersection;
        }, Kn.prototype.isDone = function() {
          return false;
        }, Kn.prototype.hasInteriorIntersection = function() {
          return this._hasInterior;
        }, Kn.prototype.interfaces_ = function() {
          return [Wn];
        }, Kn.prototype.getClass = function() {
          return Kn;
        }, Kn.isAdjacentSegments = function(t2, e3) {
          return Math.abs(t2 - e3) === 1;
        };
        var Jn = function() {
          this.coord = null, this.segmentIndex = null, this.dist = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this.coord = new C(t2), this.segmentIndex = e3, this.dist = n2;
        };
        Jn.prototype.getSegmentIndex = function() {
          return this.segmentIndex;
        }, Jn.prototype.getCoordinate = function() {
          return this.coord;
        }, Jn.prototype.print = function(t2) {
          t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex), t2.println(" dist = " + this.dist);
        }, Jn.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.compare(e3.segmentIndex, e3.dist);
        }, Jn.prototype.isEndPoint = function(t2) {
          return this.segmentIndex === 0 && this.dist === 0 || this.segmentIndex === t2;
        }, Jn.prototype.toString = function() {
          return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
        }, Jn.prototype.getDistance = function() {
          return this.dist;
        }, Jn.prototype.compare = function(t2, e3) {
          return this.segmentIndex < t2 ? -1 : this.segmentIndex > t2 ? 1 : this.dist < e3 ? -1 : this.dist > e3 ? 1 : 0;
        }, Jn.prototype.interfaces_ = function() {
          return [E];
        }, Jn.prototype.getClass = function() {
          return Jn;
        };
        var Qn = function() {
          this._nodeMap = new p(), this.edge = null;
          var t2 = arguments[0];
          this.edge = t2;
        };
        Qn.prototype.print = function(t2) {
          t2.println("Intersections:");
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, Qn.prototype.iterator = function() {
          return this._nodeMap.values().iterator();
        }, Qn.prototype.addSplitEdges = function(t2) {
          this.addEndpoints();
          for (var e3 = this.iterator(), n2 = e3.next(); e3.hasNext(); ) {
            var i2 = e3.next(), r2 = this.createSplitEdge(n2, i2);
            t2.add(r2), n2 = i2;
          }
        }, Qn.prototype.addEndpoints = function() {
          var t2 = this.edge.pts.length - 1;
          this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t2], t2, 0);
        }, Qn.prototype.createSplitEdge = function(t2, e3) {
          var n2 = e3.segmentIndex - t2.segmentIndex + 2, i2 = this.edge.pts[e3.segmentIndex], r2 = e3.dist > 0 || !e3.coord.equals2D(i2);
          r2 || n2--;
          var o2 = new Array(n2).fill(null), s2 = 0;
          o2[s2++] = new C(t2.coord);
          for (var a2 = t2.segmentIndex + 1; a2 <= e3.segmentIndex; a2++)
            o2[s2++] = this.edge.pts[a2];
          return r2 && (o2[s2] = e3.coord), new ni(o2, new Pe(this.edge._label));
        }, Qn.prototype.add = function(t2, e3, n2) {
          var i2 = new Jn(t2, e3, n2), r2 = this._nodeMap.get(i2);
          return r2 !== null ? r2 : (this._nodeMap.put(i2, i2), i2);
        }, Qn.prototype.isIntersection = function(t2) {
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            if (e3.next().coord.equals(t2))
              return true;
          }
          return false;
        }, Qn.prototype.interfaces_ = function() {
          return [];
        }, Qn.prototype.getClass = function() {
          return Qn;
        };
        var Zn = function() {
        };
        Zn.prototype.getChainStartIndices = function(t2) {
          var e3 = 0, n2 = new Nt();
          n2.add(new M(e3));
          do {
            var i2 = this.findChainEnd(t2, e3);
            n2.add(new M(i2)), e3 = i2;
          } while (e3 < t2.length - 1);
          return Zn.toIntArray(n2);
        }, Zn.prototype.findChainEnd = function(t2, e3) {
          for (var n2 = Be.quadrant(t2[e3], t2[e3 + 1]), i2 = e3 + 1; i2 < t2.length; ) {
            if (Be.quadrant(t2[i2 - 1], t2[i2]) !== n2)
              break;
            i2++;
          }
          return i2 - 1;
        }, Zn.prototype.interfaces_ = function() {
          return [];
        }, Zn.prototype.getClass = function() {
          return Zn;
        }, Zn.toIntArray = function(t2) {
          for (var e3 = new Array(t2.size()).fill(null), n2 = 0; n2 < e3.length; n2++)
            e3[n2] = t2.get(n2).intValue();
          return e3;
        };
        var $n = function() {
          this.e = null, this.pts = null, this.startIndex = null, this.env1 = new j(), this.env2 = new j();
          var t2 = arguments[0];
          this.e = t2, this.pts = t2.getCoordinates();
          var e3 = new Zn();
          this.startIndex = e3.getChainStartIndices(this.pts);
        };
        $n.prototype.getCoordinates = function() {
          return this.pts;
        }, $n.prototype.getMaxX = function(t2) {
          var e3 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
          return e3 > n2 ? e3 : n2;
        }, $n.prototype.getMinX = function(t2) {
          var e3 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
          return e3 < n2 ? e3 : n2;
        }, $n.prototype.computeIntersectsForChain = function() {
          if (arguments.length === 4) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
            this.computeIntersectsForChain(this.startIndex[t2], this.startIndex[t2 + 1], e3, e3.startIndex[n2], e3.startIndex[n2 + 1], i2);
          } else if (arguments.length === 6) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3], u2 = arguments[4], l2 = arguments[5], c2 = this.pts[r2], p2 = this.pts[o2], h2 = s2.pts[a2], f2 = s2.pts[u2];
            if (o2 - r2 == 1 && u2 - a2 == 1)
              return l2.addIntersections(this.e, r2, s2.e, a2), null;
            if (this.env1.init(c2, p2), this.env2.init(h2, f2), !this.env1.intersects(this.env2))
              return null;
            var g2 = Math.trunc((r2 + o2) / 2), d2 = Math.trunc((a2 + u2) / 2);
            r2 < g2 && (a2 < d2 && this.computeIntersectsForChain(r2, g2, s2, a2, d2, l2), d2 < u2 && this.computeIntersectsForChain(r2, g2, s2, d2, u2, l2)), g2 < o2 && (a2 < d2 && this.computeIntersectsForChain(g2, o2, s2, a2, d2, l2), d2 < u2 && this.computeIntersectsForChain(g2, o2, s2, d2, u2, l2));
          }
        }, $n.prototype.getStartIndexes = function() {
          return this.startIndex;
        }, $n.prototype.computeIntersects = function(t2, e3) {
          for (var n2 = 0; n2 < this.startIndex.length - 1; n2++)
            for (var i2 = 0; i2 < t2.startIndex.length - 1; i2++)
              this.computeIntersectsForChain(n2, t2, i2, e3);
        }, $n.prototype.interfaces_ = function() {
          return [];
        }, $n.prototype.getClass = function() {
          return $n;
        };
        var ti = function t2() {
          this._depth = Array(2).fill().map(function() {
            return Array(3);
          });
          for (var e3 = 0; e3 < 2; e3++)
            for (var n2 = 0; n2 < 3; n2++)
              this._depth[e3][n2] = t2.NULL_VALUE;
        }, ei = { NULL_VALUE: { configurable: true } };
        ti.prototype.getDepth = function(t2, e3) {
          return this._depth[t2][e3];
        }, ti.prototype.setDepth = function(t2, e3, n2) {
          this._depth[t2][e3] = n2;
        }, ti.prototype.isNull = function() {
          if (arguments.length === 0) {
            for (var t2 = 0; t2 < 2; t2++)
              for (var e3 = 0; e3 < 3; e3++)
                if (this._depth[t2][e3] !== ti.NULL_VALUE)
                  return false;
            return true;
          }
          if (arguments.length === 1) {
            var n2 = arguments[0];
            return this._depth[n2][1] === ti.NULL_VALUE;
          }
          if (arguments.length === 2) {
            var i2 = arguments[0], r2 = arguments[1];
            return this._depth[i2][r2] === ti.NULL_VALUE;
          }
        }, ti.prototype.normalize = function() {
          for (var t2 = 0; t2 < 2; t2++)
            if (!this.isNull(t2)) {
              var e3 = this._depth[t2][1];
              this._depth[t2][2] < e3 && (e3 = this._depth[t2][2]), e3 < 0 && (e3 = 0);
              for (var n2 = 1; n2 < 3; n2++) {
                var i2 = 0;
                this._depth[t2][n2] > e3 && (i2 = 1), this._depth[t2][n2] = i2;
              }
            }
        }, ti.prototype.getDelta = function(t2) {
          return this._depth[t2][Se.RIGHT] - this._depth[t2][Se.LEFT];
        }, ti.prototype.getLocation = function(t2, e3) {
          return this._depth[t2][e3] <= 0 ? w.EXTERIOR : w.INTERIOR;
        }, ti.prototype.toString = function() {
          return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
        }, ti.prototype.add = function() {
          if (arguments.length === 1)
            for (var t2 = arguments[0], e3 = 0; e3 < 2; e3++)
              for (var n2 = 1; n2 < 3; n2++) {
                var i2 = t2.getLocation(e3, n2);
                i2 !== w.EXTERIOR && i2 !== w.INTERIOR || (this.isNull(e3, n2) ? this._depth[e3][n2] = ti.depthAtLocation(i2) : this._depth[e3][n2] += ti.depthAtLocation(i2));
              }
          else if (arguments.length === 3) {
            var r2 = arguments[0], o2 = arguments[1];
            arguments[2] === w.INTERIOR && this._depth[r2][o2]++;
          }
        }, ti.prototype.interfaces_ = function() {
          return [];
        }, ti.prototype.getClass = function() {
          return ti;
        }, ti.depthAtLocation = function(t2) {
          return t2 === w.EXTERIOR ? 0 : t2 === w.INTERIOR ? 1 : ti.NULL_VALUE;
        }, ei.NULL_VALUE.get = function() {
          return -1;
        }, Object.defineProperties(ti, ei);
        var ni = function(t2) {
          function e3() {
            if (t2.call(this), this.pts = null, this._env = null, this.eiList = new Qn(this), this._name = null, this._mce = null, this._isIsolated = true, this._depth = new ti(), this._depthDelta = 0, arguments.length === 1) {
              var n2 = arguments[0];
              e3.call(this, n2, null);
            } else if (arguments.length === 2) {
              var i2 = arguments[0], r2 = arguments[1];
              this.pts = i2, this._label = r2;
            }
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.getDepth = function() {
            return this._depth;
          }, e3.prototype.getCollapsedEdge = function() {
            var t3 = new Array(2).fill(null);
            t3[0] = this.pts[0], t3[1] = this.pts[1];
            return new e3(t3, Pe.toLineLabel(this._label));
          }, e3.prototype.isIsolated = function() {
            return this._isIsolated;
          }, e3.prototype.getCoordinates = function() {
            return this.pts;
          }, e3.prototype.setIsolated = function(t3) {
            this._isIsolated = t3;
          }, e3.prototype.setName = function(t3) {
            this._name = t3;
          }, e3.prototype.equals = function(t3) {
            if (!(t3 instanceof e3))
              return false;
            var n2 = t3;
            if (this.pts.length !== n2.pts.length)
              return false;
            for (var i2 = true, r2 = true, o2 = this.pts.length, s2 = 0; s2 < this.pts.length; s2++)
              if (this.pts[s2].equals2D(n2.pts[s2]) || (i2 = false), this.pts[s2].equals2D(n2.pts[--o2]) || (r2 = false), !i2 && !r2)
                return false;
            return true;
          }, e3.prototype.getCoordinate = function() {
            if (arguments.length === 0)
              return this.pts.length > 0 ? this.pts[0] : null;
            if (arguments.length === 1) {
              var t3 = arguments[0];
              return this.pts[t3];
            }
          }, e3.prototype.print = function(t3) {
            t3.print("edge " + this._name + ": "), t3.print("LINESTRING (");
            for (var e4 = 0; e4 < this.pts.length; e4++)
              e4 > 0 && t3.print(","), t3.print(this.pts[e4].x + " " + this.pts[e4].y);
            t3.print(")  " + this._label + " " + this._depthDelta);
          }, e3.prototype.computeIM = function(t3) {
            e3.updateIM(this._label, t3);
          }, e3.prototype.isCollapsed = function() {
            return !!this._label.isArea() && (this.pts.length === 3 && !!this.pts[0].equals(this.pts[2]));
          }, e3.prototype.isClosed = function() {
            return this.pts[0].equals(this.pts[this.pts.length - 1]);
          }, e3.prototype.getMaximumSegmentIndex = function() {
            return this.pts.length - 1;
          }, e3.prototype.getDepthDelta = function() {
            return this._depthDelta;
          }, e3.prototype.getNumPoints = function() {
            return this.pts.length;
          }, e3.prototype.printReverse = function(t3) {
            t3.print("edge " + this._name + ": ");
            for (var e4 = this.pts.length - 1; e4 >= 0; e4--)
              t3.print(this.pts[e4] + " ");
            t3.println("");
          }, e3.prototype.getMonotoneChainEdge = function() {
            return this._mce === null && (this._mce = new $n(this)), this._mce;
          }, e3.prototype.getEnvelope = function() {
            if (this._env === null) {
              this._env = new j();
              for (var t3 = 0; t3 < this.pts.length; t3++)
                this._env.expandToInclude(this.pts[t3]);
            }
            return this._env;
          }, e3.prototype.addIntersection = function(t3, e4, n2, i2) {
            var r2 = new C(t3.getIntersection(i2)), o2 = e4, s2 = t3.getEdgeDistance(n2, i2), a2 = o2 + 1;
            if (a2 < this.pts.length) {
              var u2 = this.pts[a2];
              r2.equals2D(u2) && (o2 = a2, s2 = 0);
            }
            this.eiList.add(r2, o2, s2);
          }, e3.prototype.toString = function() {
            var t3 = new D();
            t3.append("edge " + this._name + ": "), t3.append("LINESTRING (");
            for (var e4 = 0; e4 < this.pts.length; e4++)
              e4 > 0 && t3.append(","), t3.append(this.pts[e4].x + " " + this.pts[e4].y);
            return t3.append(")  " + this._label + " " + this._depthDelta), t3.toString();
          }, e3.prototype.isPointwiseEqual = function(t3) {
            if (this.pts.length !== t3.pts.length)
              return false;
            for (var e4 = 0; e4 < this.pts.length; e4++)
              if (!this.pts[e4].equals2D(t3.pts[e4]))
                return false;
            return true;
          }, e3.prototype.setDepthDelta = function(t3) {
            this._depthDelta = t3;
          }, e3.prototype.getEdgeIntersectionList = function() {
            return this.eiList;
          }, e3.prototype.addIntersections = function(t3, e4, n2) {
            for (var i2 = 0; i2 < t3.getIntersectionNum(); i2++)
              this.addIntersection(t3, e4, n2, i2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.updateIM = function() {
            if (arguments.length !== 2)
              return t2.prototype.updateIM.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1];
            n2.setAtLeastIfValid(e4.getLocation(0, Se.ON), e4.getLocation(1, Se.ON), 1), e4.isArea() && (n2.setAtLeastIfValid(e4.getLocation(0, Se.LEFT), e4.getLocation(1, Se.LEFT), 2), n2.setAtLeastIfValid(e4.getLocation(0, Se.RIGHT), e4.getLocation(1, Se.RIGHT), 2));
          }, e3;
        }(Fe), ii = function(t2) {
          this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Hn(), this._bufParams = t2 || null;
        };
        ii.prototype.setWorkingPrecisionModel = function(t2) {
          this._workingPrecisionModel = t2;
        }, ii.prototype.insertUniqueEdge = function(t2) {
          var e3 = this._edgeList.findEqualEdge(t2);
          if (e3 !== null) {
            var n2 = e3.getLabel(), i2 = t2.getLabel();
            e3.isPointwiseEqual(t2) || (i2 = new Pe(t2.getLabel())).flip(), n2.merge(i2);
            var r2 = ii.depthDelta(i2), o2 = e3.getDepthDelta() + r2;
            e3.setDepthDelta(o2);
          } else
            this._edgeList.add(t2), t2.setDepthDelta(ii.depthDelta(t2.getLabel()));
        }, ii.prototype.buildSubgraphs = function(t2, e3) {
          for (var n2 = new Nt(), i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next(), o2 = r2.getRightmostCoordinate(), s2 = new An(n2).getDepth(o2);
            r2.computeDepth(s2), r2.findResultEdges(), n2.add(r2), e3.add(r2.getDirectedEdges(), r2.getNodes());
          }
        }, ii.prototype.createSubgraphs = function(t2) {
          for (var e3 = new Nt(), n2 = t2.getNodes().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (!i2.isVisited()) {
              var r2 = new Te();
              r2.create(i2), e3.add(r2);
            }
          }
          return $e.sort(e3, $e.reverseOrder()), e3;
        }, ii.prototype.createEmptyResultGeometry = function() {
          return this._geomFact.createPolygon();
        }, ii.prototype.getNoder = function(t2) {
          if (this._workingNoder !== null)
            return this._workingNoder;
          var e3 = new xn(), n2 = new rt();
          return n2.setPrecisionModel(t2), e3.setSegmentIntersector(new Kn(n2)), e3;
        }, ii.prototype.buffer = function(t2, e3) {
          var n2 = this._workingPrecisionModel;
          n2 === null && (n2 = t2.getPrecisionModel()), this._geomFact = t2.getFactory();
          var i2 = new Mn(n2, this._bufParams), r2 = new Bn(t2, e3, i2).getCurves();
          if (r2.size() <= 0)
            return this.createEmptyResultGeometry();
          this.computeNodedEdges(r2, n2), this._graph = new Ye(new kn()), this._graph.addEdges(this._edgeList.getEdges());
          var o2 = this.createSubgraphs(this._graph), s2 = new ke(this._geomFact);
          this.buildSubgraphs(o2, s2);
          var a2 = s2.getPolygons();
          if (a2.size() <= 0)
            return this.createEmptyResultGeometry();
          return this._geomFact.buildGeometry(a2);
        }, ii.prototype.computeNodedEdges = function(t2, e3) {
          var n2 = this.getNoder(e3);
          n2.computeNodes(t2);
          for (var i2 = n2.getNodedSubstrings().iterator(); i2.hasNext(); ) {
            var r2 = i2.next(), o2 = r2.getCoordinates();
            if (o2.length !== 2 || !o2[0].equals2D(o2[1])) {
              var s2 = r2.getData(), a2 = new ni(r2.getCoordinates(), new Pe(s2));
              this.insertUniqueEdge(a2);
            }
          }
        }, ii.prototype.setNoder = function(t2) {
          this._workingNoder = t2;
        }, ii.prototype.interfaces_ = function() {
          return [];
        }, ii.prototype.getClass = function() {
          return ii;
        }, ii.depthDelta = function(t2) {
          var e3 = t2.getLocation(0, Se.LEFT), n2 = t2.getLocation(0, Se.RIGHT);
          return e3 === w.INTERIOR && n2 === w.EXTERIOR ? 1 : e3 === w.EXTERIOR && n2 === w.INTERIOR ? -1 : 0;
        }, ii.convertSegStrings = function(t2) {
          for (var e3 = new _e(), n2 = new Nt(); t2.hasNext(); ) {
            var i2 = t2.next(), r2 = e3.createLineString(i2.getCoordinates());
            n2.add(r2);
          }
          return e3.buildGeometry(n2);
        };
        var ri = function() {
          if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = false, arguments.length === 2) {
            var t2 = arguments[0], e3 = arguments[1];
            this._noder = t2, this._scaleFactor = e3, this._offsetX = 0, this._offsetY = 0, this._isScaled = !this.isIntegerPrecision();
          } else if (arguments.length === 4) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = arguments[3];
            this._noder = n2, this._scaleFactor = i2, this._offsetX = r2, this._offsetY = o2, this._isScaled = !this.isIntegerPrecision();
          }
        };
        ri.prototype.rescale = function() {
          if (T(arguments[0], It))
            for (var t2 = arguments[0].iterator(); t2.hasNext(); ) {
              var e3 = t2.next();
              this.rescale(e3.getCoordinates());
            }
          else if (arguments[0] instanceof Array) {
            for (var n2 = arguments[0], i2 = 0; i2 < n2.length; i2++)
              n2[i2].x = n2[i2].x / this._scaleFactor + this._offsetX, n2[i2].y = n2[i2].y / this._scaleFactor + this._offsetY;
            n2.length === 2 && n2[0].equals2D(n2[1]) && Y.out.println(n2);
          }
        }, ri.prototype.scale = function() {
          if (T(arguments[0], It)) {
            for (var t2 = arguments[0], e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
              var i2 = n2.next();
              e3.add(new gn(this.scale(i2.getCoordinates()), i2.getData()));
            }
            return e3;
          }
          if (arguments[0] instanceof Array) {
            for (var r2 = arguments[0], o2 = new Array(r2.length).fill(null), s2 = 0; s2 < r2.length; s2++)
              o2[s2] = new C(Math.round((r2[s2].x - this._offsetX) * this._scaleFactor), Math.round((r2[s2].y - this._offsetY) * this._scaleFactor), r2[s2].z);
            return Lt.removeRepeatedPoints(o2);
          }
        }, ri.prototype.isIntegerPrecision = function() {
          return this._scaleFactor === 1;
        }, ri.prototype.getNodedSubstrings = function() {
          var t2 = this._noder.getNodedSubstrings();
          return this._isScaled && this.rescale(t2), t2;
        }, ri.prototype.computeNodes = function(t2) {
          var e3 = t2;
          this._isScaled && (e3 = this.scale(t2)), this._noder.computeNodes(e3);
        }, ri.prototype.interfaces_ = function() {
          return [In];
        }, ri.prototype.getClass = function() {
          return ri;
        };
        var oi = function() {
          this._li = new rt(), this._segStrings = null;
          var t2 = arguments[0];
          this._segStrings = t2;
        }, si = { fact: { configurable: true } };
        oi.prototype.checkEndPtVertexIntersections = function() {
          if (arguments.length === 0)
            for (var t2 = this._segStrings.iterator(); t2.hasNext(); ) {
              var e3 = t2.next().getCoordinates();
              this.checkEndPtVertexIntersections(e3[0], this._segStrings), this.checkEndPtVertexIntersections(e3[e3.length - 1], this._segStrings);
            }
          else if (arguments.length === 2) {
            for (var n2 = arguments[0], i2 = arguments[1].iterator(); i2.hasNext(); )
              for (var r2 = i2.next().getCoordinates(), o2 = 1; o2 < r2.length - 1; o2++)
                if (r2[o2].equals(n2))
                  throw new $("found endpt/interior pt intersection at index " + o2 + " :pt " + n2);
          }
        }, oi.prototype.checkInteriorIntersections = function() {
          if (arguments.length === 0)
            for (var t2 = this._segStrings.iterator(); t2.hasNext(); )
              for (var e3 = t2.next(), n2 = this._segStrings.iterator(); n2.hasNext(); ) {
                var i2 = n2.next();
                this.checkInteriorIntersections(e3, i2);
              }
          else if (arguments.length === 2)
            for (var r2 = arguments[0], o2 = arguments[1], s2 = r2.getCoordinates(), a2 = o2.getCoordinates(), u2 = 0; u2 < s2.length - 1; u2++)
              for (var l2 = 0; l2 < a2.length - 1; l2++)
                this.checkInteriorIntersections(r2, u2, o2, l2);
          else if (arguments.length === 4) {
            var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = arguments[3];
            if (c2 === h2 && p2 === f2)
              return null;
            var g2 = c2.getCoordinates()[p2], d2 = c2.getCoordinates()[p2 + 1], y3 = h2.getCoordinates()[f2], _2 = h2.getCoordinates()[f2 + 1];
            if (this._li.computeIntersection(g2, d2, y3, _2), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, g2, d2) || this.hasInteriorIntersection(this._li, y3, _2)))
              throw new $("found non-noded intersection at " + g2 + "-" + d2 + " and " + y3 + "-" + _2);
          }
        }, oi.prototype.checkValid = function() {
          this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
        }, oi.prototype.checkCollapses = function() {
          if (arguments.length === 0)
            for (var t2 = this._segStrings.iterator(); t2.hasNext(); ) {
              var e3 = t2.next();
              this.checkCollapses(e3);
            }
          else if (arguments.length === 1)
            for (var n2 = arguments[0].getCoordinates(), i2 = 0; i2 < n2.length - 2; i2++)
              this.checkCollapse(n2[i2], n2[i2 + 1], n2[i2 + 2]);
        }, oi.prototype.hasInteriorIntersection = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.getIntersectionNum(); i2++) {
            var r2 = t2.getIntersection(i2);
            if (!r2.equals(e3) && !r2.equals(n2))
              return true;
          }
          return false;
        }, oi.prototype.checkCollapse = function(t2, e3, n2) {
          if (t2.equals(n2))
            throw new $("found non-noded collapse at " + oi.fact.createLineString([t2, e3, n2]));
        }, oi.prototype.interfaces_ = function() {
          return [];
        }, oi.prototype.getClass = function() {
          return oi;
        }, si.fact.get = function() {
          return new _e();
        }, Object.defineProperties(oi, si);
        var ai = function() {
          this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          if (this._originalPt = t2, this._pt = t2, this._scaleFactor = e3, this._li = n2, e3 <= 0)
            throw new m("Scale factor must be non-zero");
          e3 !== 1 && (this._pt = new C(this.scale(t2.x), this.scale(t2.y)), this._p0Scaled = new C(), this._p1Scaled = new C()), this.initCorners(this._pt);
        }, ui = { SAFE_ENV_EXPANSION_FACTOR: { configurable: true } };
        ai.prototype.intersectsScaled = function(t2, e3) {
          var n2 = Math.min(t2.x, e3.x), i2 = Math.max(t2.x, e3.x), r2 = Math.min(t2.y, e3.y), o2 = Math.max(t2.y, e3.y), s2 = this._maxx < n2 || this._minx > i2 || this._maxy < r2 || this._miny > o2;
          if (s2)
            return false;
          var a2 = this.intersectsToleranceSquare(t2, e3);
          return et.isTrue(!(s2 && a2), "Found bad envelope test"), a2;
        }, ai.prototype.initCorners = function(t2) {
          this._minx = t2.x - 0.5, this._maxx = t2.x + 0.5, this._miny = t2.y - 0.5, this._maxy = t2.y + 0.5, this._corner[0] = new C(this._maxx, this._maxy), this._corner[1] = new C(this._minx, this._maxy), this._corner[2] = new C(this._minx, this._miny), this._corner[3] = new C(this._maxx, this._miny);
        }, ai.prototype.intersects = function(t2, e3) {
          return this._scaleFactor === 1 ? this.intersectsScaled(t2, e3) : (this.copyScaled(t2, this._p0Scaled), this.copyScaled(e3, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
        }, ai.prototype.scale = function(t2) {
          return Math.round(t2 * this._scaleFactor);
        }, ai.prototype.getCoordinate = function() {
          return this._originalPt;
        }, ai.prototype.copyScaled = function(t2, e3) {
          e3.x = this.scale(t2.x), e3.y = this.scale(t2.y);
        }, ai.prototype.getSafeEnvelope = function() {
          if (this._safeEnv === null) {
            var t2 = ai.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
            this._safeEnv = new j(this._originalPt.x - t2, this._originalPt.x + t2, this._originalPt.y - t2, this._originalPt.y + t2);
          }
          return this._safeEnv;
        }, ai.prototype.intersectsPixelClosure = function(t2, e3) {
          return this._li.computeIntersection(t2, e3, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e3, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e3, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e3, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
        }, ai.prototype.intersectsToleranceSquare = function(t2, e3) {
          var n2 = false, i2 = false;
          return this._li.computeIntersection(t2, e3, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(t2, e3, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (n2 = true), this._li.computeIntersection(t2, e3, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (i2 = true), this._li.computeIntersection(t2, e3, this._corner[3], this._corner[0]), !!this._li.isProper() || (!(!n2 || !i2) || (!!t2.equals(this._pt) || !!e3.equals(this._pt))))));
        }, ai.prototype.addSnappedNode = function(t2, e3) {
          var n2 = t2.getCoordinate(e3), i2 = t2.getCoordinate(e3 + 1);
          return !!this.intersects(n2, i2) && (t2.addIntersection(this.getCoordinate(), e3), true);
        }, ai.prototype.interfaces_ = function() {
          return [];
        }, ai.prototype.getClass = function() {
          return ai;
        }, ui.SAFE_ENV_EXPANSION_FACTOR.get = function() {
          return 0.75;
        }, Object.defineProperties(ai, ui);
        var li = function() {
          this.tempEnv1 = new j(), this.selectedSegment = new dn();
        };
        li.prototype.select = function() {
          if (arguments.length === 1)
            ;
          else if (arguments.length === 2) {
            var t2 = arguments[0], e3 = arguments[1];
            t2.getLineSegment(e3, this.selectedSegment), this.select(this.selectedSegment);
          }
        }, li.prototype.interfaces_ = function() {
          return [];
        }, li.prototype.getClass = function() {
          return li;
        };
        var ci = function() {
          this._index = null;
          var t2 = arguments[0];
          this._index = t2;
        }, pi2 = { HotPixelSnapAction: { configurable: true } };
        ci.prototype.snap = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return this.snap(t2, null, -1);
          }
          if (arguments.length === 3) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = e3.getSafeEnvelope(), o2 = new hi(e3, n2, i2);
            return this._index.query(r2, { interfaces_: function() {
              return [Ke];
            }, visitItem: function(t3) {
              t3.select(r2, o2);
            } }), o2.isNodeAdded();
          }
        }, ci.prototype.interfaces_ = function() {
          return [];
        }, ci.prototype.getClass = function() {
          return ci;
        }, pi2.HotPixelSnapAction.get = function() {
          return hi;
        }, Object.defineProperties(ci, pi2);
        var hi = function(t2) {
          function e3() {
            t2.call(this), this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = false;
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            this._hotPixel = e4, this._parentEdge = n2, this._hotPixelVertexIndex = i2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.isNodeAdded = function() {
            return this._isNodeAdded;
          }, e3.prototype.select = function() {
            if (arguments.length !== 2)
              return t2.prototype.select.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1], i2 = e4.getContext();
            if (this._parentEdge !== null && i2 === this._parentEdge && n2 === this._hotPixelVertexIndex)
              return null;
            this._isNodeAdded = this._hotPixel.addSnappedNode(i2, n2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(li), fi = function() {
          this._li = null, this._interiorIntersections = null;
          var t2 = arguments[0];
          this._li = t2, this._interiorIntersections = new Nt();
        };
        fi.prototype.processIntersections = function(t2, e3, n2, i2) {
          if (t2 === n2 && e3 === i2)
            return null;
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
          if (this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
            for (var u2 = 0; u2 < this._li.getIntersectionNum(); u2++)
              this._interiorIntersections.add(this._li.getIntersection(u2));
            t2.addIntersections(this._li, e3, 0), n2.addIntersections(this._li, i2, 1);
          }
        }, fi.prototype.isDone = function() {
          return false;
        }, fi.prototype.getInteriorIntersections = function() {
          return this._interiorIntersections;
        }, fi.prototype.interfaces_ = function() {
          return [Wn];
        }, fi.prototype.getClass = function() {
          return fi;
        };
        var gi = function() {
          this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
          var t2 = arguments[0];
          this._pm = t2, this._li = new rt(), this._li.setPrecisionModel(t2), this._scaleFactor = t2.getScale();
        };
        gi.prototype.checkCorrectness = function(t2) {
          var e3 = gn.getNodedSubstrings(t2), n2 = new oi(e3);
          try {
            n2.checkValid();
          } catch (t3) {
            if (!(t3 instanceof z))
              throw t3;
            t3.printStackTrace();
          }
        }, gi.prototype.getNodedSubstrings = function() {
          return gn.getNodedSubstrings(this._nodedSegStrings);
        }, gi.prototype.snapRound = function(t2, e3) {
          var n2 = this.findInteriorIntersections(t2, e3);
          this.computeIntersectionSnaps(n2), this.computeVertexSnaps(t2);
        }, gi.prototype.findInteriorIntersections = function(t2, e3) {
          var n2 = new fi(e3);
          return this._noder.setSegmentIntersector(n2), this._noder.computeNodes(t2), n2.getInteriorIntersections();
        }, gi.prototype.computeVertexSnaps = function() {
          if (T(arguments[0], It))
            for (var t2 = arguments[0].iterator(); t2.hasNext(); ) {
              var e3 = t2.next();
              this.computeVertexSnaps(e3);
            }
          else if (arguments[0] instanceof gn)
            for (var n2 = arguments[0], i2 = n2.getCoordinates(), r2 = 0; r2 < i2.length; r2++) {
              var o2 = new ai(i2[r2], this._scaleFactor, this._li);
              this._pointSnapper.snap(o2, n2, r2) && n2.addIntersection(i2[r2], r2);
            }
        }, gi.prototype.computeNodes = function(t2) {
          this._nodedSegStrings = t2, this._noder = new xn(), this._pointSnapper = new ci(this._noder.getIndex()), this.snapRound(t2, this._li);
        }, gi.prototype.computeIntersectionSnaps = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = new ai(n2, this._scaleFactor, this._li);
            this._pointSnapper.snap(i2);
          }
        }, gi.prototype.interfaces_ = function() {
          return [In];
        }, gi.prototype.getClass = function() {
          return gi;
        };
        var di = function() {
          if (this._argGeom = null, this._distance = null, this._bufParams = new Cn(), this._resultGeometry = null, this._saveException = null, arguments.length === 1) {
            var t2 = arguments[0];
            this._argGeom = t2;
          } else if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            this._argGeom = e3, this._bufParams = n2;
          }
        }, yi = { CAP_ROUND: { configurable: true }, CAP_BUTT: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, MAX_PRECISION_DIGITS: { configurable: true } };
        di.prototype.bufferFixedPrecision = function(t2) {
          var e3 = new ri(new gi(new fe(1)), t2.getScale()), n2 = new ii(this._bufParams);
          n2.setWorkingPrecisionModel(t2), n2.setNoder(e3), this._resultGeometry = n2.buffer(this._argGeom, this._distance);
        }, di.prototype.bufferReducedPrecision = function() {
          var t2 = this;
          if (arguments.length === 0) {
            for (var e3 = di.MAX_PRECISION_DIGITS; e3 >= 0; e3--) {
              try {
                t2.bufferReducedPrecision(e3);
              } catch (e4) {
                if (!(e4 instanceof we))
                  throw e4;
                t2._saveException = e4;
              }
              if (t2._resultGeometry !== null)
                return null;
            }
            throw this._saveException;
          }
          if (arguments.length === 1) {
            var n2 = arguments[0], i2 = di.precisionScaleFactor(this._argGeom, this._distance, n2), r2 = new fe(i2);
            this.bufferFixedPrecision(r2);
          }
        }, di.prototype.computeGeometry = function() {
          if (this.bufferOriginalPrecision(), this._resultGeometry !== null)
            return null;
          var t2 = this._argGeom.getFactory().getPrecisionModel();
          t2.getType() === fe.FIXED ? this.bufferFixedPrecision(t2) : this.bufferReducedPrecision();
        }, di.prototype.setQuadrantSegments = function(t2) {
          this._bufParams.setQuadrantSegments(t2);
        }, di.prototype.bufferOriginalPrecision = function() {
          try {
            var t2 = new ii(this._bufParams);
            this._resultGeometry = t2.buffer(this._argGeom, this._distance);
          } catch (t3) {
            if (!(t3 instanceof $))
              throw t3;
            this._saveException = t3;
          }
        }, di.prototype.getResultGeometry = function(t2) {
          return this._distance = t2, this.computeGeometry(), this._resultGeometry;
        }, di.prototype.setEndCapStyle = function(t2) {
          this._bufParams.setEndCapStyle(t2);
        }, di.prototype.interfaces_ = function() {
          return [];
        }, di.prototype.getClass = function() {
          return di;
        }, di.bufferOp = function() {
          if (arguments.length === 2) {
            var t2 = arguments[0], e3 = arguments[1];
            return new di(t2).getResultGeometry(e3);
          }
          if (arguments.length === 3) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof ct && typeof arguments[1] == "number") {
              var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new di(n2);
              o2.setQuadrantSegments(r2);
              return o2.getResultGeometry(i2);
            }
            if (arguments[2] instanceof Cn && arguments[0] instanceof ct && typeof arguments[1] == "number") {
              var s2 = arguments[0], a2 = arguments[1], u2 = arguments[2];
              return new di(s2, u2).getResultGeometry(a2);
            }
          } else if (arguments.length === 4) {
            var l2 = arguments[0], c2 = arguments[1], p2 = arguments[2], h2 = arguments[3], f2 = new di(l2);
            f2.setQuadrantSegments(p2), f2.setEndCapStyle(h2);
            return f2.getResultGeometry(c2);
          }
        }, di.precisionScaleFactor = function(t2, e3, n2) {
          var i2 = t2.getEnvelopeInternal(), r2 = R.max(Math.abs(i2.getMaxX()), Math.abs(i2.getMaxY()), Math.abs(i2.getMinX()), Math.abs(i2.getMinY())) + 2 * (e3 > 0 ? e3 : 0), o2 = n2 - Math.trunc(Math.log(r2) / Math.log(10) + 1);
          return Math.pow(10, o2);
        }, yi.CAP_ROUND.get = function() {
          return Cn.CAP_ROUND;
        }, yi.CAP_BUTT.get = function() {
          return Cn.CAP_FLAT;
        }, yi.CAP_FLAT.get = function() {
          return Cn.CAP_FLAT;
        }, yi.CAP_SQUARE.get = function() {
          return Cn.CAP_SQUARE;
        }, yi.MAX_PRECISION_DIGITS.get = function() {
          return 12;
        }, Object.defineProperties(di, yi);
        var _i = function() {
          this._pt = [new C(), new C()], this._distance = v.NaN, this._isNull = true;
        };
        _i.prototype.getCoordinates = function() {
          return this._pt;
        }, _i.prototype.getCoordinate = function(t2) {
          return this._pt[t2];
        }, _i.prototype.setMinimum = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            this.setMinimum(t2._pt[0], t2._pt[1]);
          } else if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 < this._distance && this.initialize(e3, n2, i2);
          }
        }, _i.prototype.initialize = function() {
          if (arguments.length === 0)
            this._isNull = true;
          else if (arguments.length === 2) {
            var t2 = arguments[0], e3 = arguments[1];
            this._pt[0].setCoordinate(t2), this._pt[1].setCoordinate(e3), this._distance = t2.distance(e3), this._isNull = false;
          } else if (arguments.length === 3) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this._pt[0].setCoordinate(n2), this._pt[1].setCoordinate(i2), this._distance = r2, this._isNull = false;
          }
        }, _i.prototype.getDistance = function() {
          return this._distance;
        }, _i.prototype.setMaximum = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            this.setMaximum(t2._pt[0], t2._pt[1]);
          } else if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 > this._distance && this.initialize(e3, n2, i2);
          }
        }, _i.prototype.interfaces_ = function() {
          return [];
        }, _i.prototype.getClass = function() {
          return _i;
        };
        var mi = function() {
        };
        mi.prototype.interfaces_ = function() {
          return [];
        }, mi.prototype.getClass = function() {
          return mi;
        }, mi.computeDistance = function() {
          if (arguments[2] instanceof _i && arguments[0] instanceof Kt && arguments[1] instanceof C)
            for (var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = t2.getCoordinates(), r2 = new dn(), o2 = 0; o2 < i2.length - 1; o2++) {
              r2.setCoordinates(i2[o2], i2[o2 + 1]);
              var s2 = r2.closestPoint(e3);
              n2.setMinimum(s2, e3);
            }
          else if (arguments[2] instanceof _i && arguments[0] instanceof $t && arguments[1] instanceof C) {
            var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2];
            mi.computeDistance(a2.getExteriorRing(), u2, l2);
            for (var c2 = 0; c2 < a2.getNumInteriorRing(); c2++)
              mi.computeDistance(a2.getInteriorRingN(c2), u2, l2);
          } else if (arguments[2] instanceof _i && arguments[0] instanceof ct && arguments[1] instanceof C) {
            var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2];
            if (p2 instanceof Kt)
              mi.computeDistance(p2, h2, f2);
            else if (p2 instanceof $t)
              mi.computeDistance(p2, h2, f2);
            else if (p2 instanceof zt)
              for (var g2 = p2, d2 = 0; d2 < g2.getNumGeometries(); d2++) {
                var y3 = g2.getGeometryN(d2);
                mi.computeDistance(y3, h2, f2);
              }
            else
              f2.setMinimum(p2.getCoordinate(), h2);
          } else if (arguments[2] instanceof _i && arguments[0] instanceof dn && arguments[1] instanceof C) {
            var _2 = arguments[0], m2 = arguments[1], v2 = arguments[2], I2 = _2.closestPoint(m2);
            v2.setMinimum(I2, m2);
          }
        };
        var vi = function(t2) {
          this._maxPtDist = new _i(), this._inputGeom = t2 || null;
        }, Ii = { MaxPointDistanceFilter: { configurable: true }, MaxMidpointDistanceFilter: { configurable: true } };
        vi.prototype.computeMaxMidpointDistance = function(t2) {
          var e3 = new xi(this._inputGeom);
          t2.apply(e3), this._maxPtDist.setMaximum(e3.getMaxPointDistance());
        }, vi.prototype.computeMaxVertexDistance = function(t2) {
          var e3 = new Ei(this._inputGeom);
          t2.apply(e3), this._maxPtDist.setMaximum(e3.getMaxPointDistance());
        }, vi.prototype.findDistance = function(t2) {
          return this.computeMaxVertexDistance(t2), this.computeMaxMidpointDistance(t2), this._maxPtDist.getDistance();
        }, vi.prototype.getDistancePoints = function() {
          return this._maxPtDist;
        }, vi.prototype.interfaces_ = function() {
          return [];
        }, vi.prototype.getClass = function() {
          return vi;
        }, Ii.MaxPointDistanceFilter.get = function() {
          return Ei;
        }, Ii.MaxMidpointDistanceFilter.get = function() {
          return xi;
        }, Object.defineProperties(vi, Ii);
        var Ei = function(t2) {
          this._maxPtDist = new _i(), this._minPtDist = new _i(), this._geom = t2 || null;
        };
        Ei.prototype.filter = function(t2) {
          this._minPtDist.initialize(), mi.computeDistance(this._geom, t2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }, Ei.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, Ei.prototype.interfaces_ = function() {
          return [ft];
        }, Ei.prototype.getClass = function() {
          return Ei;
        };
        var xi = function(t2) {
          this._maxPtDist = new _i(), this._minPtDist = new _i(), this._geom = t2 || null;
        };
        xi.prototype.filter = function(t2, e3) {
          if (e3 === 0)
            return null;
          var n2 = t2.getCoordinate(e3 - 1), i2 = t2.getCoordinate(e3), r2 = new C((n2.x + i2.x) / 2, (n2.y + i2.y) / 2);
          this._minPtDist.initialize(), mi.computeDistance(this._geom, r2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }, xi.prototype.isDone = function() {
          return false;
        }, xi.prototype.isGeometryChanged = function() {
          return false;
        }, xi.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, xi.prototype.interfaces_ = function() {
          return [Ut];
        }, xi.prototype.getClass = function() {
          return xi;
        };
        var Ni = function(t2) {
          this._comps = t2 || null;
        };
        Ni.prototype.filter = function(t2) {
          t2 instanceof $t && this._comps.add(t2);
        }, Ni.prototype.interfaces_ = function() {
          return [Vt];
        }, Ni.prototype.getClass = function() {
          return Ni;
        }, Ni.getPolygons = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return Ni.getPolygons(t2, new Nt());
          }
          if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3 instanceof $t ? n2.add(e3) : e3 instanceof zt && e3.apply(new Ni(n2)), n2;
          }
        };
        var Ci = function() {
          if (this._lines = null, this._isForcedToLineString = false, arguments.length === 1) {
            var t2 = arguments[0];
            this._lines = t2;
          } else if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            this._lines = e3, this._isForcedToLineString = n2;
          }
        };
        Ci.prototype.filter = function(t2) {
          if (this._isForcedToLineString && t2 instanceof ee) {
            var e3 = t2.getFactory().createLineString(t2.getCoordinateSequence());
            return this._lines.add(e3), null;
          }
          t2 instanceof Kt && this._lines.add(t2);
        }, Ci.prototype.setForceToLineString = function(t2) {
          this._isForcedToLineString = t2;
        }, Ci.prototype.interfaces_ = function() {
          return [lt];
        }, Ci.prototype.getClass = function() {
          return Ci;
        }, Ci.getGeometry = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return t2.getFactory().buildGeometry(Ci.getLines(t2));
          }
          if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3.getFactory().buildGeometry(Ci.getLines(e3, n2));
          }
        }, Ci.getLines = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return Ci.getLines(t2, false);
          }
          if (arguments.length === 2) {
            if (T(arguments[0], It) && T(arguments[1], It)) {
              for (var e3 = arguments[0], n2 = arguments[1], i2 = e3.iterator(); i2.hasNext(); ) {
                var r2 = i2.next();
                Ci.getLines(r2, n2);
              }
              return n2;
            }
            if (arguments[0] instanceof ct && typeof arguments[1] == "boolean") {
              var o2 = arguments[0], s2 = arguments[1], a2 = new Nt();
              return o2.apply(new Ci(a2, s2)), a2;
            }
            if (arguments[0] instanceof ct && T(arguments[1], It)) {
              var u2 = arguments[0], l2 = arguments[1];
              return u2 instanceof Kt ? l2.add(u2) : u2.apply(new Ci(l2)), l2;
            }
          } else if (arguments.length === 3) {
            if (typeof arguments[2] == "boolean" && T(arguments[0], It) && T(arguments[1], It)) {
              for (var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = c2.iterator(); f2.hasNext(); ) {
                var g2 = f2.next();
                Ci.getLines(g2, p2, h2);
              }
              return p2;
            }
            if (typeof arguments[2] == "boolean" && arguments[0] instanceof ct && T(arguments[1], It)) {
              var d2 = arguments[0], y3 = arguments[1], _2 = arguments[2];
              return d2.apply(new Ci(y3, _2)), y3;
            }
          }
        };
        var Si = function() {
          if (this._boundaryRule = gt.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, arguments.length === 0)
            ;
          else if (arguments.length === 1) {
            var t2 = arguments[0];
            if (t2 === null)
              throw new m("Rule must be non-null");
            this._boundaryRule = t2;
          }
        };
        Si.prototype.locateInternal = function() {
          if (arguments[0] instanceof C && arguments[1] instanceof $t) {
            var t2 = arguments[0], e3 = arguments[1];
            if (e3.isEmpty())
              return w.EXTERIOR;
            var n2 = e3.getExteriorRing(), i2 = this.locateInPolygonRing(t2, n2);
            if (i2 === w.EXTERIOR)
              return w.EXTERIOR;
            if (i2 === w.BOUNDARY)
              return w.BOUNDARY;
            for (var r2 = 0; r2 < e3.getNumInteriorRing(); r2++) {
              var o2 = e3.getInteriorRingN(r2), s2 = this.locateInPolygonRing(t2, o2);
              if (s2 === w.INTERIOR)
                return w.EXTERIOR;
              if (s2 === w.BOUNDARY)
                return w.BOUNDARY;
            }
            return w.INTERIOR;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof Kt) {
            var a2 = arguments[0], u2 = arguments[1];
            if (!u2.getEnvelopeInternal().intersects(a2))
              return w.EXTERIOR;
            var l2 = u2.getCoordinates();
            return u2.isClosed() || !a2.equals(l2[0]) && !a2.equals(l2[l2.length - 1]) ? at.isOnLine(a2, l2) ? w.INTERIOR : w.EXTERIOR : w.BOUNDARY;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof Qt) {
            var c2 = arguments[0];
            return arguments[1].getCoordinate().equals2D(c2) ? w.INTERIOR : w.EXTERIOR;
          }
        }, Si.prototype.locateInPolygonRing = function(t2, e3) {
          return e3.getEnvelopeInternal().intersects(t2) ? at.locatePointInRing(t2, e3.getCoordinates()) : w.EXTERIOR;
        }, Si.prototype.intersects = function(t2, e3) {
          return this.locate(t2, e3) !== w.EXTERIOR;
        }, Si.prototype.updateLocationInfo = function(t2) {
          t2 === w.INTERIOR && (this._isIn = true), t2 === w.BOUNDARY && this._numBoundaries++;
        }, Si.prototype.computeLocation = function(t2, e3) {
          if (e3 instanceof Qt && this.updateLocationInfo(this.locateInternal(t2, e3)), e3 instanceof Kt)
            this.updateLocationInfo(this.locateInternal(t2, e3));
          else if (e3 instanceof $t)
            this.updateLocationInfo(this.locateInternal(t2, e3));
          else if (e3 instanceof Xt)
            for (var n2 = e3, i2 = 0; i2 < n2.getNumGeometries(); i2++) {
              var r2 = n2.getGeometryN(i2);
              this.updateLocationInfo(this.locateInternal(t2, r2));
            }
          else if (e3 instanceof ne)
            for (var o2 = e3, s2 = 0; s2 < o2.getNumGeometries(); s2++) {
              var a2 = o2.getGeometryN(s2);
              this.updateLocationInfo(this.locateInternal(t2, a2));
            }
          else if (e3 instanceof zt)
            for (var u2 = new Un(e3); u2.hasNext(); ) {
              var l2 = u2.next();
              l2 !== e3 && this.computeLocation(t2, l2);
            }
        }, Si.prototype.locate = function(t2, e3) {
          return e3.isEmpty() ? w.EXTERIOR : e3 instanceof Kt ? this.locateInternal(t2, e3) : e3 instanceof $t ? this.locateInternal(t2, e3) : (this._isIn = false, this._numBoundaries = 0, this.computeLocation(t2, e3), this._boundaryRule.isInBoundary(this._numBoundaries) ? w.BOUNDARY : this._numBoundaries > 0 || this._isIn ? w.INTERIOR : w.EXTERIOR);
        }, Si.prototype.interfaces_ = function() {
          return [];
        }, Si.prototype.getClass = function() {
          return Si;
        };
        var Li = function t2() {
          if (this._component = null, this._segIndex = null, this._pt = null, arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            t2.call(this, e3, t2.INSIDE_AREA, n2);
          } else if (arguments.length === 3) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            this._component = i2, this._segIndex = r2, this._pt = o2;
          }
        }, bi = { INSIDE_AREA: { configurable: true } };
        Li.prototype.isInsideArea = function() {
          return this._segIndex === Li.INSIDE_AREA;
        }, Li.prototype.getCoordinate = function() {
          return this._pt;
        }, Li.prototype.getGeometryComponent = function() {
          return this._component;
        }, Li.prototype.getSegmentIndex = function() {
          return this._segIndex;
        }, Li.prototype.interfaces_ = function() {
          return [];
        }, Li.prototype.getClass = function() {
          return Li;
        }, bi.INSIDE_AREA.get = function() {
          return -1;
        }, Object.defineProperties(Li, bi);
        var wi = function(t2) {
          this._pts = t2 || null;
        };
        wi.prototype.filter = function(t2) {
          t2 instanceof Qt && this._pts.add(t2);
        }, wi.prototype.interfaces_ = function() {
          return [Vt];
        }, wi.prototype.getClass = function() {
          return wi;
        }, wi.getPoints = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return t2 instanceof Qt ? $e.singletonList(t2) : wi.getPoints(t2, new Nt());
          }
          if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3 instanceof Qt ? n2.add(e3) : e3 instanceof zt && e3.apply(new wi(n2)), n2;
          }
        };
        var Oi = function() {
          this._locations = null;
          var t2 = arguments[0];
          this._locations = t2;
        };
        Oi.prototype.filter = function(t2) {
          (t2 instanceof Qt || t2 instanceof Kt || t2 instanceof $t) && this._locations.add(new Li(t2, 0, t2.getCoordinate()));
        }, Oi.prototype.interfaces_ = function() {
          return [Vt];
        }, Oi.prototype.getClass = function() {
          return Oi;
        }, Oi.getLocations = function(t2) {
          var e3 = new Nt();
          return t2.apply(new Oi(e3)), e3;
        };
        var Ti = function() {
          if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new Si(), this._minDistanceLocation = null, this._minDistance = v.MAX_VALUE, arguments.length === 2) {
            var t2 = arguments[0], e3 = arguments[1];
            this._geom = [t2, e3], this._terminateDistance = 0;
          } else if (arguments.length === 3) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this._geom = new Array(2).fill(null), this._geom[0] = n2, this._geom[1] = i2, this._terminateDistance = r2;
          }
        };
        Ti.prototype.computeContainmentDistance = function() {
          if (arguments.length === 0) {
            var t2 = new Array(2).fill(null);
            if (this.computeContainmentDistance(0, t2), this._minDistance <= this._terminateDistance)
              return null;
            this.computeContainmentDistance(1, t2);
          } else if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1], i2 = 1 - e3, r2 = Ni.getPolygons(this._geom[e3]);
            if (r2.size() > 0) {
              var o2 = Oi.getLocations(this._geom[i2]);
              if (this.computeContainmentDistance(o2, r2, n2), this._minDistance <= this._terminateDistance)
                return this._minDistanceLocation[i2] = n2[0], this._minDistanceLocation[e3] = n2[1], null;
            }
          } else if (arguments.length === 3) {
            if (arguments[2] instanceof Array && T(arguments[0], xt) && T(arguments[1], xt)) {
              for (var s2 = arguments[0], a2 = arguments[1], u2 = arguments[2], l2 = 0; l2 < s2.size(); l2++)
                for (var c2 = s2.get(l2), p2 = 0; p2 < a2.size(); p2++)
                  if (this.computeContainmentDistance(c2, a2.get(p2), u2), this._minDistance <= this._terminateDistance)
                    return null;
            } else if (arguments[2] instanceof Array && arguments[0] instanceof Li && arguments[1] instanceof $t) {
              var h2 = arguments[0], f2 = arguments[1], g2 = arguments[2], d2 = h2.getCoordinate();
              if (w.EXTERIOR !== this._ptLocator.locate(d2, f2))
                return this._minDistance = 0, g2[0] = h2, g2[1] = new Li(f2, d2), null;
            }
          }
        }, Ti.prototype.computeMinDistanceLinesPoints = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.size(); i2++)
            for (var r2 = t2.get(i2), o2 = 0; o2 < e3.size(); o2++) {
              var s2 = e3.get(o2);
              if (this.computeMinDistance(r2, s2, n2), this._minDistance <= this._terminateDistance)
                return null;
            }
        }, Ti.prototype.computeFacetDistance = function() {
          var t2 = new Array(2).fill(null), e3 = Ci.getLines(this._geom[0]), n2 = Ci.getLines(this._geom[1]), i2 = wi.getPoints(this._geom[0]), r2 = wi.getPoints(this._geom[1]);
          return this.computeMinDistanceLines(e3, n2, t2), this.updateMinDistance(t2, false), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistanceLinesPoints(e3, r2, t2), this.updateMinDistance(t2, false), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistanceLinesPoints(n2, i2, t2), this.updateMinDistance(t2, true), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistancePoints(i2, r2, t2), void this.updateMinDistance(t2, false))));
        }, Ti.prototype.nearestLocations = function() {
          return this.computeMinDistance(), this._minDistanceLocation;
        }, Ti.prototype.updateMinDistance = function(t2, e3) {
          if (t2[0] === null)
            return null;
          e3 ? (this._minDistanceLocation[0] = t2[1], this._minDistanceLocation[1] = t2[0]) : (this._minDistanceLocation[0] = t2[0], this._minDistanceLocation[1] = t2[1]);
        }, Ti.prototype.nearestPoints = function() {
          this.computeMinDistance();
          return [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
        }, Ti.prototype.computeMinDistance = function() {
          if (arguments.length === 0) {
            if (this._minDistanceLocation !== null)
              return null;
            if (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance)
              return null;
            this.computeFacetDistance();
          } else if (arguments.length === 3) {
            if (arguments[2] instanceof Array && arguments[0] instanceof Kt && arguments[1] instanceof Qt) {
              var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
              if (t2.getEnvelopeInternal().distance(e3.getEnvelopeInternal()) > this._minDistance)
                return null;
              for (var i2 = t2.getCoordinates(), r2 = e3.getCoordinate(), o2 = 0; o2 < i2.length - 1; o2++) {
                var s2 = at.distancePointLine(r2, i2[o2], i2[o2 + 1]);
                if (s2 < this._minDistance) {
                  this._minDistance = s2;
                  var a2 = new dn(i2[o2], i2[o2 + 1]).closestPoint(r2);
                  n2[0] = new Li(t2, o2, a2), n2[1] = new Li(e3, 0, r2);
                }
                if (this._minDistance <= this._terminateDistance)
                  return null;
              }
            } else if (arguments[2] instanceof Array && arguments[0] instanceof Kt && arguments[1] instanceof Kt) {
              var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2];
              if (u2.getEnvelopeInternal().distance(l2.getEnvelopeInternal()) > this._minDistance)
                return null;
              for (var p2 = u2.getCoordinates(), h2 = l2.getCoordinates(), f2 = 0; f2 < p2.length - 1; f2++)
                for (var g2 = 0; g2 < h2.length - 1; g2++) {
                  var d2 = at.distanceLineLine(p2[f2], p2[f2 + 1], h2[g2], h2[g2 + 1]);
                  if (d2 < this._minDistance) {
                    this._minDistance = d2;
                    var y3 = new dn(p2[f2], p2[f2 + 1]), _2 = new dn(h2[g2], h2[g2 + 1]), m2 = y3.closestPoints(_2);
                    c2[0] = new Li(u2, f2, m2[0]), c2[1] = new Li(l2, g2, m2[1]);
                  }
                  if (this._minDistance <= this._terminateDistance)
                    return null;
                }
            }
          }
        }, Ti.prototype.computeMinDistancePoints = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.size(); i2++)
            for (var r2 = t2.get(i2), o2 = 0; o2 < e3.size(); o2++) {
              var s2 = e3.get(o2), a2 = r2.getCoordinate().distance(s2.getCoordinate());
              if (a2 < this._minDistance && (this._minDistance = a2, n2[0] = new Li(r2, 0, r2.getCoordinate()), n2[1] = new Li(s2, 0, s2.getCoordinate())), this._minDistance <= this._terminateDistance)
                return null;
            }
        }, Ti.prototype.distance = function() {
          if (this._geom[0] === null || this._geom[1] === null)
            throw new m("null geometries are not supported");
          return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance);
        }, Ti.prototype.computeMinDistanceLines = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.size(); i2++)
            for (var r2 = t2.get(i2), o2 = 0; o2 < e3.size(); o2++) {
              var s2 = e3.get(o2);
              if (this.computeMinDistance(r2, s2, n2), this._minDistance <= this._terminateDistance)
                return null;
            }
        }, Ti.prototype.interfaces_ = function() {
          return [];
        }, Ti.prototype.getClass = function() {
          return Ti;
        }, Ti.distance = function(t2, e3) {
          return new Ti(t2, e3).distance();
        }, Ti.isWithinDistance = function(t2, e3, n2) {
          return new Ti(t2, e3, n2).distance() <= n2;
        }, Ti.nearestPoints = function(t2, e3) {
          return new Ti(t2, e3).nearestPoints();
        };
        var Ri = function() {
          this._pt = [new C(), new C()], this._distance = v.NaN, this._isNull = true;
        };
        Ri.prototype.getCoordinates = function() {
          return this._pt;
        }, Ri.prototype.getCoordinate = function(t2) {
          return this._pt[t2];
        }, Ri.prototype.setMinimum = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            this.setMinimum(t2._pt[0], t2._pt[1]);
          } else if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 < this._distance && this.initialize(e3, n2, i2);
          }
        }, Ri.prototype.initialize = function() {
          if (arguments.length === 0)
            this._isNull = true;
          else if (arguments.length === 2) {
            var t2 = arguments[0], e3 = arguments[1];
            this._pt[0].setCoordinate(t2), this._pt[1].setCoordinate(e3), this._distance = t2.distance(e3), this._isNull = false;
          } else if (arguments.length === 3) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this._pt[0].setCoordinate(n2), this._pt[1].setCoordinate(i2), this._distance = r2, this._isNull = false;
          }
        }, Ri.prototype.toString = function() {
          return Z.toLineString(this._pt[0], this._pt[1]);
        }, Ri.prototype.getDistance = function() {
          return this._distance;
        }, Ri.prototype.setMaximum = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            this.setMaximum(t2._pt[0], t2._pt[1]);
          } else if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 > this._distance && this.initialize(e3, n2, i2);
          }
        }, Ri.prototype.interfaces_ = function() {
          return [];
        }, Ri.prototype.getClass = function() {
          return Ri;
        };
        var Pi = function() {
        };
        Pi.prototype.interfaces_ = function() {
          return [];
        }, Pi.prototype.getClass = function() {
          return Pi;
        }, Pi.computeDistance = function() {
          if (arguments[2] instanceof Ri && arguments[0] instanceof Kt && arguments[1] instanceof C)
            for (var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = new dn(), r2 = t2.getCoordinates(), o2 = 0; o2 < r2.length - 1; o2++) {
              i2.setCoordinates(r2[o2], r2[o2 + 1]);
              var s2 = i2.closestPoint(e3);
              n2.setMinimum(s2, e3);
            }
          else if (arguments[2] instanceof Ri && arguments[0] instanceof $t && arguments[1] instanceof C) {
            var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2];
            Pi.computeDistance(a2.getExteriorRing(), u2, l2);
            for (var c2 = 0; c2 < a2.getNumInteriorRing(); c2++)
              Pi.computeDistance(a2.getInteriorRingN(c2), u2, l2);
          } else if (arguments[2] instanceof Ri && arguments[0] instanceof ct && arguments[1] instanceof C) {
            var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2];
            if (p2 instanceof Kt)
              Pi.computeDistance(p2, h2, f2);
            else if (p2 instanceof $t)
              Pi.computeDistance(p2, h2, f2);
            else if (p2 instanceof zt)
              for (var g2 = p2, d2 = 0; d2 < g2.getNumGeometries(); d2++) {
                var y3 = g2.getGeometryN(d2);
                Pi.computeDistance(y3, h2, f2);
              }
            else
              f2.setMinimum(p2.getCoordinate(), h2);
          } else if (arguments[2] instanceof Ri && arguments[0] instanceof dn && arguments[1] instanceof C) {
            var _2 = arguments[0], m2 = arguments[1], v2 = arguments[2], I2 = _2.closestPoint(m2);
            v2.setMinimum(I2, m2);
          }
        };
        var Di = function() {
          this._g0 = null, this._g1 = null, this._ptDist = new Ri(), this._densifyFrac = 0;
          var t2 = arguments[0], e3 = arguments[1];
          this._g0 = t2, this._g1 = e3;
        }, Mi = { MaxPointDistanceFilter: { configurable: true }, MaxDensifiedByFractionDistanceFilter: { configurable: true } };
        Di.prototype.getCoordinates = function() {
          return this._ptDist.getCoordinates();
        }, Di.prototype.setDensifyFraction = function(t2) {
          if (t2 > 1 || t2 <= 0)
            throw new m("Fraction is not in range (0.0 - 1.0]");
          this._densifyFrac = t2;
        }, Di.prototype.compute = function(t2, e3) {
          this.computeOrientedDistance(t2, e3, this._ptDist), this.computeOrientedDistance(e3, t2, this._ptDist);
        }, Di.prototype.distance = function() {
          return this.compute(this._g0, this._g1), this._ptDist.getDistance();
        }, Di.prototype.computeOrientedDistance = function(t2, e3, n2) {
          var i2 = new Ai(e3);
          if (t2.apply(i2), n2.setMaximum(i2.getMaxPointDistance()), this._densifyFrac > 0) {
            var r2 = new Fi(e3, this._densifyFrac);
            t2.apply(r2), n2.setMaximum(r2.getMaxPointDistance());
          }
        }, Di.prototype.orientedDistance = function() {
          return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance();
        }, Di.prototype.interfaces_ = function() {
          return [];
        }, Di.prototype.getClass = function() {
          return Di;
        }, Di.distance = function() {
          if (arguments.length === 2) {
            var t2 = arguments[0], e3 = arguments[1];
            return new Di(t2, e3).distance();
          }
          if (arguments.length === 3) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new Di(n2, i2);
            return o2.setDensifyFraction(r2), o2.distance();
          }
        }, Mi.MaxPointDistanceFilter.get = function() {
          return Ai;
        }, Mi.MaxDensifiedByFractionDistanceFilter.get = function() {
          return Fi;
        }, Object.defineProperties(Di, Mi);
        var Ai = function() {
          this._maxPtDist = new Ri(), this._minPtDist = new Ri(), this._euclideanDist = new Pi(), this._geom = null;
          var t2 = arguments[0];
          this._geom = t2;
        };
        Ai.prototype.filter = function(t2) {
          this._minPtDist.initialize(), Pi.computeDistance(this._geom, t2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }, Ai.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, Ai.prototype.interfaces_ = function() {
          return [ft];
        }, Ai.prototype.getClass = function() {
          return Ai;
        };
        var Fi = function() {
          this._maxPtDist = new Ri(), this._minPtDist = new Ri(), this._geom = null, this._numSubSegs = 0;
          var t2 = arguments[0], e3 = arguments[1];
          this._geom = t2, this._numSubSegs = Math.trunc(Math.round(1 / e3));
        };
        Fi.prototype.filter = function(t2, e3) {
          if (e3 === 0)
            return null;
          for (var n2 = t2.getCoordinate(e3 - 1), i2 = t2.getCoordinate(e3), r2 = (i2.x - n2.x) / this._numSubSegs, o2 = (i2.y - n2.y) / this._numSubSegs, s2 = 0; s2 < this._numSubSegs; s2++) {
            var a2 = n2.x + s2 * r2, u2 = n2.y + s2 * o2, l2 = new C(a2, u2);
            this._minPtDist.initialize(), Pi.computeDistance(this._geom, l2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
          }
        }, Fi.prototype.isDone = function() {
          return false;
        }, Fi.prototype.isGeometryChanged = function() {
          return false;
        }, Fi.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, Fi.prototype.interfaces_ = function() {
          return [Ut];
        }, Fi.prototype.getClass = function() {
          return Fi;
        };
        var Gi = function(t2, e3, n2) {
          this._minValidDistance = null, this._maxValidDistance = null, this._minDistanceFound = null, this._maxDistanceFound = null, this._isValid = true, this._errMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t2 || null, this._bufDistance = e3 || null, this._result = n2 || null;
        }, qi = { VERBOSE: { configurable: true }, MAX_DISTANCE_DIFF_FRAC: { configurable: true } };
        Gi.prototype.checkMaximumDistance = function(t2, e3, n2) {
          var i2 = new Di(e3, t2);
          if (i2.setDensifyFraction(0.25), this._maxDistanceFound = i2.orientedDistance(), this._maxDistanceFound > n2) {
            this._isValid = false;
            var r2 = i2.getCoordinates();
            this._errorLocation = r2[1], this._errorIndicator = t2.getFactory().createLineString(r2), this._errMsg = "Distance between buffer curve and input is too large (" + this._maxDistanceFound + " at " + Z.toLineString(r2[0], r2[1]) + ")";
          }
        }, Gi.prototype.isValid = function() {
          var t2 = Math.abs(this._bufDistance), e3 = Gi.MAX_DISTANCE_DIFF_FRAC * t2;
          return this._minValidDistance = t2 - e3, this._maxValidDistance = t2 + e3, !(!this._input.isEmpty() && !this._result.isEmpty()) || (this._bufDistance > 0 ? this.checkPositiveValid() : this.checkNegativeValid(), Gi.VERBOSE && Y.out.println("Min Dist= " + this._minDistanceFound + "  err= " + (1 - this._minDistanceFound / this._bufDistance) + "  Max Dist= " + this._maxDistanceFound + "  err= " + (this._maxDistanceFound / this._bufDistance - 1)), this._isValid);
        }, Gi.prototype.checkNegativeValid = function() {
          if (!(this._input instanceof $t || this._input instanceof ne || this._input instanceof zt))
            return null;
          var t2 = this.getPolygonLines(this._input);
          if (this.checkMinimumDistance(t2, this._result, this._minValidDistance), !this._isValid)
            return null;
          this.checkMaximumDistance(t2, this._result, this._maxValidDistance);
        }, Gi.prototype.getErrorIndicator = function() {
          return this._errorIndicator;
        }, Gi.prototype.checkMinimumDistance = function(t2, e3, n2) {
          var i2 = new Ti(t2, e3, n2);
          if (this._minDistanceFound = i2.distance(), this._minDistanceFound < n2) {
            this._isValid = false;
            var r2 = i2.nearestPoints();
            this._errorLocation = i2.nearestPoints()[1], this._errorIndicator = t2.getFactory().createLineString(r2), this._errMsg = "Distance between buffer curve and input is too small (" + this._minDistanceFound + " at " + Z.toLineString(r2[0], r2[1]) + " )";
          }
        }, Gi.prototype.checkPositiveValid = function() {
          var t2 = this._result.getBoundary();
          if (this.checkMinimumDistance(this._input, t2, this._minValidDistance), !this._isValid)
            return null;
          this.checkMaximumDistance(this._input, t2, this._maxValidDistance);
        }, Gi.prototype.getErrorLocation = function() {
          return this._errorLocation;
        }, Gi.prototype.getPolygonLines = function(t2) {
          for (var e3 = new Nt(), n2 = new Ci(e3), i2 = Ni.getPolygons(t2).iterator(); i2.hasNext(); ) {
            i2.next().apply(n2);
          }
          return t2.getFactory().buildGeometry(e3);
        }, Gi.prototype.getErrorMessage = function() {
          return this._errMsg;
        }, Gi.prototype.interfaces_ = function() {
          return [];
        }, Gi.prototype.getClass = function() {
          return Gi;
        }, qi.VERBOSE.get = function() {
          return false;
        }, qi.MAX_DISTANCE_DIFF_FRAC.get = function() {
          return 0.012;
        }, Object.defineProperties(Gi, qi);
        var Bi = function(t2, e3, n2) {
          this._isValid = true, this._errorMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t2 || null, this._distance = e3 || null, this._result = n2 || null;
        }, Vi = { VERBOSE: { configurable: true }, MAX_ENV_DIFF_FRAC: { configurable: true } };
        Bi.prototype.isValid = function() {
          return this.checkPolygonal(), this._isValid ? (this.checkExpectedEmpty(), this._isValid ? (this.checkEnvelope(), this._isValid ? (this.checkArea(), this._isValid ? (this.checkDistance(), this._isValid) : this._isValid) : this._isValid) : this._isValid) : this._isValid;
        }, Bi.prototype.checkEnvelope = function() {
          if (this._distance < 0)
            return null;
          var t2 = this._distance * Bi.MAX_ENV_DIFF_FRAC;
          t2 === 0 && (t2 = 1e-3);
          var e3 = new j(this._input.getEnvelopeInternal());
          e3.expandBy(this._distance);
          var n2 = new j(this._result.getEnvelopeInternal());
          n2.expandBy(t2), n2.contains(e3) || (this._isValid = false, this._errorMsg = "Buffer envelope is incorrect", this._errorIndicator = this._input.getFactory().toGeometry(n2)), this.report("Envelope");
        }, Bi.prototype.checkDistance = function() {
          var t2 = new Gi(this._input, this._distance, this._result);
          t2.isValid() || (this._isValid = false, this._errorMsg = t2.getErrorMessage(), this._errorLocation = t2.getErrorLocation(), this._errorIndicator = t2.getErrorIndicator()), this.report("Distance");
        }, Bi.prototype.checkArea = function() {
          var t2 = this._input.getArea(), e3 = this._result.getArea();
          this._distance > 0 && t2 > e3 && (this._isValid = false, this._errorMsg = "Area of positive buffer is smaller than input", this._errorIndicator = this._result), this._distance < 0 && t2 < e3 && (this._isValid = false, this._errorMsg = "Area of negative buffer is larger than input", this._errorIndicator = this._result), this.report("Area");
        }, Bi.prototype.checkPolygonal = function() {
          this._result instanceof $t || this._result instanceof ne || (this._isValid = false), this._errorMsg = "Result is not polygonal", this._errorIndicator = this._result, this.report("Polygonal");
        }, Bi.prototype.getErrorIndicator = function() {
          return this._errorIndicator;
        }, Bi.prototype.getErrorLocation = function() {
          return this._errorLocation;
        }, Bi.prototype.checkExpectedEmpty = function() {
          return this._input.getDimension() >= 2 ? null : this._distance > 0 ? null : (this._result.isEmpty() || (this._isValid = false, this._errorMsg = "Result is non-empty", this._errorIndicator = this._result), void this.report("ExpectedEmpty"));
        }, Bi.prototype.report = function(t2) {
          if (!Bi.VERBOSE)
            return null;
          Y.out.println("Check " + t2 + ": " + (this._isValid ? "passed" : "FAILED"));
        }, Bi.prototype.getErrorMessage = function() {
          return this._errorMsg;
        }, Bi.prototype.interfaces_ = function() {
          return [];
        }, Bi.prototype.getClass = function() {
          return Bi;
        }, Bi.isValidMsg = function(t2, e3, n2) {
          var i2 = new Bi(t2, e3, n2);
          return i2.isValid() ? null : i2.getErrorMessage();
        }, Bi.isValid = function(t2, e3, n2) {
          return !!new Bi(t2, e3, n2).isValid();
        }, Vi.VERBOSE.get = function() {
          return false;
        }, Vi.MAX_ENV_DIFF_FRAC.get = function() {
          return 0.012;
        }, Object.defineProperties(Bi, Vi);
        var Ui = function() {
          this._pts = null, this._data = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._pts = t2, this._data = e3;
        };
        Ui.prototype.getCoordinates = function() {
          return this._pts;
        }, Ui.prototype.size = function() {
          return this._pts.length;
        }, Ui.prototype.getCoordinate = function(t2) {
          return this._pts[t2];
        }, Ui.prototype.isClosed = function() {
          return this._pts[0].equals(this._pts[this._pts.length - 1]);
        }, Ui.prototype.getSegmentOctant = function(t2) {
          return t2 === this._pts.length - 1 ? -1 : pn.octant(this.getCoordinate(t2), this.getCoordinate(t2 + 1));
        }, Ui.prototype.setData = function(t2) {
          this._data = t2;
        }, Ui.prototype.getData = function() {
          return this._data;
        }, Ui.prototype.toString = function() {
          return Z.toLineString(new ue(this._pts));
        }, Ui.prototype.interfaces_ = function() {
          return [hn];
        }, Ui.prototype.getClass = function() {
          return Ui;
        };
        var zi = function() {
          this._findAllIntersections = false, this._isCheckEndSegmentsOnly = false, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new Nt(), this._intersectionCount = 0, this._keepIntersections = true;
          var t2 = arguments[0];
          this._li = t2, this._interiorIntersection = null;
        };
        zi.prototype.getInteriorIntersection = function() {
          return this._interiorIntersection;
        }, zi.prototype.setCheckEndSegmentsOnly = function(t2) {
          this._isCheckEndSegmentsOnly = t2;
        }, zi.prototype.getIntersectionSegments = function() {
          return this._intSegments;
        }, zi.prototype.count = function() {
          return this._intersectionCount;
        }, zi.prototype.getIntersections = function() {
          return this._intersections;
        }, zi.prototype.setFindAllIntersections = function(t2) {
          this._findAllIntersections = t2;
        }, zi.prototype.setKeepIntersections = function(t2) {
          this._keepIntersections = t2;
        }, zi.prototype.processIntersections = function(t2, e3, n2, i2) {
          if (!this._findAllIntersections && this.hasIntersection())
            return null;
          if (t2 === n2 && e3 === i2)
            return null;
          if (this._isCheckEndSegmentsOnly) {
            if (!(this.isEndSegment(t2, e3) || this.isEndSegment(n2, i2)))
              return null;
          }
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && this._li.isInteriorIntersection() && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = r2, this._intSegments[1] = o2, this._intSegments[2] = s2, this._intSegments[3] = a2, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++);
        }, zi.prototype.isEndSegment = function(t2, e3) {
          return e3 === 0 || e3 >= t2.size() - 2;
        }, zi.prototype.hasIntersection = function() {
          return this._interiorIntersection !== null;
        }, zi.prototype.isDone = function() {
          return !this._findAllIntersections && this._interiorIntersection !== null;
        }, zi.prototype.interfaces_ = function() {
          return [Wn];
        }, zi.prototype.getClass = function() {
          return zi;
        }, zi.createAllIntersectionsFinder = function(t2) {
          var e3 = new zi(t2);
          return e3.setFindAllIntersections(true), e3;
        }, zi.createAnyIntersectionFinder = function(t2) {
          return new zi(t2);
        }, zi.createIntersectionCounter = function(t2) {
          var e3 = new zi(t2);
          return e3.setFindAllIntersections(true), e3.setKeepIntersections(false), e3;
        };
        var Xi = function() {
          this._li = new rt(), this._segStrings = null, this._findAllIntersections = false, this._segInt = null, this._isValid = true;
          var t2 = arguments[0];
          this._segStrings = t2;
        };
        Xi.prototype.execute = function() {
          if (this._segInt !== null)
            return null;
          this.checkInteriorIntersections();
        }, Xi.prototype.getIntersections = function() {
          return this._segInt.getIntersections();
        }, Xi.prototype.isValid = function() {
          return this.execute(), this._isValid;
        }, Xi.prototype.setFindAllIntersections = function(t2) {
          this._findAllIntersections = t2;
        }, Xi.prototype.checkInteriorIntersections = function() {
          this._isValid = true, this._segInt = new zi(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections);
          var t2 = new xn();
          if (t2.setSegmentIntersector(this._segInt), t2.computeNodes(this._segStrings), this._segInt.hasIntersection())
            return this._isValid = false, null;
        }, Xi.prototype.checkValid = function() {
          if (this.execute(), !this._isValid)
            throw new we(this.getErrorMessage(), this._segInt.getInteriorIntersection());
        }, Xi.prototype.getErrorMessage = function() {
          if (this._isValid)
            return "no intersections found";
          var t2 = this._segInt.getIntersectionSegments();
          return "found non-noded intersection between " + Z.toLineString(t2[0], t2[1]) + " and " + Z.toLineString(t2[2], t2[3]);
        }, Xi.prototype.interfaces_ = function() {
          return [];
        }, Xi.prototype.getClass = function() {
          return Xi;
        }, Xi.computeIntersections = function(t2) {
          var e3 = new Xi(t2);
          return e3.setFindAllIntersections(true), e3.isValid(), e3.getIntersections();
        };
        var Yi = function t2() {
          this._nv = null;
          var e3 = arguments[0];
          this._nv = new Xi(t2.toSegmentStrings(e3));
        };
        Yi.prototype.checkValid = function() {
          this._nv.checkValid();
        }, Yi.prototype.interfaces_ = function() {
          return [];
        }, Yi.prototype.getClass = function() {
          return Yi;
        }, Yi.toSegmentStrings = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            e3.add(new Ui(i2.getCoordinates(), i2));
          }
          return e3;
        }, Yi.checkValid = function(t2) {
          new Yi(t2).checkValid();
        };
        var ki = function(t2) {
          this._mapOp = t2;
        };
        ki.prototype.map = function(t2) {
          for (var e3 = new Nt(), n2 = 0; n2 < t2.getNumGeometries(); n2++) {
            var i2 = this._mapOp.map(t2.getGeometryN(n2));
            i2.isEmpty() || e3.add(i2);
          }
          return t2.getFactory().createGeometryCollection(_e.toGeometryArray(e3));
        }, ki.prototype.interfaces_ = function() {
          return [];
        }, ki.prototype.getClass = function() {
          return ki;
        }, ki.map = function(t2, e3) {
          return new ki(e3).map(t2);
        };
        var ji = function() {
          this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new Nt(), this._resultLineList = new Nt();
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._op = t2, this._geometryFactory = e3, this._ptLocator = n2;
        };
        ji.prototype.collectLines = function(t2) {
          for (var e3 = this._op.getGraph().getEdgeEnds().iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this.collectLineEdge(n2, t2, this._lineEdgesList), this.collectBoundaryTouchEdge(n2, t2, this._lineEdgesList);
          }
        }, ji.prototype.labelIsolatedLine = function(t2, e3) {
          var n2 = this._ptLocator.locate(t2.getCoordinate(), this._op.getArgGeometry(e3));
          t2.getLabel().setLocation(e3, n2);
        }, ji.prototype.build = function(t2) {
          return this.findCoveredLineEdges(), this.collectLines(t2), this.buildLines(t2), this._resultLineList;
        }, ji.prototype.collectLineEdge = function(t2, e3, n2) {
          var i2 = t2.getLabel(), r2 = t2.getEdge();
          t2.isLineEdge() && (t2.isVisited() || !Lr.isResultOfOp(i2, e3) || r2.isCovered() || (n2.add(r2), t2.setVisitedEdge(true)));
        }, ji.prototype.findCoveredLineEdges = function() {
          for (var t2 = this._op.getGraph().getNodes().iterator(); t2.hasNext(); ) {
            t2.next().getEdges().findCoveredLineEdges();
          }
          for (var e3 = this._op.getGraph().getEdgeEnds().iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = n2.getEdge();
            if (n2.isLineEdge() && !i2.isCoveredSet()) {
              var r2 = this._op.isCoveredByA(n2.getCoordinate());
              i2.setCovered(r2);
            }
          }
        }, ji.prototype.labelIsolatedLines = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = n2.getLabel();
            n2.isIsolated() && (i2.isNull(0) ? this.labelIsolatedLine(n2, 0) : this.labelIsolatedLine(n2, 1));
          }
        }, ji.prototype.buildLines = function(t2) {
          for (var e3 = this._lineEdgesList.iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = this._geometryFactory.createLineString(n2.getCoordinates());
            this._resultLineList.add(i2), n2.setInResult(true);
          }
        }, ji.prototype.collectBoundaryTouchEdge = function(t2, e3, n2) {
          var i2 = t2.getLabel();
          return t2.isLineEdge() ? null : t2.isVisited() ? null : t2.isInteriorAreaEdge() ? null : t2.getEdge().isInResult() ? null : (et.isTrue(!(t2.isInResult() || t2.getSym().isInResult()) || !t2.getEdge().isInResult()), void (Lr.isResultOfOp(i2, e3) && e3 === Lr.INTERSECTION && (n2.add(t2.getEdge()), t2.setVisitedEdge(true))));
        }, ji.prototype.interfaces_ = function() {
          return [];
        }, ji.prototype.getClass = function() {
          return ji;
        };
        var Hi = function() {
          this._op = null, this._geometryFactory = null, this._resultPointList = new Nt();
          var t2 = arguments[0], e3 = arguments[1];
          this._op = t2, this._geometryFactory = e3;
        };
        Hi.prototype.filterCoveredNodeToPoint = function(t2) {
          var e3 = t2.getCoordinate();
          if (!this._op.isCoveredByLA(e3)) {
            var n2 = this._geometryFactory.createPoint(e3);
            this._resultPointList.add(n2);
          }
        }, Hi.prototype.extractNonCoveredResultNodes = function(t2) {
          for (var e3 = this._op.getGraph().getNodes().iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            if (!n2.isInResult() && (!n2.isIncidentEdgeInResult() && (n2.getEdges().getDegree() === 0 || t2 === Lr.INTERSECTION))) {
              var i2 = n2.getLabel();
              Lr.isResultOfOp(i2, t2) && this.filterCoveredNodeToPoint(n2);
            }
          }
        }, Hi.prototype.build = function(t2) {
          return this.extractNonCoveredResultNodes(t2), this._resultPointList;
        }, Hi.prototype.interfaces_ = function() {
          return [];
        }, Hi.prototype.getClass = function() {
          return Hi;
        };
        var Wi = function() {
          this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = true, this._preserveGeometryCollectionType = true, this._preserveCollections = false, this._preserveType = false;
        };
        Wi.prototype.transformPoint = function(t2, e3) {
          return this._factory.createPoint(this.transformCoordinates(t2.getCoordinateSequence(), t2));
        }, Wi.prototype.transformPolygon = function(t2, e3) {
          var n2 = true, i2 = this.transformLinearRing(t2.getExteriorRing(), t2);
          i2 !== null && i2 instanceof ee && !i2.isEmpty() || (n2 = false);
          for (var r2 = new Nt(), o2 = 0; o2 < t2.getNumInteriorRing(); o2++) {
            var s2 = this.transformLinearRing(t2.getInteriorRingN(o2), t2);
            s2 === null || s2.isEmpty() || (s2 instanceof ee || (n2 = false), r2.add(s2));
          }
          if (n2)
            return this._factory.createPolygon(i2, r2.toArray([]));
          var a2 = new Nt();
          return i2 !== null && a2.add(i2), a2.addAll(r2), this._factory.buildGeometry(a2);
        }, Wi.prototype.createCoordinateSequence = function(t2) {
          return this._factory.getCoordinateSequenceFactory().create(t2);
        }, Wi.prototype.getInputGeometry = function() {
          return this._inputGeom;
        }, Wi.prototype.transformMultiLineString = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transformLineString(t2.getGeometryN(i2), t2);
            r2 !== null && (r2.isEmpty() || n2.add(r2));
          }
          return this._factory.buildGeometry(n2);
        }, Wi.prototype.transformCoordinates = function(t2, e3) {
          return this.copy(t2);
        }, Wi.prototype.transformLineString = function(t2, e3) {
          return this._factory.createLineString(this.transformCoordinates(t2.getCoordinateSequence(), t2));
        }, Wi.prototype.transformMultiPoint = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transformPoint(t2.getGeometryN(i2), t2);
            r2 !== null && (r2.isEmpty() || n2.add(r2));
          }
          return this._factory.buildGeometry(n2);
        }, Wi.prototype.transformMultiPolygon = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transformPolygon(t2.getGeometryN(i2), t2);
            r2 !== null && (r2.isEmpty() || n2.add(r2));
          }
          return this._factory.buildGeometry(n2);
        }, Wi.prototype.copy = function(t2) {
          return t2.copy();
        }, Wi.prototype.transformGeometryCollection = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transform(t2.getGeometryN(i2));
            r2 !== null && (this._pruneEmptyGeometry && r2.isEmpty() || n2.add(r2));
          }
          return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(_e.toGeometryArray(n2)) : this._factory.buildGeometry(n2);
        }, Wi.prototype.transform = function(t2) {
          if (this._inputGeom = t2, this._factory = t2.getFactory(), t2 instanceof Qt)
            return this.transformPoint(t2, null);
          if (t2 instanceof te)
            return this.transformMultiPoint(t2, null);
          if (t2 instanceof ee)
            return this.transformLinearRing(t2, null);
          if (t2 instanceof Kt)
            return this.transformLineString(t2, null);
          if (t2 instanceof Xt)
            return this.transformMultiLineString(t2, null);
          if (t2 instanceof $t)
            return this.transformPolygon(t2, null);
          if (t2 instanceof ne)
            return this.transformMultiPolygon(t2, null);
          if (t2 instanceof zt)
            return this.transformGeometryCollection(t2, null);
          throw new m("Unknown Geometry subtype: " + t2.getClass().getName());
        }, Wi.prototype.transformLinearRing = function(t2, e3) {
          var n2 = this.transformCoordinates(t2.getCoordinateSequence(), t2);
          if (n2 === null)
            return this._factory.createLinearRing(null);
          var i2 = n2.size();
          return i2 > 0 && i2 < 4 && !this._preserveType ? this._factory.createLineString(n2) : this._factory.createLinearRing(n2);
        }, Wi.prototype.interfaces_ = function() {
          return [];
        }, Wi.prototype.getClass = function() {
          return Wi;
        };
        var Ki = function t2() {
          if (this._snapTolerance = 0, this._srcPts = null, this._seg = new dn(), this._allowSnappingToSourceVertices = false, this._isClosed = false, arguments[0] instanceof Kt && typeof arguments[1] == "number") {
            var e3 = arguments[0], n2 = arguments[1];
            t2.call(this, e3.getCoordinates(), n2);
          } else if (arguments[0] instanceof Array && typeof arguments[1] == "number") {
            var i2 = arguments[0], r2 = arguments[1];
            this._srcPts = i2, this._isClosed = t2.isClosed(i2), this._snapTolerance = r2;
          }
        };
        Ki.prototype.snapVertices = function(t2, e3) {
          for (var n2 = this._isClosed ? t2.size() - 1 : t2.size(), i2 = 0; i2 < n2; i2++) {
            var r2 = t2.get(i2), o2 = this.findSnapForVertex(r2, e3);
            o2 !== null && (t2.set(i2, new C(o2)), i2 === 0 && this._isClosed && t2.set(t2.size() - 1, new C(o2)));
          }
        }, Ki.prototype.findSnapForVertex = function(t2, e3) {
          for (var n2 = 0; n2 < e3.length; n2++) {
            if (t2.equals2D(e3[n2]))
              return null;
            if (t2.distance(e3[n2]) < this._snapTolerance)
              return e3[n2];
          }
          return null;
        }, Ki.prototype.snapTo = function(t2) {
          var e3 = new St(this._srcPts);
          this.snapVertices(e3, t2), this.snapSegments(e3, t2);
          return e3.toCoordinateArray();
        }, Ki.prototype.snapSegments = function(t2, e3) {
          if (e3.length === 0)
            return null;
          var n2 = e3.length;
          e3[0].equals2D(e3[e3.length - 1]) && (n2 = e3.length - 1);
          for (var i2 = 0; i2 < n2; i2++) {
            var r2 = e3[i2], o2 = this.findSegmentIndexToSnap(r2, t2);
            o2 >= 0 && t2.add(o2 + 1, new C(r2), false);
          }
        }, Ki.prototype.findSegmentIndexToSnap = function(t2, e3) {
          for (var n2 = v.MAX_VALUE, i2 = -1, r2 = 0; r2 < e3.size() - 1; r2++) {
            if (this._seg.p0 = e3.get(r2), this._seg.p1 = e3.get(r2 + 1), this._seg.p0.equals2D(t2) || this._seg.p1.equals2D(t2)) {
              if (this._allowSnappingToSourceVertices)
                continue;
              return -1;
            }
            var o2 = this._seg.distance(t2);
            o2 < this._snapTolerance && o2 < n2 && (n2 = o2, i2 = r2);
          }
          return i2;
        }, Ki.prototype.setAllowSnappingToSourceVertices = function(t2) {
          this._allowSnappingToSourceVertices = t2;
        }, Ki.prototype.interfaces_ = function() {
          return [];
        }, Ki.prototype.getClass = function() {
          return Ki;
        }, Ki.isClosed = function(t2) {
          return !(t2.length <= 1) && t2[0].equals2D(t2[t2.length - 1]);
        };
        var Ji = function(t2) {
          this._srcGeom = t2 || null;
        }, Qi = { SNAP_PRECISION_FACTOR: { configurable: true } };
        Ji.prototype.snapTo = function(t2, e3) {
          var n2 = this.extractTargetCoordinates(t2);
          return new Zi(e3, n2).transform(this._srcGeom);
        }, Ji.prototype.snapToSelf = function(t2, e3) {
          var n2 = this.extractTargetCoordinates(this._srcGeom), i2 = new Zi(t2, n2, true).transform(this._srcGeom), r2 = i2;
          return e3 && T(r2, Zt) && (r2 = i2.buffer(0)), r2;
        }, Ji.prototype.computeSnapTolerance = function(t2) {
          return this.computeMinimumSegmentLength(t2) / 10;
        }, Ji.prototype.extractTargetCoordinates = function(t2) {
          for (var e3 = new f(), n2 = t2.getCoordinates(), i2 = 0; i2 < n2.length; i2++)
            e3.add(n2[i2]);
          return e3.toArray(new Array(0).fill(null));
        }, Ji.prototype.computeMinimumSegmentLength = function(t2) {
          for (var e3 = v.MAX_VALUE, n2 = 0; n2 < t2.length - 1; n2++) {
            var i2 = t2[n2].distance(t2[n2 + 1]);
            i2 < e3 && (e3 = i2);
          }
          return e3;
        }, Ji.prototype.interfaces_ = function() {
          return [];
        }, Ji.prototype.getClass = function() {
          return Ji;
        }, Ji.snap = function(t2, e3, n2) {
          var i2 = new Array(2).fill(null), r2 = new Ji(t2);
          i2[0] = r2.snapTo(e3, n2);
          var o2 = new Ji(e3);
          return i2[1] = o2.snapTo(i2[0], n2), i2;
        }, Ji.computeOverlaySnapTolerance = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0], e3 = Ji.computeSizeBasedSnapTolerance(t2), n2 = t2.getPrecisionModel();
            if (n2.getType() === fe.FIXED) {
              var i2 = 1 / n2.getScale() * 2 / 1.415;
              i2 > e3 && (e3 = i2);
            }
            return e3;
          }
          if (arguments.length === 2) {
            var r2 = arguments[0], o2 = arguments[1];
            return Math.min(Ji.computeOverlaySnapTolerance(r2), Ji.computeOverlaySnapTolerance(o2));
          }
        }, Ji.computeSizeBasedSnapTolerance = function(t2) {
          var e3 = t2.getEnvelopeInternal();
          return Math.min(e3.getHeight(), e3.getWidth()) * Ji.SNAP_PRECISION_FACTOR;
        }, Ji.snapToSelf = function(t2, e3, n2) {
          return new Ji(t2).snapToSelf(e3, n2);
        }, Qi.SNAP_PRECISION_FACTOR.get = function() {
          return 1e-9;
        }, Object.defineProperties(Ji, Qi);
        var Zi = function(t2) {
          function e3(e4, n2, i2) {
            t2.call(this), this._snapTolerance = e4 || null, this._snapPts = n2 || null, this._isSelfSnap = i2 !== void 0 && i2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.snapLine = function(t3, e4) {
            var n2 = new Ki(t3, this._snapTolerance);
            return n2.setAllowSnappingToSourceVertices(this._isSelfSnap), n2.snapTo(e4);
          }, e3.prototype.transformCoordinates = function(t3, e4) {
            var n2 = t3.toCoordinateArray(), i2 = this.snapLine(n2, this._snapPts);
            return this._factory.getCoordinateSequenceFactory().create(i2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Wi), $i = function() {
          this._isFirst = true, this._commonMantissaBitsCount = 53, this._commonBits = 0, this._commonSignExp = null;
        };
        $i.prototype.getCommon = function() {
          return v.longBitsToDouble(this._commonBits);
        }, $i.prototype.add = function(t2) {
          var e3 = v.doubleToLongBits(t2);
          if (this._isFirst)
            return this._commonBits = e3, this._commonSignExp = $i.signExpBits(this._commonBits), this._isFirst = false, null;
          if ($i.signExpBits(e3) !== this._commonSignExp)
            return this._commonBits = 0, null;
          this._commonMantissaBitsCount = $i.numCommonMostSigMantissaBits(this._commonBits, e3), this._commonBits = $i.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
        }, $i.prototype.toString = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0], e3 = v.longBitsToDouble(t2), n2 = "0000000000000000000000000000000000000000000000000000000000000000" + v.toBinaryString(t2), i2 = n2.substring(n2.length - 64);
            return i2.substring(0, 1) + "  " + i2.substring(1, 12) + "(exp) " + i2.substring(12) + " [ " + e3 + " ]";
          }
        }, $i.prototype.interfaces_ = function() {
          return [];
        }, $i.prototype.getClass = function() {
          return $i;
        }, $i.getBit = function(t2, e3) {
          return (t2 & 1 << e3) != 0 ? 1 : 0;
        }, $i.signExpBits = function(t2) {
          return t2 >> 52;
        }, $i.zeroLowerBits = function(t2, e3) {
          return t2 & ~((1 << e3) - 1);
        }, $i.numCommonMostSigMantissaBits = function(t2, e3) {
          for (var n2 = 0, i2 = 52; i2 >= 0; i2--) {
            if ($i.getBit(t2, i2) !== $i.getBit(e3, i2))
              return n2;
            n2++;
          }
          return 52;
        };
        var tr = function() {
          this._commonCoord = null, this._ccFilter = new nr();
        }, er = { CommonCoordinateFilter: { configurable: true }, Translater: { configurable: true } };
        tr.prototype.addCommonBits = function(t2) {
          var e3 = new ir(this._commonCoord);
          t2.apply(e3), t2.geometryChanged();
        }, tr.prototype.removeCommonBits = function(t2) {
          if (this._commonCoord.x === 0 && this._commonCoord.y === 0)
            return t2;
          var e3 = new C(this._commonCoord);
          e3.x = -e3.x, e3.y = -e3.y;
          var n2 = new ir(e3);
          return t2.apply(n2), t2.geometryChanged(), t2;
        }, tr.prototype.getCommonCoordinate = function() {
          return this._commonCoord;
        }, tr.prototype.add = function(t2) {
          t2.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate();
        }, tr.prototype.interfaces_ = function() {
          return [];
        }, tr.prototype.getClass = function() {
          return tr;
        }, er.CommonCoordinateFilter.get = function() {
          return nr;
        }, er.Translater.get = function() {
          return ir;
        }, Object.defineProperties(tr, er);
        var nr = function() {
          this._commonBitsX = new $i(), this._commonBitsY = new $i();
        };
        nr.prototype.filter = function(t2) {
          this._commonBitsX.add(t2.x), this._commonBitsY.add(t2.y);
        }, nr.prototype.getCommonCoordinate = function() {
          return new C(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
        }, nr.prototype.interfaces_ = function() {
          return [ft];
        }, nr.prototype.getClass = function() {
          return nr;
        };
        var ir = function() {
          this.trans = null;
          var t2 = arguments[0];
          this.trans = t2;
        };
        ir.prototype.filter = function(t2, e3) {
          var n2 = t2.getOrdinate(e3, 0) + this.trans.x, i2 = t2.getOrdinate(e3, 1) + this.trans.y;
          t2.setOrdinate(e3, 0, n2), t2.setOrdinate(e3, 1, i2);
        }, ir.prototype.isDone = function() {
          return false;
        }, ir.prototype.isGeometryChanged = function() {
          return true;
        }, ir.prototype.interfaces_ = function() {
          return [Ut];
        }, ir.prototype.getClass = function() {
          return ir;
        };
        var rr = function(t2, e3) {
          this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null, this._geom[0] = t2, this._geom[1] = e3, this.computeSnapTolerance();
        };
        rr.prototype.selfSnap = function(t2) {
          return new Ji(t2).snapTo(t2, this._snapTolerance);
        }, rr.prototype.removeCommonBits = function(t2) {
          this._cbr = new tr(), this._cbr.add(t2[0]), this._cbr.add(t2[1]);
          var e3 = new Array(2).fill(null);
          return e3[0] = this._cbr.removeCommonBits(t2[0].copy()), e3[1] = this._cbr.removeCommonBits(t2[1].copy()), e3;
        }, rr.prototype.prepareResult = function(t2) {
          return this._cbr.addCommonBits(t2), t2;
        }, rr.prototype.getResultGeometry = function(t2) {
          var e3 = this.snap(this._geom), n2 = Lr.overlayOp(e3[0], e3[1], t2);
          return this.prepareResult(n2);
        }, rr.prototype.checkValid = function(t2) {
          t2.isValid() || Y.out.println("Snapped geometry is invalid");
        }, rr.prototype.computeSnapTolerance = function() {
          this._snapTolerance = Ji.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
        }, rr.prototype.snap = function(t2) {
          var e3 = this.removeCommonBits(t2);
          return Ji.snap(e3[0], e3[1], this._snapTolerance);
        }, rr.prototype.interfaces_ = function() {
          return [];
        }, rr.prototype.getClass = function() {
          return rr;
        }, rr.overlayOp = function(t2, e3, n2) {
          return new rr(t2, e3).getResultGeometry(n2);
        }, rr.union = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.UNION);
        }, rr.intersection = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.INTERSECTION);
        }, rr.symDifference = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.SYMDIFFERENCE);
        }, rr.difference = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.DIFFERENCE);
        };
        var or = function(t2, e3) {
          this._geom = new Array(2).fill(null), this._geom[0] = t2, this._geom[1] = e3;
        };
        or.prototype.getResultGeometry = function(t2) {
          var e3 = null, n2 = false, i2 = null;
          try {
            e3 = Lr.overlayOp(this._geom[0], this._geom[1], t2);
            n2 = true;
          } catch (t3) {
            if (!(t3 instanceof $))
              throw t3;
            i2 = t3;
          }
          if (!n2)
            try {
              e3 = rr.overlayOp(this._geom[0], this._geom[1], t2);
            } catch (t3) {
              throw t3 instanceof $ ? i2 : t3;
            }
          return e3;
        }, or.prototype.interfaces_ = function() {
          return [];
        }, or.prototype.getClass = function() {
          return or;
        }, or.overlayOp = function(t2, e3, n2) {
          return new or(t2, e3).getResultGeometry(n2);
        }, or.union = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.UNION);
        }, or.intersection = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.INTERSECTION);
        }, or.symDifference = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.SYMDIFFERENCE);
        }, or.difference = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.DIFFERENCE);
        };
        var sr = function() {
          this.mce = null, this.chainIndex = null;
          var t2 = arguments[0], e3 = arguments[1];
          this.mce = t2, this.chainIndex = e3;
        };
        sr.prototype.computeIntersections = function(t2, e3) {
          this.mce.computeIntersectsForChain(this.chainIndex, t2.mce, t2.chainIndex, e3);
        }, sr.prototype.interfaces_ = function() {
          return [];
        }, sr.prototype.getClass = function() {
          return sr;
        };
        var ar = function t2() {
          if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            this._eventType = t2.DELETE, this._xValue = e3, this._insertEvent = n2;
          } else if (arguments.length === 3) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            this._eventType = t2.INSERT, this._label = i2, this._xValue = r2, this._obj = o2;
          }
        }, ur = { INSERT: { configurable: true }, DELETE: { configurable: true } };
        ar.prototype.isDelete = function() {
          return this._eventType === ar.DELETE;
        }, ar.prototype.setDeleteEventIndex = function(t2) {
          this._deleteEventIndex = t2;
        }, ar.prototype.getObject = function() {
          return this._obj;
        }, ar.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._xValue < e3._xValue ? -1 : this._xValue > e3._xValue ? 1 : this._eventType < e3._eventType ? -1 : this._eventType > e3._eventType ? 1 : 0;
        }, ar.prototype.getInsertEvent = function() {
          return this._insertEvent;
        }, ar.prototype.isInsert = function() {
          return this._eventType === ar.INSERT;
        }, ar.prototype.isSameLabel = function(t2) {
          return this._label !== null && this._label === t2._label;
        }, ar.prototype.getDeleteEventIndex = function() {
          return this._deleteEventIndex;
        }, ar.prototype.interfaces_ = function() {
          return [E];
        }, ar.prototype.getClass = function() {
          return ar;
        }, ur.INSERT.get = function() {
          return 1;
        }, ur.DELETE.get = function() {
          return 2;
        }, Object.defineProperties(ar, ur);
        var lr = function() {
        };
        lr.prototype.interfaces_ = function() {
          return [];
        }, lr.prototype.getClass = function() {
          return lr;
        };
        var cr = function() {
          this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = false, this._isDoneWhenProperInt = false;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._li = t2, this._includeProper = e3, this._recordIsolated = n2;
        };
        cr.prototype.isTrivialIntersection = function(t2, e3, n2, i2) {
          if (t2 === n2 && this._li.getIntersectionNum() === 1) {
            if (cr.isAdjacentSegments(e3, i2))
              return true;
            if (t2.isClosed()) {
              var r2 = t2.getNumPoints() - 1;
              if (e3 === 0 && i2 === r2 || i2 === 0 && e3 === r2)
                return true;
            }
          }
          return false;
        }, cr.prototype.getProperIntersectionPoint = function() {
          return this._properIntersectionPoint;
        }, cr.prototype.setIsDoneIfProperInt = function(t2) {
          this._isDoneWhenProperInt = t2;
        }, cr.prototype.hasProperInteriorIntersection = function() {
          return this._hasProperInterior;
        }, cr.prototype.isBoundaryPointInternal = function(t2, e3) {
          for (var n2 = e3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().getCoordinate();
            if (t2.isIntersection(i2))
              return true;
          }
          return false;
        }, cr.prototype.hasProperIntersection = function() {
          return this._hasProper;
        }, cr.prototype.hasIntersection = function() {
          return this._hasIntersection;
        }, cr.prototype.isDone = function() {
          return this._isDone;
        }, cr.prototype.isBoundaryPoint = function(t2, e3) {
          return e3 !== null && (!!this.isBoundaryPointInternal(t2, e3[0]) || !!this.isBoundaryPointInternal(t2, e3[1]));
        }, cr.prototype.setBoundaryNodes = function(t2, e3) {
          this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = t2, this._bdyNodes[1] = e3;
        }, cr.prototype.addIntersections = function(t2, e3, n2, i2) {
          if (t2 === n2 && e3 === i2)
            return null;
          this.numTests++;
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && (this._recordIsolated && (t2.setIsolated(false), n2.setIsolated(false)), this._numIntersections++, this.isTrivialIntersection(t2, e3, n2, i2) || (this._hasIntersection = true, !this._includeProper && this._li.isProper() || (t2.addIntersections(this._li, e3, 0), n2.addIntersections(this._li, i2, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = true, this._isDoneWhenProperInt && (this._isDone = true), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = true))));
        }, cr.prototype.interfaces_ = function() {
          return [];
        }, cr.prototype.getClass = function() {
          return cr;
        }, cr.isAdjacentSegments = function(t2, e3) {
          return Math.abs(t2 - e3) === 1;
        };
        var pr = function(t2) {
          function e3() {
            t2.call(this), this.events = new Nt(), this.nOverlaps = null;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.prepareEvents = function() {
            $e.sort(this.events);
            for (var t3 = 0; t3 < this.events.size(); t3++) {
              var e4 = this.events.get(t3);
              e4.isDelete() && e4.getInsertEvent().setDeleteEventIndex(t3);
            }
          }, e3.prototype.computeIntersections = function() {
            if (arguments.length === 1) {
              var t3 = arguments[0];
              this.nOverlaps = 0, this.prepareEvents();
              for (var e4 = 0; e4 < this.events.size(); e4++) {
                var n2 = this.events.get(e4);
                if (n2.isInsert() && this.processOverlaps(e4, n2.getDeleteEventIndex(), n2, t3), t3.isDone())
                  break;
              }
            } else if (arguments.length === 3) {
              if (arguments[2] instanceof cr && T(arguments[0], xt) && T(arguments[1], xt)) {
                var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
                this.addEdges(i2, i2), this.addEdges(r2, r2), this.computeIntersections(o2);
              } else if (typeof arguments[2] == "boolean" && T(arguments[0], xt) && arguments[1] instanceof cr) {
                var s2 = arguments[0], a2 = arguments[1];
                arguments[2] ? this.addEdges(s2, null) : this.addEdges(s2), this.computeIntersections(a2);
              }
            }
          }, e3.prototype.addEdge = function(t3, e4) {
            for (var n2 = t3.getMonotoneChainEdge(), i2 = n2.getStartIndexes(), r2 = 0; r2 < i2.length - 1; r2++) {
              var o2 = new sr(n2, r2), s2 = new ar(e4, n2.getMinX(r2), o2);
              this.events.add(s2), this.events.add(new ar(n2.getMaxX(r2), s2));
            }
          }, e3.prototype.processOverlaps = function(t3, e4, n2, i2) {
            for (var r2 = n2.getObject(), o2 = t3; o2 < e4; o2++) {
              var s2 = this.events.get(o2);
              if (s2.isInsert()) {
                var a2 = s2.getObject();
                n2.isSameLabel(s2) || (r2.computeIntersections(a2, i2), this.nOverlaps++);
              }
            }
          }, e3.prototype.addEdges = function() {
            if (arguments.length === 1)
              for (var t3 = arguments[0].iterator(); t3.hasNext(); ) {
                var e4 = t3.next();
                this.addEdge(e4, e4);
              }
            else if (arguments.length === 2)
              for (var n2 = arguments[0], i2 = arguments[1], r2 = n2.iterator(); r2.hasNext(); ) {
                var o2 = r2.next();
                this.addEdge(o2, i2);
              }
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(lr), hr = function() {
          this._min = v.POSITIVE_INFINITY, this._max = v.NEGATIVE_INFINITY;
        }, fr = { NodeComparator: { configurable: true } };
        hr.prototype.getMin = function() {
          return this._min;
        }, hr.prototype.intersects = function(t2, e3) {
          return !(this._min > e3 || this._max < t2);
        }, hr.prototype.getMax = function() {
          return this._max;
        }, hr.prototype.toString = function() {
          return Z.toLineString(new C(this._min, 0), new C(this._max, 0));
        }, hr.prototype.interfaces_ = function() {
          return [];
        }, hr.prototype.getClass = function() {
          return hr;
        }, fr.NodeComparator.get = function() {
          return gr;
        }, Object.defineProperties(hr, fr);
        var gr = function() {
        };
        gr.prototype.compare = function(t2, e3) {
          var n2 = t2, i2 = e3, r2 = (n2._min + n2._max) / 2, o2 = (i2._min + i2._max) / 2;
          return r2 < o2 ? -1 : r2 > o2 ? 1 : 0;
        }, gr.prototype.interfaces_ = function() {
          return [N];
        }, gr.prototype.getClass = function() {
          return gr;
        };
        var dr = function(t2) {
          function e3() {
            t2.call(this), this._item = null;
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            this._min = e4, this._max = n2, this._item = i2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.query = function(t3, e4, n2) {
            if (!this.intersects(t3, e4))
              return null;
            n2.visitItem(this._item);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(hr), yr = function(t2) {
          function e3() {
            t2.call(this), this._node1 = null, this._node2 = null;
            var e4 = arguments[0], n2 = arguments[1];
            this._node1 = e4, this._node2 = n2, this.buildExtent(this._node1, this._node2);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.buildExtent = function(t3, e4) {
            this._min = Math.min(t3._min, e4._min), this._max = Math.max(t3._max, e4._max);
          }, e3.prototype.query = function(t3, e4, n2) {
            if (!this.intersects(t3, e4))
              return null;
            this._node1 !== null && this._node1.query(t3, e4, n2), this._node2 !== null && this._node2.query(t3, e4, n2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(hr), _r = function() {
          this._leaves = new Nt(), this._root = null, this._level = 0;
        };
        _r.prototype.buildTree = function() {
          $e.sort(this._leaves, new hr.NodeComparator());
          for (var t2 = this._leaves, e3 = null, n2 = new Nt(); ; ) {
            if (this.buildLevel(t2, n2), n2.size() === 1)
              return n2.get(0);
            e3 = t2, t2 = n2, n2 = e3;
          }
        }, _r.prototype.insert = function(t2, e3, n2) {
          if (this._root !== null)
            throw new Error("Index cannot be added to once it has been queried");
          this._leaves.add(new dr(t2, e3, n2));
        }, _r.prototype.query = function(t2, e3, n2) {
          this.init(), this._root.query(t2, e3, n2);
        }, _r.prototype.buildRoot = function() {
          if (this._root !== null)
            return null;
          this._root = this.buildTree();
        }, _r.prototype.printNode = function(t2) {
          Y.out.println(Z.toLineString(new C(t2._min, this._level), new C(t2._max, this._level)));
        }, _r.prototype.init = function() {
          if (this._root !== null)
            return null;
          this.buildRoot();
        }, _r.prototype.buildLevel = function(t2, e3) {
          this._level++, e3.clear();
          for (var n2 = 0; n2 < t2.size(); n2 += 2) {
            var i2 = t2.get(n2);
            if ((n2 + 1 < t2.size() ? t2.get(n2) : null) === null)
              e3.add(i2);
            else {
              var r2 = new yr(t2.get(n2), t2.get(n2 + 1));
              e3.add(r2);
            }
          }
        }, _r.prototype.interfaces_ = function() {
          return [];
        }, _r.prototype.getClass = function() {
          return _r;
        };
        var mr = function() {
          this._items = new Nt();
        };
        mr.prototype.visitItem = function(t2) {
          this._items.add(t2);
        }, mr.prototype.getItems = function() {
          return this._items;
        }, mr.prototype.interfaces_ = function() {
          return [Ke];
        }, mr.prototype.getClass = function() {
          return mr;
        };
        var vr = function() {
          this._index = null;
          var t2 = arguments[0];
          if (!T(t2, Zt))
            throw new m("Argument must be Polygonal");
          this._index = new xr(t2);
        }, Ir = { SegmentVisitor: { configurable: true }, IntervalIndexedGeometry: { configurable: true } };
        vr.prototype.locate = function(t2) {
          var e3 = new st(t2), n2 = new Er(e3);
          return this._index.query(t2.y, t2.y, n2), e3.getLocation();
        }, vr.prototype.interfaces_ = function() {
          return [Vn];
        }, vr.prototype.getClass = function() {
          return vr;
        }, Ir.SegmentVisitor.get = function() {
          return Er;
        }, Ir.IntervalIndexedGeometry.get = function() {
          return xr;
        }, Object.defineProperties(vr, Ir);
        var Er = function() {
          this._counter = null;
          var t2 = arguments[0];
          this._counter = t2;
        };
        Er.prototype.visitItem = function(t2) {
          var e3 = t2;
          this._counter.countSegment(e3.getCoordinate(0), e3.getCoordinate(1));
        }, Er.prototype.interfaces_ = function() {
          return [Ke];
        }, Er.prototype.getClass = function() {
          return Er;
        };
        var xr = function() {
          this._index = new _r();
          var t2 = arguments[0];
          this.init(t2);
        };
        xr.prototype.init = function(t2) {
          for (var e3 = Ci.getLines(t2).iterator(); e3.hasNext(); ) {
            var n2 = e3.next().getCoordinates();
            this.addLine(n2);
          }
        }, xr.prototype.addLine = function(t2) {
          for (var e3 = 1; e3 < t2.length; e3++) {
            var n2 = new dn(t2[e3 - 1], t2[e3]), i2 = Math.min(n2.p0.y, n2.p1.y), r2 = Math.max(n2.p0.y, n2.p1.y);
            this._index.insert(i2, r2, n2);
          }
        }, xr.prototype.query = function() {
          if (arguments.length === 2) {
            var t2 = arguments[0], e3 = arguments[1], n2 = new mr();
            return this._index.query(t2, e3, n2), n2.getItems();
          }
          if (arguments.length === 3) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            this._index.query(i2, r2, o2);
          }
        }, xr.prototype.interfaces_ = function() {
          return [];
        }, xr.prototype.getClass = function() {
          return xr;
        };
        var Nr = function(t2) {
          function e3() {
            if (t2.call(this), this._parentGeom = null, this._lineEdgeMap = new he(), this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = true, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = false, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Si(), arguments.length === 2) {
              var e4 = arguments[0], n2 = arguments[1], i2 = gt.OGC_SFS_BOUNDARY_RULE;
              this._argIndex = e4, this._parentGeom = n2, this._boundaryNodeRule = i2, n2 !== null && this.add(n2);
            } else if (arguments.length === 3) {
              var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
              this._argIndex = r2, this._parentGeom = o2, this._boundaryNodeRule = s2, o2 !== null && this.add(o2);
            }
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.insertBoundaryPoint = function(t3, n2) {
            var i2 = this._nodes.addNode(n2).getLabel(), r2 = 1;
            w.NONE;
            i2.getLocation(t3, Se.ON) === w.BOUNDARY && r2++;
            var o2 = e3.determineBoundary(this._boundaryNodeRule, r2);
            i2.setLocation(t3, o2);
          }, e3.prototype.computeSelfNodes = function() {
            if (arguments.length === 2) {
              var t3 = arguments[0], e4 = arguments[1];
              return this.computeSelfNodes(t3, e4, false);
            }
            if (arguments.length === 3) {
              var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new cr(n2, true, false);
              o2.setIsDoneIfProperInt(r2);
              var s2 = this.createEdgeSetIntersector(), a2 = this._parentGeom instanceof ee || this._parentGeom instanceof $t || this._parentGeom instanceof ne, u2 = i2 || !a2;
              return s2.computeIntersections(this._edges, o2, u2), this.addSelfIntersectionNodes(this._argIndex), o2;
            }
          }, e3.prototype.computeSplitEdges = function(t3) {
            for (var e4 = this._edges.iterator(); e4.hasNext(); ) {
              e4.next().eiList.addSplitEdges(t3);
            }
          }, e3.prototype.computeEdgeIntersections = function(t3, e4, n2) {
            var i2 = new cr(e4, n2, true);
            i2.setBoundaryNodes(this.getBoundaryNodes(), t3.getBoundaryNodes());
            return this.createEdgeSetIntersector().computeIntersections(this._edges, t3._edges, i2), i2;
          }, e3.prototype.getGeometry = function() {
            return this._parentGeom;
          }, e3.prototype.getBoundaryNodeRule = function() {
            return this._boundaryNodeRule;
          }, e3.prototype.hasTooFewPoints = function() {
            return this._hasTooFewPoints;
          }, e3.prototype.addPoint = function() {
            if (arguments[0] instanceof Qt) {
              var t3 = arguments[0].getCoordinate();
              this.insertPoint(this._argIndex, t3, w.INTERIOR);
            } else if (arguments[0] instanceof C) {
              var e4 = arguments[0];
              this.insertPoint(this._argIndex, e4, w.INTERIOR);
            }
          }, e3.prototype.addPolygon = function(t3) {
            this.addPolygonRing(t3.getExteriorRing(), w.EXTERIOR, w.INTERIOR);
            for (var e4 = 0; e4 < t3.getNumInteriorRing(); e4++) {
              var n2 = t3.getInteriorRingN(e4);
              this.addPolygonRing(n2, w.INTERIOR, w.EXTERIOR);
            }
          }, e3.prototype.addEdge = function(t3) {
            this.insertEdge(t3);
            var e4 = t3.getCoordinates();
            this.insertPoint(this._argIndex, e4[0], w.BOUNDARY), this.insertPoint(this._argIndex, e4[e4.length - 1], w.BOUNDARY);
          }, e3.prototype.addLineString = function(t3) {
            var e4 = Lt.removeRepeatedPoints(t3.getCoordinates());
            if (e4.length < 2)
              return this._hasTooFewPoints = true, this._invalidPoint = e4[0], null;
            var n2 = new ni(e4, new Pe(this._argIndex, w.INTERIOR));
            this._lineEdgeMap.put(t3, n2), this.insertEdge(n2), et.isTrue(e4.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this._argIndex, e4[0]), this.insertBoundaryPoint(this._argIndex, e4[e4.length - 1]);
          }, e3.prototype.getInvalidPoint = function() {
            return this._invalidPoint;
          }, e3.prototype.getBoundaryPoints = function() {
            for (var t3 = this.getBoundaryNodes(), e4 = new Array(t3.size()).fill(null), n2 = 0, i2 = t3.iterator(); i2.hasNext(); ) {
              var r2 = i2.next();
              e4[n2++] = r2.getCoordinate().copy();
            }
            return e4;
          }, e3.prototype.getBoundaryNodes = function() {
            return this._boundaryNodes === null && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes;
          }, e3.prototype.addSelfIntersectionNode = function(t3, e4, n2) {
            if (this.isBoundaryNode(t3, e4))
              return null;
            n2 === w.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(t3, e4) : this.insertPoint(t3, e4, n2);
          }, e3.prototype.addPolygonRing = function(t3, e4, n2) {
            if (t3.isEmpty())
              return null;
            var i2 = Lt.removeRepeatedPoints(t3.getCoordinates());
            if (i2.length < 4)
              return this._hasTooFewPoints = true, this._invalidPoint = i2[0], null;
            var r2 = e4, o2 = n2;
            at.isCCW(i2) && (r2 = n2, o2 = e4);
            var s2 = new ni(i2, new Pe(this._argIndex, w.BOUNDARY, r2, o2));
            this._lineEdgeMap.put(t3, s2), this.insertEdge(s2), this.insertPoint(this._argIndex, i2[0], w.BOUNDARY);
          }, e3.prototype.insertPoint = function(t3, e4, n2) {
            var i2 = this._nodes.addNode(e4), r2 = i2.getLabel();
            r2 === null ? i2._label = new Pe(t3, n2) : r2.setLocation(t3, n2);
          }, e3.prototype.createEdgeSetIntersector = function() {
            return new pr();
          }, e3.prototype.addSelfIntersectionNodes = function(t3) {
            for (var e4 = this._edges.iterator(); e4.hasNext(); )
              for (var n2 = e4.next(), i2 = n2.getLabel().getLocation(t3), r2 = n2.eiList.iterator(); r2.hasNext(); ) {
                var o2 = r2.next();
                this.addSelfIntersectionNode(t3, o2.coord, i2);
              }
          }, e3.prototype.add = function() {
            if (arguments.length !== 1)
              return t2.prototype.add.apply(this, arguments);
            var e4 = arguments[0];
            if (e4.isEmpty())
              return null;
            if (e4 instanceof ne && (this._useBoundaryDeterminationRule = false), e4 instanceof $t)
              this.addPolygon(e4);
            else if (e4 instanceof Kt)
              this.addLineString(e4);
            else if (e4 instanceof Qt)
              this.addPoint(e4);
            else if (e4 instanceof te)
              this.addCollection(e4);
            else if (e4 instanceof Xt)
              this.addCollection(e4);
            else if (e4 instanceof ne)
              this.addCollection(e4);
            else {
              if (!(e4 instanceof zt))
                throw new Error(e4.getClass().getName());
              this.addCollection(e4);
            }
          }, e3.prototype.addCollection = function(t3) {
            for (var e4 = 0; e4 < t3.getNumGeometries(); e4++) {
              var n2 = t3.getGeometryN(e4);
              this.add(n2);
            }
          }, e3.prototype.locate = function(t3) {
            return T(this._parentGeom, Zt) && this._parentGeom.getNumGeometries() > 50 ? (this._areaPtLocator === null && (this._areaPtLocator = new vr(this._parentGeom)), this._areaPtLocator.locate(t3)) : this._ptLocator.locate(t3, this._parentGeom);
          }, e3.prototype.findEdge = function() {
            if (arguments.length === 1) {
              var e4 = arguments[0];
              return this._lineEdgeMap.get(e4);
            }
            return t2.prototype.findEdge.apply(this, arguments);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.determineBoundary = function(t3, e4) {
            return t3.isInBoundary(e4) ? w.BOUNDARY : w.INTERIOR;
          }, e3;
        }(Ye), Cr = function() {
          if (this._li = new rt(), this._resultPrecisionModel = null, this._arg = null, arguments.length === 1) {
            var t2 = arguments[0];
            this.setComputationPrecision(t2.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new Nr(0, t2);
          } else if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1], i2 = gt.OGC_SFS_BOUNDARY_RULE;
            e3.getPrecisionModel().compareTo(n2.getPrecisionModel()) >= 0 ? this.setComputationPrecision(e3.getPrecisionModel()) : this.setComputationPrecision(n2.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Nr(0, e3, i2), this._arg[1] = new Nr(1, n2, i2);
          } else if (arguments.length === 3) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
            r2.getPrecisionModel().compareTo(o2.getPrecisionModel()) >= 0 ? this.setComputationPrecision(r2.getPrecisionModel()) : this.setComputationPrecision(o2.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Nr(0, r2, s2), this._arg[1] = new Nr(1, o2, s2);
          }
        };
        Cr.prototype.getArgGeometry = function(t2) {
          return this._arg[t2].getGeometry();
        }, Cr.prototype.setComputationPrecision = function(t2) {
          this._resultPrecisionModel = t2, this._li.setPrecisionModel(this._resultPrecisionModel);
        }, Cr.prototype.interfaces_ = function() {
          return [];
        }, Cr.prototype.getClass = function() {
          return Cr;
        };
        var Sr = function() {
        };
        Sr.prototype.interfaces_ = function() {
          return [];
        }, Sr.prototype.getClass = function() {
          return Sr;
        }, Sr.map = function() {
          if (arguments[0] instanceof ct && T(arguments[1], Sr.MapOp)) {
            for (var t2 = arguments[0], e3 = arguments[1], n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
              var r2 = e3.map(t2.getGeometryN(i2));
              r2 !== null && n2.add(r2);
            }
            return t2.getFactory().buildGeometry(n2);
          }
          if (T(arguments[0], It) && T(arguments[1], Sr.MapOp)) {
            for (var o2 = arguments[0], s2 = arguments[1], a2 = new Nt(), u2 = o2.iterator(); u2.hasNext(); ) {
              var l2 = u2.next(), c2 = s2.map(l2);
              c2 !== null && a2.add(c2);
            }
            return a2;
          }
        }, Sr.MapOp = function() {
        };
        var Lr = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            t2.call(this, e4, n2), this._ptLocator = new Si(), this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new Hn(), this._resultPolyList = new Nt(), this._resultLineList = new Nt(), this._resultPointList = new Nt(), this._graph = new Ye(new kn()), this._geomFact = e4.getFactory();
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.insertUniqueEdge = function(t3) {
            var e4 = this._edgeList.findEqualEdge(t3);
            if (e4 !== null) {
              var n2 = e4.getLabel(), i2 = t3.getLabel();
              e4.isPointwiseEqual(t3) || (i2 = new Pe(t3.getLabel())).flip();
              var r2 = e4.getDepth();
              r2.isNull() && r2.add(n2), r2.add(i2), n2.merge(i2);
            } else
              this._edgeList.add(t3);
          }, e3.prototype.getGraph = function() {
            return this._graph;
          }, e3.prototype.cancelDuplicateResultEdges = function() {
            for (var t3 = this._graph.getEdgeEnds().iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getSym();
              e4.isInResult() && n2.isInResult() && (e4.setInResult(false), n2.setInResult(false));
            }
          }, e3.prototype.isCoveredByLA = function(t3) {
            return !!this.isCovered(t3, this._resultLineList) || !!this.isCovered(t3, this._resultPolyList);
          }, e3.prototype.computeGeometry = function(t3, n2, i2, r2) {
            var o2 = new Nt();
            return o2.addAll(t3), o2.addAll(n2), o2.addAll(i2), o2.isEmpty() ? e3.createEmptyResult(r2, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(o2);
          }, e3.prototype.mergeSymLabels = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              t3.next().getEdges().mergeSymLabels();
            }
          }, e3.prototype.isCovered = function(t3, e4) {
            for (var n2 = e4.iterator(); n2.hasNext(); ) {
              var i2 = n2.next();
              if (this._ptLocator.locate(t3, i2) !== w.EXTERIOR)
                return true;
            }
            return false;
          }, e3.prototype.replaceCollapsedEdges = function() {
            for (var t3 = new Nt(), e4 = this._edgeList.iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              n2.isCollapsed() && (e4.remove(), t3.add(n2.getCollapsedEdge()));
            }
            this._edgeList.addAll(t3);
          }, e3.prototype.updateNodeLabelling = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getEdges().getLabel();
              e4.getLabel().merge(n2);
            }
          }, e3.prototype.getResultGeometry = function(t3) {
            return this.computeOverlay(t3), this._resultGeom;
          }, e3.prototype.insertUniqueEdges = function(t3) {
            for (var e4 = t3.iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              this.insertUniqueEdge(n2);
            }
          }, e3.prototype.computeOverlay = function(t3) {
            this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, false), this._arg[1].computeSelfNodes(this._li, false), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
            var e4 = new Nt();
            this._arg[0].computeSplitEdges(e4), this._arg[1].computeSplitEdges(e4), this.insertUniqueEdges(e4), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Yi.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t3), this.cancelDuplicateResultEdges();
            var n2 = new ke(this._geomFact);
            n2.add(this._graph), this._resultPolyList = n2.getPolygons();
            var i2 = new ji(this, this._geomFact, this._ptLocator);
            this._resultLineList = i2.build(t3);
            var r2 = new Hi(this, this._geomFact, this._ptLocator);
            this._resultPointList = r2.build(t3), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, t3);
          }, e3.prototype.labelIncompleteNode = function(t3, e4) {
            var n2 = this._ptLocator.locate(t3.getCoordinate(), this._arg[e4].getGeometry());
            t3.getLabel().setLocation(e4, n2);
          }, e3.prototype.copyPoints = function(t3) {
            for (var e4 = this._arg[t3].getNodeIterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              this._graph.addNode(n2.getCoordinate()).setLabel(t3, n2.getLabel().getLocation(t3));
            }
          }, e3.prototype.findResultAreaEdges = function(t3) {
            for (var n2 = this._graph.getEdgeEnds().iterator(); n2.hasNext(); ) {
              var i2 = n2.next(), r2 = i2.getLabel();
              r2.isArea() && !i2.isInteriorAreaEdge() && e3.isResultOfOp(r2.getLocation(0, Se.RIGHT), r2.getLocation(1, Se.RIGHT), t3) && i2.setInResult(true);
            }
          }, e3.prototype.computeLabelsFromDepths = function() {
            for (var t3 = this._edgeList.iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getLabel(), i2 = e4.getDepth();
              if (!i2.isNull()) {
                i2.normalize();
                for (var r2 = 0; r2 < 2; r2++)
                  n2.isNull(r2) || !n2.isArea() || i2.isNull(r2) || (i2.getDelta(r2) === 0 ? n2.toLine(r2) : (et.isTrue(!i2.isNull(r2, Se.LEFT), "depth of LEFT side has not been initialized"), n2.setLocation(r2, Se.LEFT, i2.getLocation(r2, Se.LEFT)), et.isTrue(!i2.isNull(r2, Se.RIGHT), "depth of RIGHT side has not been initialized"), n2.setLocation(r2, Se.RIGHT, i2.getLocation(r2, Se.RIGHT))));
              }
            }
          }, e3.prototype.computeLabelling = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              t3.next().getEdges().computeLabelling(this._arg);
            }
            this.mergeSymLabels(), this.updateNodeLabelling();
          }, e3.prototype.labelIncompleteNodes = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getLabel();
              e4.isIsolated() && (n2.isNull(0) ? this.labelIncompleteNode(e4, 0) : this.labelIncompleteNode(e4, 1)), e4.getEdges().updateLabelling(n2);
            }
          }, e3.prototype.isCoveredByA = function(t3) {
            return !!this.isCovered(t3, this._resultPolyList);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Cr);
        Lr.overlayOp = function(t2, e3, n2) {
          return new Lr(t2, e3).getResultGeometry(n2);
        }, Lr.intersection = function(t2, e3) {
          if (t2.isEmpty() || e3.isEmpty())
            return Lr.createEmptyResult(Lr.INTERSECTION, t2, e3, t2.getFactory());
          if (t2.isGeometryCollection()) {
            var n2 = e3;
            return ki.map(t2, { interfaces_: function() {
              return [Sr.MapOp];
            }, map: function(t3) {
              return t3.intersection(n2);
            } });
          }
          return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.INTERSECTION);
        }, Lr.symDifference = function(t2, e3) {
          if (t2.isEmpty() || e3.isEmpty()) {
            if (t2.isEmpty() && e3.isEmpty())
              return Lr.createEmptyResult(Lr.SYMDIFFERENCE, t2, e3, t2.getFactory());
            if (t2.isEmpty())
              return e3.copy();
            if (e3.isEmpty())
              return t2.copy();
          }
          return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.SYMDIFFERENCE);
        }, Lr.resultDimension = function(t2, e3, n2) {
          var i2 = e3.getDimension(), r2 = n2.getDimension(), o2 = -1;
          switch (t2) {
            case Lr.INTERSECTION:
              o2 = Math.min(i2, r2);
              break;
            case Lr.UNION:
              o2 = Math.max(i2, r2);
              break;
            case Lr.DIFFERENCE:
              o2 = i2;
              break;
            case Lr.SYMDIFFERENCE:
              o2 = Math.max(i2, r2);
          }
          return o2;
        }, Lr.createEmptyResult = function(t2, e3, n2, i2) {
          var r2 = null;
          switch (Lr.resultDimension(t2, e3, n2)) {
            case -1:
              r2 = i2.createGeometryCollection(new Array(0).fill(null));
              break;
            case 0:
              r2 = i2.createPoint();
              break;
            case 1:
              r2 = i2.createLineString();
              break;
            case 2:
              r2 = i2.createPolygon();
          }
          return r2;
        }, Lr.difference = function(t2, e3) {
          return t2.isEmpty() ? Lr.createEmptyResult(Lr.DIFFERENCE, t2, e3, t2.getFactory()) : e3.isEmpty() ? t2.copy() : (t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.DIFFERENCE));
        }, Lr.isResultOfOp = function() {
          if (arguments.length === 2) {
            var t2 = arguments[0], e3 = arguments[1], n2 = t2.getLocation(0), i2 = t2.getLocation(1);
            return Lr.isResultOfOp(n2, i2, e3);
          }
          if (arguments.length === 3) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
            switch (r2 === w.BOUNDARY && (r2 = w.INTERIOR), o2 === w.BOUNDARY && (o2 = w.INTERIOR), s2) {
              case Lr.INTERSECTION:
                return r2 === w.INTERIOR && o2 === w.INTERIOR;
              case Lr.UNION:
                return r2 === w.INTERIOR || o2 === w.INTERIOR;
              case Lr.DIFFERENCE:
                return r2 === w.INTERIOR && o2 !== w.INTERIOR;
              case Lr.SYMDIFFERENCE:
                return r2 === w.INTERIOR && o2 !== w.INTERIOR || r2 !== w.INTERIOR && o2 === w.INTERIOR;
            }
            return false;
          }
        }, Lr.INTERSECTION = 1, Lr.UNION = 2, Lr.DIFFERENCE = 3, Lr.SYMDIFFERENCE = 4;
        var br = function() {
          this._g = null, this._boundaryDistanceTolerance = null, this._linework = null, this._ptLocator = new Si(), this._seg = new dn();
          var t2 = arguments[0], e3 = arguments[1];
          this._g = t2, this._boundaryDistanceTolerance = e3, this._linework = this.extractLinework(t2);
        };
        br.prototype.isWithinToleranceOfBoundary = function(t2) {
          for (var e3 = 0; e3 < this._linework.getNumGeometries(); e3++)
            for (var n2 = this._linework.getGeometryN(e3).getCoordinateSequence(), i2 = 0; i2 < n2.size() - 1; i2++) {
              n2.getCoordinate(i2, this._seg.p0), n2.getCoordinate(i2 + 1, this._seg.p1);
              if (this._seg.distance(t2) <= this._boundaryDistanceTolerance)
                return true;
            }
          return false;
        }, br.prototype.getLocation = function(t2) {
          return this.isWithinToleranceOfBoundary(t2) ? w.BOUNDARY : this._ptLocator.locate(t2, this._g);
        }, br.prototype.extractLinework = function(t2) {
          var e3 = new wr();
          t2.apply(e3);
          var n2 = e3.getLinework(), i2 = _e.toLineStringArray(n2);
          return t2.getFactory().createMultiLineString(i2);
        }, br.prototype.interfaces_ = function() {
          return [];
        }, br.prototype.getClass = function() {
          return br;
        };
        var wr = function() {
          this._linework = null, this._linework = new Nt();
        };
        wr.prototype.getLinework = function() {
          return this._linework;
        }, wr.prototype.filter = function(t2) {
          if (t2 instanceof $t) {
            var e3 = t2;
            this._linework.add(e3.getExteriorRing());
            for (var n2 = 0; n2 < e3.getNumInteriorRing(); n2++)
              this._linework.add(e3.getInteriorRingN(n2));
          }
        }, wr.prototype.interfaces_ = function() {
          return [Vt];
        }, wr.prototype.getClass = function() {
          return wr;
        };
        var Or = function() {
          this._g = null, this._doLeft = true, this._doRight = true;
          var t2 = arguments[0];
          this._g = t2;
        };
        Or.prototype.extractPoints = function(t2, e3, n2) {
          for (var i2 = t2.getCoordinates(), r2 = 0; r2 < i2.length - 1; r2++)
            this.computeOffsetPoints(i2[r2], i2[r2 + 1], e3, n2);
        }, Or.prototype.setSidesToGenerate = function(t2, e3) {
          this._doLeft = t2, this._doRight = e3;
        }, Or.prototype.getPoints = function(t2) {
          for (var e3 = new Nt(), n2 = Ci.getLines(this._g).iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            this.extractPoints(i2, t2, e3);
          }
          return e3;
        }, Or.prototype.computeOffsetPoints = function(t2, e3, n2, i2) {
          var r2 = e3.x - t2.x, o2 = e3.y - t2.y, s2 = Math.sqrt(r2 * r2 + o2 * o2), a2 = n2 * r2 / s2, u2 = n2 * o2 / s2, l2 = (e3.x + t2.x) / 2, c2 = (e3.y + t2.y) / 2;
          if (this._doLeft) {
            var p2 = new C(l2 - u2, c2 + a2);
            i2.add(p2);
          }
          if (this._doRight) {
            var h2 = new C(l2 + u2, c2 - a2);
            i2.add(h2);
          }
        }, Or.prototype.interfaces_ = function() {
          return [];
        }, Or.prototype.getClass = function() {
          return Or;
        };
        var Tr = function t2() {
          this._geom = null, this._locFinder = null, this._location = new Array(3).fill(null), this._invalidLocation = null, this._boundaryDistanceTolerance = t2.TOLERANCE, this._testCoords = new Nt();
          var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          this._boundaryDistanceTolerance = t2.computeBoundaryDistanceTolerance(e3, n2), this._geom = [e3, n2, i2], this._locFinder = [new br(this._geom[0], this._boundaryDistanceTolerance), new br(this._geom[1], this._boundaryDistanceTolerance), new br(this._geom[2], this._boundaryDistanceTolerance)];
        }, Rr = { TOLERANCE: { configurable: true } };
        Tr.prototype.reportResult = function(t2, e3, n2) {
          Y.out.println("Overlay result invalid - A:" + w.toLocationSymbol(e3[0]) + " B:" + w.toLocationSymbol(e3[1]) + " expected:" + (n2 ? "i" : "e") + " actual:" + w.toLocationSymbol(e3[2]));
        }, Tr.prototype.isValid = function(t2) {
          this.addTestPts(this._geom[0]), this.addTestPts(this._geom[1]);
          var e3 = this.checkValid(t2);
          return e3;
        }, Tr.prototype.checkValid = function() {
          if (arguments.length === 1) {
            for (var t2 = arguments[0], e3 = 0; e3 < this._testCoords.size(); e3++) {
              var n2 = this._testCoords.get(e3);
              if (!this.checkValid(t2, n2))
                return this._invalidLocation = n2, false;
            }
            return true;
          }
          if (arguments.length === 2) {
            var i2 = arguments[0], r2 = arguments[1];
            return this._location[0] = this._locFinder[0].getLocation(r2), this._location[1] = this._locFinder[1].getLocation(r2), this._location[2] = this._locFinder[2].getLocation(r2), !!Tr.hasLocation(this._location, w.BOUNDARY) || this.isValidResult(i2, this._location);
          }
        }, Tr.prototype.addTestPts = function(t2) {
          var e3 = new Or(t2);
          this._testCoords.addAll(e3.getPoints(5 * this._boundaryDistanceTolerance));
        }, Tr.prototype.isValidResult = function(t2, e3) {
          var n2 = Lr.isResultOfOp(e3[0], e3[1], t2), i2 = !(n2 ^ e3[2] === w.INTERIOR);
          return i2 || this.reportResult(t2, e3, n2), i2;
        }, Tr.prototype.getInvalidLocation = function() {
          return this._invalidLocation;
        }, Tr.prototype.interfaces_ = function() {
          return [];
        }, Tr.prototype.getClass = function() {
          return Tr;
        }, Tr.hasLocation = function(t2, e3) {
          for (var n2 = 0; n2 < 3; n2++)
            if (t2[n2] === e3)
              return true;
          return false;
        }, Tr.computeBoundaryDistanceTolerance = function(t2, e3) {
          return Math.min(Ji.computeSizeBasedSnapTolerance(t2), Ji.computeSizeBasedSnapTolerance(e3));
        }, Tr.isValid = function(t2, e3, n2, i2) {
          return new Tr(t2, e3, i2).isValid(n2);
        }, Rr.TOLERANCE.get = function() {
          return 1e-6;
        }, Object.defineProperties(Tr, Rr);
        var Pr = function t2(e3) {
          this._geomFactory = null, this._skipEmpty = false, this._inputGeoms = null, this._geomFactory = t2.extractFactory(e3), this._inputGeoms = e3;
        };
        Pr.prototype.extractElements = function(t2, e3) {
          if (t2 === null)
            return null;
          for (var n2 = 0; n2 < t2.getNumGeometries(); n2++) {
            var i2 = t2.getGeometryN(n2);
            this._skipEmpty && i2.isEmpty() || e3.add(i2);
          }
        }, Pr.prototype.combine = function() {
          for (var t2 = new Nt(), e3 = this._inputGeoms.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this.extractElements(n2, t2);
          }
          return t2.size() === 0 ? this._geomFactory !== null ? this._geomFactory.createGeometryCollection(null) : null : this._geomFactory.buildGeometry(t2);
        }, Pr.prototype.interfaces_ = function() {
          return [];
        }, Pr.prototype.getClass = function() {
          return Pr;
        }, Pr.combine = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return new Pr(t2).combine();
          }
          if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            return new Pr(Pr.createList(e3, n2)).combine();
          }
          if (arguments.length === 3) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            return new Pr(Pr.createList(i2, r2, o2)).combine();
          }
        }, Pr.extractFactory = function(t2) {
          return t2.isEmpty() ? null : t2.iterator().next().getFactory();
        }, Pr.createList = function() {
          if (arguments.length === 2) {
            var t2 = arguments[0], e3 = arguments[1], n2 = new Nt();
            return n2.add(t2), n2.add(e3), n2;
          }
          if (arguments.length === 3) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = new Nt();
            return s2.add(i2), s2.add(r2), s2.add(o2), s2;
          }
        };
        var Dr = function() {
          this._inputPolys = null, this._geomFactory = null;
          var t2 = arguments[0];
          this._inputPolys = t2, this._inputPolys === null && (this._inputPolys = new Nt());
        }, Mr = { STRTREE_NODE_CAPACITY: { configurable: true } };
        Dr.prototype.reduceToGeometries = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next(), r2 = null;
            T(i2, xt) ? r2 = this.unionTree(i2) : i2 instanceof ct && (r2 = i2), e3.add(r2);
          }
          return e3;
        }, Dr.prototype.extractByEnvelope = function(t2, e3, n2) {
          for (var i2 = new Nt(), r2 = 0; r2 < e3.getNumGeometries(); r2++) {
            var o2 = e3.getGeometryN(r2);
            o2.getEnvelopeInternal().intersects(t2) ? i2.add(o2) : n2.add(o2);
          }
          return this._geomFactory.buildGeometry(i2);
        }, Dr.prototype.unionOptimized = function(t2, e3) {
          var n2 = t2.getEnvelopeInternal(), i2 = e3.getEnvelopeInternal();
          if (!n2.intersects(i2)) {
            return Pr.combine(t2, e3);
          }
          if (t2.getNumGeometries() <= 1 && e3.getNumGeometries() <= 1)
            return this.unionActual(t2, e3);
          var r2 = n2.intersection(i2);
          return this.unionUsingEnvelopeIntersection(t2, e3, r2);
        }, Dr.prototype.union = function() {
          if (this._inputPolys === null)
            throw new Error("union() method cannot be called twice");
          if (this._inputPolys.isEmpty())
            return null;
          this._geomFactory = this._inputPolys.iterator().next().getFactory();
          for (var t2 = new sn(Dr.STRTREE_NODE_CAPACITY), e3 = this._inputPolys.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            t2.insert(n2.getEnvelopeInternal(), n2);
          }
          this._inputPolys = null;
          var i2 = t2.itemsTree();
          return this.unionTree(i2);
        }, Dr.prototype.binaryUnion = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return this.binaryUnion(t2, 0, t2.size());
          }
          if (arguments.length === 3) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            if (i2 - n2 <= 1) {
              var r2 = Dr.getGeometry(e3, n2);
              return this.unionSafe(r2, null);
            }
            if (i2 - n2 == 2)
              return this.unionSafe(Dr.getGeometry(e3, n2), Dr.getGeometry(e3, n2 + 1));
            var o2 = Math.trunc((i2 + n2) / 2), s2 = this.binaryUnion(e3, n2, o2), a2 = this.binaryUnion(e3, o2, i2);
            return this.unionSafe(s2, a2);
          }
        }, Dr.prototype.repeatedUnion = function(t2) {
          for (var e3 = null, n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            e3 = e3 === null ? i2.copy() : e3.union(i2);
          }
          return e3;
        }, Dr.prototype.unionSafe = function(t2, e3) {
          return t2 === null && e3 === null ? null : t2 === null ? e3.copy() : e3 === null ? t2.copy() : this.unionOptimized(t2, e3);
        }, Dr.prototype.unionActual = function(t2, e3) {
          return Dr.restrictToPolygons(t2.union(e3));
        }, Dr.prototype.unionTree = function(t2) {
          var e3 = this.reduceToGeometries(t2);
          return this.binaryUnion(e3);
        }, Dr.prototype.unionUsingEnvelopeIntersection = function(t2, e3, n2) {
          var i2 = new Nt(), r2 = this.extractByEnvelope(n2, t2, i2), o2 = this.extractByEnvelope(n2, e3, i2), s2 = this.unionActual(r2, o2);
          i2.add(s2);
          return Pr.combine(i2);
        }, Dr.prototype.bufferUnion = function() {
          if (arguments.length === 1) {
            var t2 = arguments[0];
            return t2.get(0).getFactory().buildGeometry(t2).buffer(0);
          }
          if (arguments.length === 2) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3.getFactory().createGeometryCollection([e3, n2]).buffer(0);
          }
        }, Dr.prototype.interfaces_ = function() {
          return [];
        }, Dr.prototype.getClass = function() {
          return Dr;
        }, Dr.restrictToPolygons = function(t2) {
          if (T(t2, Zt))
            return t2;
          var e3 = Ni.getPolygons(t2);
          return e3.size() === 1 ? e3.get(0) : t2.getFactory().createMultiPolygon(_e.toPolygonArray(e3));
        }, Dr.getGeometry = function(t2, e3) {
          return e3 >= t2.size() ? null : t2.get(e3);
        }, Dr.union = function(t2) {
          return new Dr(t2).union();
        }, Mr.STRTREE_NODE_CAPACITY.get = function() {
          return 4;
        }, Object.defineProperties(Dr, Mr);
        var Ar = function() {
        };
        Ar.prototype.interfaces_ = function() {
          return [];
        }, Ar.prototype.getClass = function() {
          return Ar;
        }, Ar.union = function(t2, e3) {
          if (t2.isEmpty() || e3.isEmpty()) {
            if (t2.isEmpty() && e3.isEmpty())
              return Lr.createEmptyResult(Lr.UNION, t2, e3, t2.getFactory());
            if (t2.isEmpty())
              return e3.copy();
            if (e3.isEmpty())
              return t2.copy();
          }
          return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.UNION);
        }, t.GeoJSONReader = Ne, t.GeoJSONWriter = Ce, t.OverlayOp = Lr, t.UnionOp = Ar, t.BufferOp = di, Object.defineProperty(t, "__esModule", { value: true });
      });
    }
  });

  // node_modules/leaflet/dist/leaflet-src.js
  var require_leaflet_src = __commonJS({
    "node_modules/leaflet/dist/leaflet-src.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global.L = {});
      })(exports, function(exports2) {
        "use strict";
        var version = "1.7.1";
        function extend(dest) {
          var i, j, len, src;
          for (j = 1, len = arguments.length; j < len; j++) {
            src = arguments[j];
            for (i in src) {
              dest[i] = src[i];
            }
          }
          return dest;
        }
        var create = Object.create || function() {
          function F() {
          }
          return function(proto) {
            F.prototype = proto;
            return new F();
          };
        }();
        function bind(fn, obj) {
          var slice2 = Array.prototype.slice;
          if (fn.bind) {
            return fn.bind.apply(fn, slice2.call(arguments, 1));
          }
          var args = slice2.call(arguments, 2);
          return function() {
            return fn.apply(obj, args.length ? args.concat(slice2.call(arguments)) : arguments);
          };
        }
        var lastId = 0;
        function stamp(obj) {
          obj._leaflet_id = obj._leaflet_id || ++lastId;
          return obj._leaflet_id;
        }
        function throttle(fn, time, context) {
          var lock, args, wrapperFn, later;
          later = function() {
            lock = false;
            if (args) {
              wrapperFn.apply(context, args);
              args = false;
            }
          };
          wrapperFn = function() {
            if (lock) {
              args = arguments;
            } else {
              fn.apply(context, arguments);
              setTimeout(later, time);
              lock = true;
            }
          };
          return wrapperFn;
        }
        function wrapNum(x2, range, includeMax) {
          var max = range[1], min = range[0], d = max - min;
          return x2 === max && includeMax ? x2 : ((x2 - min) % d + d) % d + min;
        }
        function falseFn() {
          return false;
        }
        function formatNum(num, digits) {
          var pow2 = Math.pow(10, digits === void 0 ? 6 : digits);
          return Math.round(num * pow2) / pow2;
        }
        function trim(str) {
          return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
        }
        function splitWords(str) {
          return trim(str).split(/\s+/);
        }
        function setOptions(obj, options) {
          if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
            obj.options = obj.options ? create(obj.options) : {};
          }
          for (var i in options) {
            obj.options[i] = options[i];
          }
          return obj.options;
        }
        function getParamString(obj, existingUrl, uppercase) {
          var params = [];
          for (var i in obj) {
            params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
          }
          return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
        }
        var templateRe = /\{ *([\w_-]+) *\}/g;
        function template(str, data) {
          return str.replace(templateRe, function(str2, key) {
            var value = data[key];
            if (value === void 0) {
              throw new Error("No value provided for variable " + str2);
            } else if (typeof value === "function") {
              value = value(data);
            }
            return value;
          });
        }
        var isArray = Array.isArray || function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
        function indexOf(array2, el) {
          for (var i = 0; i < array2.length; i++) {
            if (array2[i] === el) {
              return i;
            }
          }
          return -1;
        }
        var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
        function getPrefixed(name) {
          return window["webkit" + name] || window["moz" + name] || window["ms" + name];
        }
        var lastTime = 0;
        function timeoutDefer(fn) {
          var time = +new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
          lastTime = time + timeToCall;
          return window.setTimeout(fn, timeToCall);
        }
        var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
        var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
          window.clearTimeout(id);
        };
        function requestAnimFrame(fn, context, immediate) {
          if (immediate && requestFn === timeoutDefer) {
            fn.call(context);
          } else {
            return requestFn.call(window, bind(fn, context));
          }
        }
        function cancelAnimFrame(id) {
          if (id) {
            cancelFn.call(window, id);
          }
        }
        var Util = {
          extend,
          create,
          bind,
          lastId,
          stamp,
          throttle,
          wrapNum,
          falseFn,
          formatNum,
          trim,
          splitWords,
          setOptions,
          getParamString,
          template,
          isArray,
          indexOf,
          emptyImageUrl,
          requestFn,
          cancelFn,
          requestAnimFrame,
          cancelAnimFrame
        };
        function Class() {
        }
        Class.extend = function(props) {
          var NewClass = function() {
            if (this.initialize) {
              this.initialize.apply(this, arguments);
            }
            this.callInitHooks();
          };
          var parentProto = NewClass.__super__ = this.prototype;
          var proto = create(parentProto);
          proto.constructor = NewClass;
          NewClass.prototype = proto;
          for (var i in this) {
            if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") {
              NewClass[i] = this[i];
            }
          }
          if (props.statics) {
            extend(NewClass, props.statics);
            delete props.statics;
          }
          if (props.includes) {
            checkDeprecatedMixinEvents(props.includes);
            extend.apply(null, [proto].concat(props.includes));
            delete props.includes;
          }
          if (proto.options) {
            props.options = extend(create(proto.options), props.options);
          }
          extend(proto, props);
          proto._initHooks = [];
          proto.callInitHooks = function() {
            if (this._initHooksCalled) {
              return;
            }
            if (parentProto.callInitHooks) {
              parentProto.callInitHooks.call(this);
            }
            this._initHooksCalled = true;
            for (var i2 = 0, len = proto._initHooks.length; i2 < len; i2++) {
              proto._initHooks[i2].call(this);
            }
          };
          return NewClass;
        };
        Class.include = function(props) {
          extend(this.prototype, props);
          return this;
        };
        Class.mergeOptions = function(options) {
          extend(this.prototype.options, options);
          return this;
        };
        Class.addInitHook = function(fn) {
          var args = Array.prototype.slice.call(arguments, 1);
          var init = typeof fn === "function" ? fn : function() {
            this[fn].apply(this, args);
          };
          this.prototype._initHooks = this.prototype._initHooks || [];
          this.prototype._initHooks.push(init);
          return this;
        };
        function checkDeprecatedMixinEvents(includes) {
          if (typeof L === "undefined" || !L || !L.Mixin) {
            return;
          }
          includes = isArray(includes) ? includes : [includes];
          for (var i = 0; i < includes.length; i++) {
            if (includes[i] === L.Mixin.Events) {
              console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
            }
          }
        }
        var Events = {
          on: function(types, fn, context) {
            if (typeof types === "object") {
              for (var type in types) {
                this._on(type, types[type], fn);
              }
            } else {
              types = splitWords(types);
              for (var i = 0, len = types.length; i < len; i++) {
                this._on(types[i], fn, context);
              }
            }
            return this;
          },
          off: function(types, fn, context) {
            if (!types) {
              delete this._events;
            } else if (typeof types === "object") {
              for (var type in types) {
                this._off(type, types[type], fn);
              }
            } else {
              types = splitWords(types);
              for (var i = 0, len = types.length; i < len; i++) {
                this._off(types[i], fn, context);
              }
            }
            return this;
          },
          _on: function(type, fn, context) {
            this._events = this._events || {};
            var typeListeners = this._events[type];
            if (!typeListeners) {
              typeListeners = [];
              this._events[type] = typeListeners;
            }
            if (context === this) {
              context = void 0;
            }
            var newListener = { fn, ctx: context }, listeners = typeListeners;
            for (var i = 0, len = listeners.length; i < len; i++) {
              if (listeners[i].fn === fn && listeners[i].ctx === context) {
                return;
              }
            }
            listeners.push(newListener);
          },
          _off: function(type, fn, context) {
            var listeners, i, len;
            if (!this._events) {
              return;
            }
            listeners = this._events[type];
            if (!listeners) {
              return;
            }
            if (!fn) {
              for (i = 0, len = listeners.length; i < len; i++) {
                listeners[i].fn = falseFn;
              }
              delete this._events[type];
              return;
            }
            if (context === this) {
              context = void 0;
            }
            if (listeners) {
              for (i = 0, len = listeners.length; i < len; i++) {
                var l = listeners[i];
                if (l.ctx !== context) {
                  continue;
                }
                if (l.fn === fn) {
                  l.fn = falseFn;
                  if (this._firingCount) {
                    this._events[type] = listeners = listeners.slice();
                  }
                  listeners.splice(i, 1);
                  return;
                }
              }
            }
          },
          fire: function(type, data, propagate) {
            if (!this.listens(type, propagate)) {
              return this;
            }
            var event = extend({}, data, {
              type,
              target: this,
              sourceTarget: data && data.sourceTarget || this
            });
            if (this._events) {
              var listeners = this._events[type];
              if (listeners) {
                this._firingCount = this._firingCount + 1 || 1;
                for (var i = 0, len = listeners.length; i < len; i++) {
                  var l = listeners[i];
                  l.fn.call(l.ctx || this, event);
                }
                this._firingCount--;
              }
            }
            if (propagate) {
              this._propagateEvent(event);
            }
            return this;
          },
          listens: function(type, propagate) {
            var listeners = this._events && this._events[type];
            if (listeners && listeners.length) {
              return true;
            }
            if (propagate) {
              for (var id in this._eventParents) {
                if (this._eventParents[id].listens(type, propagate)) {
                  return true;
                }
              }
            }
            return false;
          },
          once: function(types, fn, context) {
            if (typeof types === "object") {
              for (var type in types) {
                this.once(type, types[type], fn);
              }
              return this;
            }
            var handler = bind(function() {
              this.off(types, fn, context).off(types, handler, context);
            }, this);
            return this.on(types, fn, context).on(types, handler, context);
          },
          addEventParent: function(obj) {
            this._eventParents = this._eventParents || {};
            this._eventParents[stamp(obj)] = obj;
            return this;
          },
          removeEventParent: function(obj) {
            if (this._eventParents) {
              delete this._eventParents[stamp(obj)];
            }
            return this;
          },
          _propagateEvent: function(e) {
            for (var id in this._eventParents) {
              this._eventParents[id].fire(e.type, extend({
                layer: e.target,
                propagatedFrom: e.target
              }, e), true);
            }
          }
        };
        Events.addEventListener = Events.on;
        Events.removeEventListener = Events.clearAllEventListeners = Events.off;
        Events.addOneTimeEventListener = Events.once;
        Events.fireEvent = Events.fire;
        Events.hasEventListeners = Events.listens;
        var Evented = Class.extend(Events);
        function Point(x2, y2, round) {
          this.x = round ? Math.round(x2) : x2;
          this.y = round ? Math.round(y2) : y2;
        }
        var trunc = Math.trunc || function(v) {
          return v > 0 ? Math.floor(v) : Math.ceil(v);
        };
        Point.prototype = {
          clone: function() {
            return new Point(this.x, this.y);
          },
          add: function(point2) {
            return this.clone()._add(toPoint(point2));
          },
          _add: function(point2) {
            this.x += point2.x;
            this.y += point2.y;
            return this;
          },
          subtract: function(point2) {
            return this.clone()._subtract(toPoint(point2));
          },
          _subtract: function(point2) {
            this.x -= point2.x;
            this.y -= point2.y;
            return this;
          },
          divideBy: function(num) {
            return this.clone()._divideBy(num);
          },
          _divideBy: function(num) {
            this.x /= num;
            this.y /= num;
            return this;
          },
          multiplyBy: function(num) {
            return this.clone()._multiplyBy(num);
          },
          _multiplyBy: function(num) {
            this.x *= num;
            this.y *= num;
            return this;
          },
          scaleBy: function(point2) {
            return new Point(this.x * point2.x, this.y * point2.y);
          },
          unscaleBy: function(point2) {
            return new Point(this.x / point2.x, this.y / point2.y);
          },
          round: function() {
            return this.clone()._round();
          },
          _round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
          },
          floor: function() {
            return this.clone()._floor();
          },
          _floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
          },
          ceil: function() {
            return this.clone()._ceil();
          },
          _ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
          },
          trunc: function() {
            return this.clone()._trunc();
          },
          _trunc: function() {
            this.x = trunc(this.x);
            this.y = trunc(this.y);
            return this;
          },
          distanceTo: function(point2) {
            point2 = toPoint(point2);
            var x2 = point2.x - this.x, y2 = point2.y - this.y;
            return Math.sqrt(x2 * x2 + y2 * y2);
          },
          equals: function(point2) {
            point2 = toPoint(point2);
            return point2.x === this.x && point2.y === this.y;
          },
          contains: function(point2) {
            point2 = toPoint(point2);
            return Math.abs(point2.x) <= Math.abs(this.x) && Math.abs(point2.y) <= Math.abs(this.y);
          },
          toString: function() {
            return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
          }
        };
        function toPoint(x2, y2, round) {
          if (x2 instanceof Point) {
            return x2;
          }
          if (isArray(x2)) {
            return new Point(x2[0], x2[1]);
          }
          if (x2 === void 0 || x2 === null) {
            return x2;
          }
          if (typeof x2 === "object" && "x" in x2 && "y" in x2) {
            return new Point(x2.x, x2.y);
          }
          return new Point(x2, y2, round);
        }
        function Bounds(a, b) {
          if (!a) {
            return;
          }
          var points = b ? [a, b] : a;
          for (var i = 0, len = points.length; i < len; i++) {
            this.extend(points[i]);
          }
        }
        Bounds.prototype = {
          extend: function(point2) {
            point2 = toPoint(point2);
            if (!this.min && !this.max) {
              this.min = point2.clone();
              this.max = point2.clone();
            } else {
              this.min.x = Math.min(point2.x, this.min.x);
              this.max.x = Math.max(point2.x, this.max.x);
              this.min.y = Math.min(point2.y, this.min.y);
              this.max.y = Math.max(point2.y, this.max.y);
            }
            return this;
          },
          getCenter: function(round) {
            return new Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
          },
          getBottomLeft: function() {
            return new Point(this.min.x, this.max.y);
          },
          getTopRight: function() {
            return new Point(this.max.x, this.min.y);
          },
          getTopLeft: function() {
            return this.min;
          },
          getBottomRight: function() {
            return this.max;
          },
          getSize: function() {
            return this.max.subtract(this.min);
          },
          contains: function(obj) {
            var min, max;
            if (typeof obj[0] === "number" || obj instanceof Point) {
              obj = toPoint(obj);
            } else {
              obj = toBounds(obj);
            }
            if (obj instanceof Bounds) {
              min = obj.min;
              max = obj.max;
            } else {
              min = max = obj;
            }
            return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
          },
          intersects: function(bounds) {
            bounds = toBounds(bounds);
            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
            return xIntersects && yIntersects;
          },
          overlaps: function(bounds) {
            bounds = toBounds(bounds);
            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
            return xOverlaps && yOverlaps;
          },
          isValid: function() {
            return !!(this.min && this.max);
          }
        };
        function toBounds(a, b) {
          if (!a || a instanceof Bounds) {
            return a;
          }
          return new Bounds(a, b);
        }
        function LatLngBounds(corner1, corner2) {
          if (!corner1) {
            return;
          }
          var latlngs = corner2 ? [corner1, corner2] : corner1;
          for (var i = 0, len = latlngs.length; i < len; i++) {
            this.extend(latlngs[i]);
          }
        }
        LatLngBounds.prototype = {
          extend: function(obj) {
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof LatLng) {
              sw2 = obj;
              ne2 = obj;
            } else if (obj instanceof LatLngBounds) {
              sw2 = obj._southWest;
              ne2 = obj._northEast;
              if (!sw2 || !ne2) {
                return this;
              }
            } else {
              return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
            }
            if (!sw && !ne) {
              this._southWest = new LatLng(sw2.lat, sw2.lng);
              this._northEast = new LatLng(ne2.lat, ne2.lng);
            } else {
              sw.lat = Math.min(sw2.lat, sw.lat);
              sw.lng = Math.min(sw2.lng, sw.lng);
              ne.lat = Math.max(ne2.lat, ne.lat);
              ne.lng = Math.max(ne2.lng, ne.lng);
            }
            return this;
          },
          pad: function(bufferRatio) {
            var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
            return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
          },
          getCenter: function() {
            return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
          },
          getSouthWest: function() {
            return this._southWest;
          },
          getNorthEast: function() {
            return this._northEast;
          },
          getNorthWest: function() {
            return new LatLng(this.getNorth(), this.getWest());
          },
          getSouthEast: function() {
            return new LatLng(this.getSouth(), this.getEast());
          },
          getWest: function() {
            return this._southWest.lng;
          },
          getSouth: function() {
            return this._southWest.lat;
          },
          getEast: function() {
            return this._northEast.lng;
          },
          getNorth: function() {
            return this._northEast.lat;
          },
          contains: function(obj) {
            if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) {
              obj = toLatLng(obj);
            } else {
              obj = toLatLngBounds(obj);
            }
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof LatLngBounds) {
              sw2 = obj.getSouthWest();
              ne2 = obj.getNorthEast();
            } else {
              sw2 = ne2 = obj;
            }
            return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
          },
          intersects: function(bounds) {
            bounds = toLatLngBounds(bounds);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
            return latIntersects && lngIntersects;
          },
          overlaps: function(bounds) {
            bounds = toLatLngBounds(bounds);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
            return latOverlaps && lngOverlaps;
          },
          toBBoxString: function() {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
          },
          equals: function(bounds, maxMargin) {
            if (!bounds) {
              return false;
            }
            bounds = toLatLngBounds(bounds);
            return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
          },
          isValid: function() {
            return !!(this._southWest && this._northEast);
          }
        };
        function toLatLngBounds(a, b) {
          if (a instanceof LatLngBounds) {
            return a;
          }
          return new LatLngBounds(a, b);
        }
        function LatLng(lat, lng, alt) {
          if (isNaN(lat) || isNaN(lng)) {
            throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
          }
          this.lat = +lat;
          this.lng = +lng;
          if (alt !== void 0) {
            this.alt = +alt;
          }
        }
        LatLng.prototype = {
          equals: function(obj, maxMargin) {
            if (!obj) {
              return false;
            }
            obj = toLatLng(obj);
            var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));
            return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
          },
          toString: function(precision) {
            return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
          },
          distanceTo: function(other) {
            return Earth.distance(this, toLatLng(other));
          },
          wrap: function() {
            return Earth.wrapLatLng(this);
          },
          toBounds: function(sizeInMeters) {
            var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
            return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);
          },
          clone: function() {
            return new LatLng(this.lat, this.lng, this.alt);
          }
        };
        function toLatLng(a, b, c) {
          if (a instanceof LatLng) {
            return a;
          }
          if (isArray(a) && typeof a[0] !== "object") {
            if (a.length === 3) {
              return new LatLng(a[0], a[1], a[2]);
            }
            if (a.length === 2) {
              return new LatLng(a[0], a[1]);
            }
            return null;
          }
          if (a === void 0 || a === null) {
            return a;
          }
          if (typeof a === "object" && "lat" in a) {
            return new LatLng(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
          }
          if (b === void 0) {
            return null;
          }
          return new LatLng(a, b, c);
        }
        var CRS = {
          latLngToPoint: function(latlng, zoom2) {
            var projectedPoint = this.projection.project(latlng), scale2 = this.scale(zoom2);
            return this.transformation._transform(projectedPoint, scale2);
          },
          pointToLatLng: function(point2, zoom2) {
            var scale2 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point2, scale2);
            return this.projection.unproject(untransformedPoint);
          },
          project: function(latlng) {
            return this.projection.project(latlng);
          },
          unproject: function(point2) {
            return this.projection.unproject(point2);
          },
          scale: function(zoom2) {
            return 256 * Math.pow(2, zoom2);
          },
          zoom: function(scale2) {
            return Math.log(scale2 / 256) / Math.LN2;
          },
          getProjectedBounds: function(zoom2) {
            if (this.infinite) {
              return null;
            }
            var b = this.projection.bounds, s = this.scale(zoom2), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);
            return new Bounds(min, max);
          },
          infinite: false,
          wrapLatLng: function(latlng) {
            var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
            return new LatLng(lat, lng, alt);
          },
          wrapLatLngBounds: function(bounds) {
            var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
            if (latShift === 0 && lngShift === 0) {
              return bounds;
            }
            var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
            return new LatLngBounds(newSw, newNe);
          }
        };
        var Earth = extend({}, CRS, {
          wrapLng: [-180, 180],
          R: 6371e3,
          distance: function(latlng1, latlng2) {
            var rad2 = Math.PI / 180, lat1 = latlng1.lat * rad2, lat2 = latlng2.lat * rad2, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad2 / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad2 / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return this.R * c;
          }
        });
        var earthRadius2 = 6378137;
        var SphericalMercator = {
          R: earthRadius2,
          MAX_LATITUDE: 85.0511287798,
          project: function(latlng) {
            var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin2 = Math.sin(lat * d);
            return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin2) / (1 - sin2)) / 2);
          },
          unproject: function(point2) {
            var d = 180 / Math.PI;
            return new LatLng((2 * Math.atan(Math.exp(point2.y / this.R)) - Math.PI / 2) * d, point2.x * d / this.R);
          },
          bounds: function() {
            var d = earthRadius2 * Math.PI;
            return new Bounds([-d, -d], [d, d]);
          }()
        };
        function Transformation(a, b, c, d) {
          if (isArray(a)) {
            this._a = a[0];
            this._b = a[1];
            this._c = a[2];
            this._d = a[3];
            return;
          }
          this._a = a;
          this._b = b;
          this._c = c;
          this._d = d;
        }
        Transformation.prototype = {
          transform: function(point2, scale2) {
            return this._transform(point2.clone(), scale2);
          },
          _transform: function(point2, scale2) {
            scale2 = scale2 || 1;
            point2.x = scale2 * (this._a * point2.x + this._b);
            point2.y = scale2 * (this._c * point2.y + this._d);
            return point2;
          },
          untransform: function(point2, scale2) {
            scale2 = scale2 || 1;
            return new Point((point2.x / scale2 - this._b) / this._a, (point2.y / scale2 - this._d) / this._c);
          }
        };
        function toTransformation(a, b, c, d) {
          return new Transformation(a, b, c, d);
        }
        var EPSG3857 = extend({}, Earth, {
          code: "EPSG:3857",
          projection: SphericalMercator,
          transformation: function() {
            var scale2 = 0.5 / (Math.PI * SphericalMercator.R);
            return toTransformation(scale2, 0.5, -scale2, 0.5);
          }()
        });
        var EPSG900913 = extend({}, EPSG3857, {
          code: "EPSG:900913"
        });
        function svgCreate(name) {
          return document.createElementNS("http://www.w3.org/2000/svg", name);
        }
        function pointsToPath(rings, closed) {
          var str = "", i, j, len, len2, points, p;
          for (i = 0, len = rings.length; i < len; i++) {
            points = rings[i];
            for (j = 0, len2 = points.length; j < len2; j++) {
              p = points[j];
              str += (j ? "L" : "M") + p.x + " " + p.y;
            }
            str += closed ? svg ? "z" : "x" : "";
          }
          return str || "M0 0";
        }
        var style$1 = document.documentElement.style;
        var ie = "ActiveXObject" in window;
        var ielt9 = ie && !document.addEventListener;
        var edge = "msLaunchUri" in navigator && !("documentMode" in document);
        var webkit = userAgentContains("webkit");
        var android = userAgentContains("android");
        var android23 = userAgentContains("android 2") || userAgentContains("android 3");
        var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
        var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
        var opera = !!window.opera;
        var chrome = !edge && userAgentContains("chrome");
        var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
        var safari = !chrome && userAgentContains("safari");
        var phantom = userAgentContains("phantom");
        var opera12 = "OTransition" in style$1;
        var win = navigator.platform.indexOf("Win") === 0;
        var ie3d = ie && "transition" in style$1;
        var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
        var gecko3d = "MozPerspective" in style$1;
        var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
        var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
        var mobileWebkit = mobile && webkit;
        var mobileWebkit3d = mobile && webkit3d;
        var msPointer = !window.PointerEvent && window.MSPointerEvent;
        var pointer = !!(window.PointerEvent || msPointer);
        var touch = !window.L_NO_TOUCH && (pointer || "ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch);
        var mobileOpera = mobile && opera;
        var mobileGecko = mobile && gecko;
        var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
        var passiveEvents = function() {
          var supportsPassiveOption = false;
          try {
            var opts = Object.defineProperty({}, "passive", {
              get: function() {
                supportsPassiveOption = true;
              }
            });
            window.addEventListener("testPassiveEventSupport", falseFn, opts);
            window.removeEventListener("testPassiveEventSupport", falseFn, opts);
          } catch (e) {
          }
          return supportsPassiveOption;
        }();
        var canvas = function() {
          return !!document.createElement("canvas").getContext;
        }();
        var svg = !!(document.createElementNS && svgCreate("svg").createSVGRect);
        var vml = !svg && function() {
          try {
            var div = document.createElement("div");
            div.innerHTML = '<v:shape adj="1"/>';
            var shape = div.firstChild;
            shape.style.behavior = "url(#default#VML)";
            return shape && typeof shape.adj === "object";
          } catch (e) {
            return false;
          }
        }();
        function userAgentContains(str) {
          return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
        }
        var Browser = {
          ie,
          ielt9,
          edge,
          webkit,
          android,
          android23,
          androidStock,
          opera,
          chrome,
          gecko,
          safari,
          phantom,
          opera12,
          win,
          ie3d,
          webkit3d,
          gecko3d,
          any3d,
          mobile,
          mobileWebkit,
          mobileWebkit3d,
          msPointer,
          pointer,
          touch,
          mobileOpera,
          mobileGecko,
          retina,
          passiveEvents,
          canvas,
          svg,
          vml
        };
        var POINTER_DOWN = msPointer ? "MSPointerDown" : "pointerdown";
        var POINTER_MOVE = msPointer ? "MSPointerMove" : "pointermove";
        var POINTER_UP = msPointer ? "MSPointerUp" : "pointerup";
        var POINTER_CANCEL = msPointer ? "MSPointerCancel" : "pointercancel";
        var _pointers = {};
        var _pointerDocListener = false;
        function addPointerListener(obj, type, handler, id) {
          if (type === "touchstart") {
            _addPointerStart(obj, handler, id);
          } else if (type === "touchmove") {
            _addPointerMove(obj, handler, id);
          } else if (type === "touchend") {
            _addPointerEnd(obj, handler, id);
          }
          return this;
        }
        function removePointerListener(obj, type, id) {
          var handler = obj["_leaflet_" + type + id];
          if (type === "touchstart") {
            obj.removeEventListener(POINTER_DOWN, handler, false);
          } else if (type === "touchmove") {
            obj.removeEventListener(POINTER_MOVE, handler, false);
          } else if (type === "touchend") {
            obj.removeEventListener(POINTER_UP, handler, false);
            obj.removeEventListener(POINTER_CANCEL, handler, false);
          }
          return this;
        }
        function _addPointerStart(obj, handler, id) {
          var onDown = bind(function(e) {
            if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
              preventDefault(e);
            }
            _handlePointer(e, handler);
          });
          obj["_leaflet_touchstart" + id] = onDown;
          obj.addEventListener(POINTER_DOWN, onDown, false);
          if (!_pointerDocListener) {
            document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
            document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
            document.addEventListener(POINTER_UP, _globalPointerUp, true);
            document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
            _pointerDocListener = true;
          }
        }
        function _globalPointerDown(e) {
          _pointers[e.pointerId] = e;
        }
        function _globalPointerMove(e) {
          if (_pointers[e.pointerId]) {
            _pointers[e.pointerId] = e;
          }
        }
        function _globalPointerUp(e) {
          delete _pointers[e.pointerId];
        }
        function _handlePointer(e, handler) {
          e.touches = [];
          for (var i in _pointers) {
            e.touches.push(_pointers[i]);
          }
          e.changedTouches = [e];
          handler(e);
        }
        function _addPointerMove(obj, handler, id) {
          var onMove = function(e) {
            if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse") && e.buttons === 0) {
              return;
            }
            _handlePointer(e, handler);
          };
          obj["_leaflet_touchmove" + id] = onMove;
          obj.addEventListener(POINTER_MOVE, onMove, false);
        }
        function _addPointerEnd(obj, handler, id) {
          var onUp = function(e) {
            _handlePointer(e, handler);
          };
          obj["_leaflet_touchend" + id] = onUp;
          obj.addEventListener(POINTER_UP, onUp, false);
          obj.addEventListener(POINTER_CANCEL, onUp, false);
        }
        var _touchstart = msPointer ? "MSPointerDown" : pointer ? "pointerdown" : "touchstart";
        var _touchend = msPointer ? "MSPointerUp" : pointer ? "pointerup" : "touchend";
        var _pre = "_leaflet_";
        function addDoubleTapListener(obj, handler, id) {
          var last, touch$$1, doubleTap = false, delay = 250;
          function onTouchStart(e) {
            if (pointer) {
              if (!e.isPrimary) {
                return;
              }
              if (e.pointerType === "mouse") {
                return;
              }
            } else if (e.touches.length > 1) {
              return;
            }
            var now = Date.now(), delta = now - (last || now);
            touch$$1 = e.touches ? e.touches[0] : e;
            doubleTap = delta > 0 && delta <= delay;
            last = now;
          }
          function onTouchEnd(e) {
            if (doubleTap && !touch$$1.cancelBubble) {
              if (pointer) {
                if (e.pointerType === "mouse") {
                  return;
                }
                var newTouch = {}, prop, i;
                for (i in touch$$1) {
                  prop = touch$$1[i];
                  newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;
                }
                touch$$1 = newTouch;
              }
              touch$$1.type = "dblclick";
              touch$$1.button = 0;
              handler(touch$$1);
              last = null;
            }
          }
          obj[_pre + _touchstart + id] = onTouchStart;
          obj[_pre + _touchend + id] = onTouchEnd;
          obj[_pre + "dblclick" + id] = handler;
          obj.addEventListener(_touchstart, onTouchStart, passiveEvents ? { passive: false } : false);
          obj.addEventListener(_touchend, onTouchEnd, passiveEvents ? { passive: false } : false);
          obj.addEventListener("dblclick", handler, false);
          return this;
        }
        function removeDoubleTapListener(obj, id) {
          var touchstart = obj[_pre + _touchstart + id], touchend = obj[_pre + _touchend + id], dblclick = obj[_pre + "dblclick" + id];
          obj.removeEventListener(_touchstart, touchstart, passiveEvents ? { passive: false } : false);
          obj.removeEventListener(_touchend, touchend, passiveEvents ? { passive: false } : false);
          obj.removeEventListener("dblclick", dblclick, false);
          return this;
        }
        var TRANSFORM = testProp(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]);
        var TRANSITION = testProp(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
        var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
        function get(id) {
          return typeof id === "string" ? document.getElementById(id) : id;
        }
        function getStyle(el, style) {
          var value = el.style[style] || el.currentStyle && el.currentStyle[style];
          if ((!value || value === "auto") && document.defaultView) {
            var css = document.defaultView.getComputedStyle(el, null);
            value = css ? css[style] : null;
          }
          return value === "auto" ? null : value;
        }
        function create$1(tagName, className, container) {
          var el = document.createElement(tagName);
          el.className = className || "";
          if (container) {
            container.appendChild(el);
          }
          return el;
        }
        function remove(el) {
          var parent = el.parentNode;
          if (parent) {
            parent.removeChild(el);
          }
        }
        function empty(el) {
          while (el.firstChild) {
            el.removeChild(el.firstChild);
          }
        }
        function toFront(el) {
          var parent = el.parentNode;
          if (parent && parent.lastChild !== el) {
            parent.appendChild(el);
          }
        }
        function toBack(el) {
          var parent = el.parentNode;
          if (parent && parent.firstChild !== el) {
            parent.insertBefore(el, parent.firstChild);
          }
        }
        function hasClass(el, name) {
          if (el.classList !== void 0) {
            return el.classList.contains(name);
          }
          var className = getClass(el);
          return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
        }
        function addClass(el, name) {
          if (el.classList !== void 0) {
            var classes = splitWords(name);
            for (var i = 0, len = classes.length; i < len; i++) {
              el.classList.add(classes[i]);
            }
          } else if (!hasClass(el, name)) {
            var className = getClass(el);
            setClass(el, (className ? className + " " : "") + name);
          }
        }
        function removeClass(el, name) {
          if (el.classList !== void 0) {
            el.classList.remove(name);
          } else {
            setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
          }
        }
        function setClass(el, name) {
          if (el.className.baseVal === void 0) {
            el.className = name;
          } else {
            el.className.baseVal = name;
          }
        }
        function getClass(el) {
          if (el.correspondingElement) {
            el = el.correspondingElement;
          }
          return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
        }
        function setOpacity(el, value) {
          if ("opacity" in el.style) {
            el.style.opacity = value;
          } else if ("filter" in el.style) {
            _setOpacityIE(el, value);
          }
        }
        function _setOpacityIE(el, value) {
          var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
          try {
            filter = el.filters.item(filterName);
          } catch (e) {
            if (value === 1) {
              return;
            }
          }
          value = Math.round(value * 100);
          if (filter) {
            filter.Enabled = value !== 100;
            filter.Opacity = value;
          } else {
            el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
          }
        }
        function testProp(props) {
          var style = document.documentElement.style;
          for (var i = 0; i < props.length; i++) {
            if (props[i] in style) {
              return props[i];
            }
          }
          return false;
        }
        function setTransform(el, offset, scale2) {
          var pos = offset || new Point(0, 0);
          el.style[TRANSFORM] = (ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
        }
        function setPosition(el, point2) {
          el._leaflet_pos = point2;
          if (any3d) {
            setTransform(el, point2);
          } else {
            el.style.left = point2.x + "px";
            el.style.top = point2.y + "px";
          }
        }
        function getPosition(el) {
          return el._leaflet_pos || new Point(0, 0);
        }
        var disableTextSelection;
        var enableTextSelection;
        var _userSelect;
        if ("onselectstart" in document) {
          disableTextSelection = function() {
            on(window, "selectstart", preventDefault);
          };
          enableTextSelection = function() {
            off(window, "selectstart", preventDefault);
          };
        } else {
          var userSelectProperty = testProp(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
          disableTextSelection = function() {
            if (userSelectProperty) {
              var style = document.documentElement.style;
              _userSelect = style[userSelectProperty];
              style[userSelectProperty] = "none";
            }
          };
          enableTextSelection = function() {
            if (userSelectProperty) {
              document.documentElement.style[userSelectProperty] = _userSelect;
              _userSelect = void 0;
            }
          };
        }
        function disableImageDrag() {
          on(window, "dragstart", preventDefault);
        }
        function enableImageDrag() {
          off(window, "dragstart", preventDefault);
        }
        var _outlineElement, _outlineStyle;
        function preventOutline(element) {
          while (element.tabIndex === -1) {
            element = element.parentNode;
          }
          if (!element.style) {
            return;
          }
          restoreOutline();
          _outlineElement = element;
          _outlineStyle = element.style.outline;
          element.style.outline = "none";
          on(window, "keydown", restoreOutline);
        }
        function restoreOutline() {
          if (!_outlineElement) {
            return;
          }
          _outlineElement.style.outline = _outlineStyle;
          _outlineElement = void 0;
          _outlineStyle = void 0;
          off(window, "keydown", restoreOutline);
        }
        function getSizedParentNode(element) {
          do {
            element = element.parentNode;
          } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
          return element;
        }
        function getScale(element) {
          var rect = element.getBoundingClientRect();
          return {
            x: rect.width / element.offsetWidth || 1,
            y: rect.height / element.offsetHeight || 1,
            boundingClientRect: rect
          };
        }
        var DomUtil = {
          TRANSFORM,
          TRANSITION,
          TRANSITION_END,
          get,
          getStyle,
          create: create$1,
          remove,
          empty,
          toFront,
          toBack,
          hasClass,
          addClass,
          removeClass,
          setClass,
          getClass,
          setOpacity,
          testProp,
          setTransform,
          setPosition,
          getPosition,
          disableTextSelection,
          enableTextSelection,
          disableImageDrag,
          enableImageDrag,
          preventOutline,
          restoreOutline,
          getSizedParentNode,
          getScale
        };
        function on(obj, types, fn, context) {
          if (typeof types === "object") {
            for (var type in types) {
              addOne(obj, type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            for (var i = 0, len = types.length; i < len; i++) {
              addOne(obj, types[i], fn, context);
            }
          }
          return this;
        }
        var eventsKey = "_leaflet_events";
        function off(obj, types, fn, context) {
          if (typeof types === "object") {
            for (var type in types) {
              removeOne(obj, type, types[type], fn);
            }
          } else if (types) {
            types = splitWords(types);
            for (var i = 0, len = types.length; i < len; i++) {
              removeOne(obj, types[i], fn, context);
            }
          } else {
            for (var j in obj[eventsKey]) {
              removeOne(obj, j, obj[eventsKey][j]);
            }
            delete obj[eventsKey];
          }
          return this;
        }
        function browserFiresNativeDblClick() {
          if (pointer) {
            return !(edge || safari);
          }
        }
        var mouseSubst = {
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          wheel: !("onwheel" in window) && "mousewheel"
        };
        function addOne(obj, type, fn, context) {
          var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
          if (obj[eventsKey] && obj[eventsKey][id]) {
            return this;
          }
          var handler = function(e) {
            return fn.call(context || obj, e || window.event);
          };
          var originalHandler = handler;
          if (pointer && type.indexOf("touch") === 0) {
            addPointerListener(obj, type, handler, id);
          } else if (touch && type === "dblclick" && !browserFiresNativeDblClick()) {
            addDoubleTapListener(obj, handler, id);
          } else if ("addEventListener" in obj) {
            if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
              obj.addEventListener(mouseSubst[type] || type, handler, passiveEvents ? { passive: false } : false);
            } else if (type === "mouseenter" || type === "mouseleave") {
              handler = function(e) {
                e = e || window.event;
                if (isExternalTarget(obj, e)) {
                  originalHandler(e);
                }
              };
              obj.addEventListener(mouseSubst[type], handler, false);
            } else {
              obj.addEventListener(type, originalHandler, false);
            }
          } else if ("attachEvent" in obj) {
            obj.attachEvent("on" + type, handler);
          }
          obj[eventsKey] = obj[eventsKey] || {};
          obj[eventsKey][id] = handler;
        }
        function removeOne(obj, type, fn, context) {
          var id = type + stamp(fn) + (context ? "_" + stamp(context) : ""), handler = obj[eventsKey] && obj[eventsKey][id];
          if (!handler) {
            return this;
          }
          if (pointer && type.indexOf("touch") === 0) {
            removePointerListener(obj, type, id);
          } else if (touch && type === "dblclick" && !browserFiresNativeDblClick()) {
            removeDoubleTapListener(obj, id);
          } else if ("removeEventListener" in obj) {
            obj.removeEventListener(mouseSubst[type] || type, handler, false);
          } else if ("detachEvent" in obj) {
            obj.detachEvent("on" + type, handler);
          }
          obj[eventsKey][id] = null;
        }
        function stopPropagation(e) {
          if (e.stopPropagation) {
            e.stopPropagation();
          } else if (e.originalEvent) {
            e.originalEvent._stopped = true;
          } else {
            e.cancelBubble = true;
          }
          skipped(e);
          return this;
        }
        function disableScrollPropagation(el) {
          addOne(el, "wheel", stopPropagation);
          return this;
        }
        function disableClickPropagation(el) {
          on(el, "mousedown touchstart dblclick", stopPropagation);
          addOne(el, "click", fakeStop);
          return this;
        }
        function preventDefault(e) {
          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
          return this;
        }
        function stop(e) {
          preventDefault(e);
          stopPropagation(e);
          return this;
        }
        function getMousePosition(e, container) {
          if (!container) {
            return new Point(e.clientX, e.clientY);
          }
          var scale2 = getScale(container), offset = scale2.boundingClientRect;
          return new Point((e.clientX - offset.left) / scale2.x - container.clientLeft, (e.clientY - offset.top) / scale2.y - container.clientTop);
        }
        var wheelPxFactor = win && chrome ? 2 * window.devicePixelRatio : gecko ? window.devicePixelRatio : 1;
        function getWheelDelta(e) {
          return edge ? e.wheelDeltaY / 2 : e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : e.deltaX || e.deltaZ ? 0 : e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : e.detail ? e.detail / -32765 * 60 : 0;
        }
        var skipEvents = {};
        function fakeStop(e) {
          skipEvents[e.type] = true;
        }
        function skipped(e) {
          var events = skipEvents[e.type];
          skipEvents[e.type] = false;
          return events;
        }
        function isExternalTarget(el, e) {
          var related = e.relatedTarget;
          if (!related) {
            return true;
          }
          try {
            while (related && related !== el) {
              related = related.parentNode;
            }
          } catch (err) {
            return false;
          }
          return related !== el;
        }
        var DomEvent = {
          on,
          off,
          stopPropagation,
          disableScrollPropagation,
          disableClickPropagation,
          preventDefault,
          stop,
          getMousePosition,
          getWheelDelta,
          fakeStop,
          skipped,
          isExternalTarget,
          addListener: on,
          removeListener: off
        };
        var PosAnimation = Evented.extend({
          run: function(el, newPos, duration, easeLinearity) {
            this.stop();
            this._el = el;
            this._inProgress = true;
            this._duration = duration || 0.25;
            this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
            this._startPos = getPosition(el);
            this._offset = newPos.subtract(this._startPos);
            this._startTime = +new Date();
            this.fire("start");
            this._animate();
          },
          stop: function() {
            if (!this._inProgress) {
              return;
            }
            this._step(true);
            this._complete();
          },
          _animate: function() {
            this._animId = requestAnimFrame(this._animate, this);
            this._step();
          },
          _step: function(round) {
            var elapsed = +new Date() - this._startTime, duration = this._duration * 1e3;
            if (elapsed < duration) {
              this._runFrame(this._easeOut(elapsed / duration), round);
            } else {
              this._runFrame(1);
              this._complete();
            }
          },
          _runFrame: function(progress, round) {
            var pos = this._startPos.add(this._offset.multiplyBy(progress));
            if (round) {
              pos._round();
            }
            setPosition(this._el, pos);
            this.fire("step");
          },
          _complete: function() {
            cancelAnimFrame(this._animId);
            this._inProgress = false;
            this.fire("end");
          },
          _easeOut: function(t) {
            return 1 - Math.pow(1 - t, this._easeOutPower);
          }
        });
        var Map2 = Evented.extend({
          options: {
            crs: EPSG3857,
            center: void 0,
            zoom: void 0,
            minZoom: void 0,
            maxZoom: void 0,
            layers: [],
            maxBounds: void 0,
            renderer: void 0,
            zoomAnimation: true,
            zoomAnimationThreshold: 4,
            fadeAnimation: true,
            markerZoomAnimation: true,
            transform3DLimit: 8388608,
            zoomSnap: 1,
            zoomDelta: 1,
            trackResize: true
          },
          initialize: function(id, options) {
            options = setOptions(this, options);
            this._handlers = [];
            this._layers = {};
            this._zoomBoundLayers = {};
            this._sizeChanged = true;
            this._initContainer(id);
            this._initLayout();
            this._onResize = bind(this._onResize, this);
            this._initEvents();
            if (options.maxBounds) {
              this.setMaxBounds(options.maxBounds);
            }
            if (options.zoom !== void 0) {
              this._zoom = this._limitZoom(options.zoom);
            }
            if (options.center && options.zoom !== void 0) {
              this.setView(toLatLng(options.center), options.zoom, { reset: true });
            }
            this.callInitHooks();
            this._zoomAnimated = TRANSITION && any3d && !mobileOpera && this.options.zoomAnimation;
            if (this._zoomAnimated) {
              this._createAnimProxy();
              on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
            }
            this._addLayers(this.options.layers);
          },
          setView: function(center, zoom2, options) {
            zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
            center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
            options = options || {};
            this._stop();
            if (this._loaded && !options.reset && options !== true) {
              if (options.animate !== void 0) {
                options.zoom = extend({ animate: options.animate }, options.zoom);
                options.pan = extend({ animate: options.animate, duration: options.duration }, options.pan);
              }
              var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options.zoom) : this._tryAnimatedPan(center, options.pan);
              if (moved) {
                clearTimeout(this._sizeTimer);
                return this;
              }
            }
            this._resetView(center, zoom2);
            return this;
          },
          setZoom: function(zoom2, options) {
            if (!this._loaded) {
              this._zoom = zoom2;
              return this;
            }
            return this.setView(this.getCenter(), zoom2, { zoom: options });
          },
          zoomIn: function(delta, options) {
            delta = delta || (any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom + delta, options);
          },
          zoomOut: function(delta, options) {
            delta = delta || (any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom - delta, options);
          },
          setZoomAround: function(latlng, zoom2, options) {
            var scale2 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale2), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
            return this.setView(newCenter, zoom2, { zoom: options });
          },
          _getBoundsCenterZoom: function(bounds, options) {
            options = options || {};
            bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
            zoom2 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom2) : zoom2;
            if (zoom2 === Infinity) {
              return {
                center: bounds.getCenter(),
                zoom: zoom2
              };
            }
            var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
            return {
              center,
              zoom: zoom2
            };
          },
          fitBounds: function(bounds, options) {
            bounds = toLatLngBounds(bounds);
            if (!bounds.isValid()) {
              throw new Error("Bounds are not valid.");
            }
            var target = this._getBoundsCenterZoom(bounds, options);
            return this.setView(target.center, target.zoom, options);
          },
          fitWorld: function(options) {
            return this.fitBounds([[-90, -180], [90, 180]], options);
          },
          panTo: function(center, options) {
            return this.setView(center, this._zoom, { pan: options });
          },
          panBy: function(offset, options) {
            offset = toPoint(offset).round();
            options = options || {};
            if (!offset.x && !offset.y) {
              return this.fire("moveend");
            }
            if (options.animate !== true && !this.getSize().contains(offset)) {
              this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
              return this;
            }
            if (!this._panAnim) {
              this._panAnim = new PosAnimation();
              this._panAnim.on({
                "step": this._onPanTransitionStep,
                "end": this._onPanTransitionEnd
              }, this);
            }
            if (!options.noMoveStart) {
              this.fire("movestart");
            }
            if (options.animate !== false) {
              addClass(this._mapPane, "leaflet-pan-anim");
              var newPos = this._getMapPanePos().subtract(offset).round();
              this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
            } else {
              this._rawPanBy(offset);
              this.fire("move").fire("moveend");
            }
            return this;
          },
          flyTo: function(targetCenter, targetZoom, options) {
            options = options || {};
            if (options.animate === false || !any3d) {
              return this.setView(targetCenter, targetZoom, options);
            }
            this._stop();
            var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
            targetCenter = toLatLng(targetCenter);
            targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
            var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
            function r(i) {
              var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
              var log2 = sq < 1e-9 ? -18 : Math.log(sq);
              return log2;
            }
            function sinh(n) {
              return (Math.exp(n) - Math.exp(-n)) / 2;
            }
            function cosh(n) {
              return (Math.exp(n) + Math.exp(-n)) / 2;
            }
            function tanh(n) {
              return sinh(n) / cosh(n);
            }
            var r0 = r(0);
            function w(s) {
              return w0 * (cosh(r0) / cosh(r0 + rho * s));
            }
            function u(s) {
              return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
            }
            function easeOut(t) {
              return 1 - Math.pow(1 - t, 1.5);
            }
            var start = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S * 0.8;
            function frame() {
              var t = (Date.now() - start) / duration, s = easeOut(t) * S;
              if (t <= 1) {
                this._flyToFrame = requestAnimFrame(frame, this);
                this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), { flyTo: true });
              } else {
                this._move(targetCenter, targetZoom)._moveEnd(true);
              }
            }
            this._moveStart(true, options.noMoveStart);
            frame.call(this);
            return this;
          },
          flyToBounds: function(bounds, options) {
            var target = this._getBoundsCenterZoom(bounds, options);
            return this.flyTo(target.center, target.zoom, options);
          },
          setMaxBounds: function(bounds) {
            bounds = toLatLngBounds(bounds);
            if (!bounds.isValid()) {
              this.options.maxBounds = null;
              return this.off("moveend", this._panInsideMaxBounds);
            } else if (this.options.maxBounds) {
              this.off("moveend", this._panInsideMaxBounds);
            }
            this.options.maxBounds = bounds;
            if (this._loaded) {
              this._panInsideMaxBounds();
            }
            return this.on("moveend", this._panInsideMaxBounds);
          },
          setMinZoom: function(zoom2) {
            var oldZoom = this.options.minZoom;
            this.options.minZoom = zoom2;
            if (this._loaded && oldZoom !== zoom2) {
              this.fire("zoomlevelschange");
              if (this.getZoom() < this.options.minZoom) {
                return this.setZoom(zoom2);
              }
            }
            return this;
          },
          setMaxZoom: function(zoom2) {
            var oldZoom = this.options.maxZoom;
            this.options.maxZoom = zoom2;
            if (this._loaded && oldZoom !== zoom2) {
              this.fire("zoomlevelschange");
              if (this.getZoom() > this.options.maxZoom) {
                return this.setZoom(zoom2);
              }
            }
            return this;
          },
          panInsideBounds: function(bounds, options) {
            this._enforcingBounds = true;
            var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
            if (!center.equals(newCenter)) {
              this.panTo(newCenter, options);
            }
            this._enforcingBounds = false;
            return this;
          },
          panInside: function(latlng, options) {
            options = options || {};
            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), center = this.getCenter(), pixelCenter = this.project(center), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), halfPixelBounds = pixelBounds.getSize().divideBy(2), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);
            if (!paddedBounds.contains(pixelPoint)) {
              this._enforcingBounds = true;
              var diff = pixelCenter.subtract(pixelPoint), newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);
              if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {
                newCenter.x = pixelCenter.x - diff.x;
                if (diff.x > 0) {
                  newCenter.x += halfPixelBounds.x - paddingTL.x;
                } else {
                  newCenter.x -= halfPixelBounds.x - paddingBR.x;
                }
              }
              if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {
                newCenter.y = pixelCenter.y - diff.y;
                if (diff.y > 0) {
                  newCenter.y += halfPixelBounds.y - paddingTL.y;
                } else {
                  newCenter.y -= halfPixelBounds.y - paddingBR.y;
                }
              }
              this.panTo(this.unproject(newCenter), options);
              this._enforcingBounds = false;
            }
            return this;
          },
          invalidateSize: function(options) {
            if (!this._loaded) {
              return this;
            }
            options = extend({
              animate: false,
              pan: true
            }, options === true ? { animate: true } : options);
            var oldSize = this.getSize();
            this._sizeChanged = true;
            this._lastCenter = null;
            var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
            if (!offset.x && !offset.y) {
              return this;
            }
            if (options.animate && options.pan) {
              this.panBy(offset);
            } else {
              if (options.pan) {
                this._rawPanBy(offset);
              }
              this.fire("move");
              if (options.debounceMoveend) {
                clearTimeout(this._sizeTimer);
                this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
              } else {
                this.fire("moveend");
              }
            }
            return this.fire("resize", {
              oldSize,
              newSize
            });
          },
          stop: function() {
            this.setZoom(this._limitZoom(this._zoom));
            if (!this.options.zoomSnap) {
              this.fire("viewreset");
            }
            return this._stop();
          },
          locate: function(options) {
            options = this._locateOptions = extend({
              timeout: 1e4,
              watch: false
            }, options);
            if (!("geolocation" in navigator)) {
              this._handleGeolocationError({
                code: 0,
                message: "Geolocation not supported."
              });
              return this;
            }
            var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
            if (options.watch) {
              this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
            } else {
              navigator.geolocation.getCurrentPosition(onResponse, onError, options);
            }
            return this;
          },
          stopLocate: function() {
            if (navigator.geolocation && navigator.geolocation.clearWatch) {
              navigator.geolocation.clearWatch(this._locationWatchId);
            }
            if (this._locateOptions) {
              this._locateOptions.setView = false;
            }
            return this;
          },
          _handleGeolocationError: function(error) {
            var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
            if (this._locateOptions.setView && !this._loaded) {
              this.fitWorld();
            }
            this.fire("locationerror", {
              code: c,
              message: "Geolocation error: " + message + "."
            });
          },
          _handleGeolocationResponse: function(pos) {
            var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
            if (options.setView) {
              var zoom2 = this.getBoundsZoom(bounds);
              this.setView(latlng, options.maxZoom ? Math.min(zoom2, options.maxZoom) : zoom2);
            }
            var data = {
              latlng,
              bounds,
              timestamp: pos.timestamp
            };
            for (var i in pos.coords) {
              if (typeof pos.coords[i] === "number") {
                data[i] = pos.coords[i];
              }
            }
            this.fire("locationfound", data);
          },
          addHandler: function(name, HandlerClass) {
            if (!HandlerClass) {
              return this;
            }
            var handler = this[name] = new HandlerClass(this);
            this._handlers.push(handler);
            if (this.options[name]) {
              handler.enable();
            }
            return this;
          },
          remove: function() {
            this._initEvents(true);
            this.off("moveend", this._panInsideMaxBounds);
            if (this._containerId !== this._container._leaflet_id) {
              throw new Error("Map container is being reused by another instance");
            }
            try {
              delete this._container._leaflet_id;
              delete this._containerId;
            } catch (e) {
              this._container._leaflet_id = void 0;
              this._containerId = void 0;
            }
            if (this._locationWatchId !== void 0) {
              this.stopLocate();
            }
            this._stop();
            remove(this._mapPane);
            if (this._clearControlPos) {
              this._clearControlPos();
            }
            if (this._resizeRequest) {
              cancelAnimFrame(this._resizeRequest);
              this._resizeRequest = null;
            }
            this._clearHandlers();
            if (this._loaded) {
              this.fire("unload");
            }
            var i;
            for (i in this._layers) {
              this._layers[i].remove();
            }
            for (i in this._panes) {
              remove(this._panes[i]);
            }
            this._layers = [];
            this._panes = [];
            delete this._mapPane;
            delete this._renderer;
            return this;
          },
          createPane: function(name, container) {
            var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
            if (name) {
              this._panes[name] = pane;
            }
            return pane;
          },
          getCenter: function() {
            this._checkIfLoaded();
            if (this._lastCenter && !this._moved()) {
              return this._lastCenter;
            }
            return this.layerPointToLatLng(this._getCenterLayerPoint());
          },
          getZoom: function() {
            return this._zoom;
          },
          getBounds: function() {
            var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
            return new LatLngBounds(sw, ne);
          },
          getMinZoom: function() {
            return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
          },
          getMaxZoom: function() {
            return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
          },
          getBoundsZoom: function(bounds, inside, padding) {
            bounds = toLatLngBounds(bounds);
            padding = toPoint(padding || [0, 0]);
            var zoom2 = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom2), this.project(nw, zoom2)).getSize(), snap = any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
            zoom2 = this.getScaleZoom(scale2, zoom2);
            if (snap) {
              zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
              zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
            }
            return Math.max(min, Math.min(max, zoom2));
          },
          getSize: function() {
            if (!this._size || this._sizeChanged) {
              this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);
              this._sizeChanged = false;
            }
            return this._size.clone();
          },
          getPixelBounds: function(center, zoom2) {
            var topLeftPoint = this._getTopLeftPoint(center, zoom2);
            return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
          },
          getPixelOrigin: function() {
            this._checkIfLoaded();
            return this._pixelOrigin;
          },
          getPixelWorldBounds: function(zoom2) {
            return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
          },
          getPane: function(pane) {
            return typeof pane === "string" ? this._panes[pane] : pane;
          },
          getPanes: function() {
            return this._panes;
          },
          getContainer: function() {
            return this._container;
          },
          getZoomScale: function(toZoom, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
            return crs.scale(toZoom) / crs.scale(fromZoom);
          },
          getScaleZoom: function(scale2, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
            var zoom2 = crs.zoom(scale2 * crs.scale(fromZoom));
            return isNaN(zoom2) ? Infinity : zoom2;
          },
          project: function(latlng, zoom2) {
            zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
            return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
          },
          unproject: function(point2, zoom2) {
            zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
            return this.options.crs.pointToLatLng(toPoint(point2), zoom2);
          },
          layerPointToLatLng: function(point2) {
            var projectedPoint = toPoint(point2).add(this.getPixelOrigin());
            return this.unproject(projectedPoint);
          },
          latLngToLayerPoint: function(latlng) {
            var projectedPoint = this.project(toLatLng(latlng))._round();
            return projectedPoint._subtract(this.getPixelOrigin());
          },
          wrapLatLng: function(latlng) {
            return this.options.crs.wrapLatLng(toLatLng(latlng));
          },
          wrapLatLngBounds: function(latlng) {
            return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
          },
          distance: function(latlng1, latlng2) {
            return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
          },
          containerPointToLayerPoint: function(point2) {
            return toPoint(point2).subtract(this._getMapPanePos());
          },
          layerPointToContainerPoint: function(point2) {
            return toPoint(point2).add(this._getMapPanePos());
          },
          containerPointToLatLng: function(point2) {
            var layerPoint = this.containerPointToLayerPoint(toPoint(point2));
            return this.layerPointToLatLng(layerPoint);
          },
          latLngToContainerPoint: function(latlng) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
          },
          mouseEventToContainerPoint: function(e) {
            return getMousePosition(e, this._container);
          },
          mouseEventToLayerPoint: function(e) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
          },
          mouseEventToLatLng: function(e) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
          },
          _initContainer: function(id) {
            var container = this._container = get(id);
            if (!container) {
              throw new Error("Map container not found.");
            } else if (container._leaflet_id) {
              throw new Error("Map container is already initialized.");
            }
            on(container, "scroll", this._onScroll, this);
            this._containerId = stamp(container);
          },
          _initLayout: function() {
            var container = this._container;
            this._fadeAnimated = this.options.fadeAnimation && any3d;
            addClass(container, "leaflet-container" + (touch ? " leaflet-touch" : "") + (retina ? " leaflet-retina" : "") + (ielt9 ? " leaflet-oldie" : "") + (safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
            var position = getStyle(container, "position");
            if (position !== "absolute" && position !== "relative" && position !== "fixed") {
              container.style.position = "relative";
            }
            this._initPanes();
            if (this._initControlPos) {
              this._initControlPos();
            }
          },
          _initPanes: function() {
            var panes = this._panes = {};
            this._paneRenderers = {};
            this._mapPane = this.createPane("mapPane", this._container);
            setPosition(this._mapPane, new Point(0, 0));
            this.createPane("tilePane");
            this.createPane("shadowPane");
            this.createPane("overlayPane");
            this.createPane("markerPane");
            this.createPane("tooltipPane");
            this.createPane("popupPane");
            if (!this.options.markerZoomAnimation) {
              addClass(panes.markerPane, "leaflet-zoom-hide");
              addClass(panes.shadowPane, "leaflet-zoom-hide");
            }
          },
          _resetView: function(center, zoom2) {
            setPosition(this._mapPane, new Point(0, 0));
            var loading = !this._loaded;
            this._loaded = true;
            zoom2 = this._limitZoom(zoom2);
            this.fire("viewprereset");
            var zoomChanged = this._zoom !== zoom2;
            this._moveStart(zoomChanged, false)._move(center, zoom2)._moveEnd(zoomChanged);
            this.fire("viewreset");
            if (loading) {
              this.fire("load");
            }
          },
          _moveStart: function(zoomChanged, noMoveStart) {
            if (zoomChanged) {
              this.fire("zoomstart");
            }
            if (!noMoveStart) {
              this.fire("movestart");
            }
            return this;
          },
          _move: function(center, zoom2, data) {
            if (zoom2 === void 0) {
              zoom2 = this._zoom;
            }
            var zoomChanged = this._zoom !== zoom2;
            this._zoom = zoom2;
            this._lastCenter = center;
            this._pixelOrigin = this._getNewPixelOrigin(center);
            if (zoomChanged || data && data.pinch) {
              this.fire("zoom", data);
            }
            return this.fire("move", data);
          },
          _moveEnd: function(zoomChanged) {
            if (zoomChanged) {
              this.fire("zoomend");
            }
            return this.fire("moveend");
          },
          _stop: function() {
            cancelAnimFrame(this._flyToFrame);
            if (this._panAnim) {
              this._panAnim.stop();
            }
            return this;
          },
          _rawPanBy: function(offset) {
            setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
          },
          _getZoomSpan: function() {
            return this.getMaxZoom() - this.getMinZoom();
          },
          _panInsideMaxBounds: function() {
            if (!this._enforcingBounds) {
              this.panInsideBounds(this.options.maxBounds);
            }
          },
          _checkIfLoaded: function() {
            if (!this._loaded) {
              throw new Error("Set map center and zoom first.");
            }
          },
          _initEvents: function(remove$$1) {
            this._targets = {};
            this._targets[stamp(this._container)] = this;
            var onOff = remove$$1 ? off : on;
            onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
            if (this.options.trackResize) {
              onOff(window, "resize", this._onResize, this);
            }
            if (any3d && this.options.transform3DLimit) {
              (remove$$1 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
            }
          },
          _onResize: function() {
            cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = requestAnimFrame(function() {
              this.invalidateSize({ debounceMoveend: true });
            }, this);
          },
          _onScroll: function() {
            this._container.scrollTop = 0;
            this._container.scrollLeft = 0;
          },
          _onMoveEnd: function() {
            var pos = this._getMapPanePos();
            if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
              this._resetView(this.getCenter(), this.getZoom());
            }
          },
          _findEventTargets: function(e, type) {
            var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = false;
            while (src) {
              target = this._targets[stamp(src)];
              if (target && (type === "click" || type === "preclick") && !e._simulated && this._draggableMoved(target)) {
                dragging = true;
                break;
              }
              if (target && target.listens(type, true)) {
                if (isHover && !isExternalTarget(src, e)) {
                  break;
                }
                targets.push(target);
                if (isHover) {
                  break;
                }
              }
              if (src === this._container) {
                break;
              }
              src = src.parentNode;
            }
            if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {
              targets = [this];
            }
            return targets;
          },
          _handleDOMEvent: function(e) {
            if (!this._loaded || skipped(e)) {
              return;
            }
            var type = e.type;
            if (type === "mousedown" || type === "keypress" || type === "keyup" || type === "keydown") {
              preventOutline(e.target || e.srcElement);
            }
            this._fireDOMEvent(e, type);
          },
          _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
          _fireDOMEvent: function(e, type, targets) {
            if (e.type === "click") {
              var synth = extend({}, e);
              synth.type = "preclick";
              this._fireDOMEvent(synth, synth.type, targets);
            }
            if (e._stopped) {
              return;
            }
            targets = (targets || []).concat(this._findEventTargets(e, type));
            if (!targets.length) {
              return;
            }
            var target = targets[0];
            if (type === "contextmenu" && target.listens(type, true)) {
              preventDefault(e);
            }
            var data = {
              originalEvent: e
            };
            if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
              var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
              data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
              data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
              data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
            }
            for (var i = 0; i < targets.length; i++) {
              targets[i].fire(type, data, true);
              if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
                return;
              }
            }
          },
          _draggableMoved: function(obj) {
            obj = obj.dragging && obj.dragging.enabled() ? obj : this;
            return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
          },
          _clearHandlers: function() {
            for (var i = 0, len = this._handlers.length; i < len; i++) {
              this._handlers[i].disable();
            }
          },
          whenReady: function(callback, context) {
            if (this._loaded) {
              callback.call(context || this, { target: this });
            } else {
              this.on("load", callback, context);
            }
            return this;
          },
          _getMapPanePos: function() {
            return getPosition(this._mapPane) || new Point(0, 0);
          },
          _moved: function() {
            var pos = this._getMapPanePos();
            return pos && !pos.equals([0, 0]);
          },
          _getTopLeftPoint: function(center, zoom2) {
            var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
            return pixelOrigin.subtract(this._getMapPanePos());
          },
          _getNewPixelOrigin: function(center, zoom2) {
            var viewHalf = this.getSize()._divideBy(2);
            return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
          },
          _latLngToNewLayerPoint: function(latlng, zoom2, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom2);
            return this.project(latlng, zoom2)._subtract(topLeft);
          },
          _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom2, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom2);
            return toBounds([
              this.project(latLngBounds.getSouthWest(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getNorthWest(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getSouthEast(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getNorthEast(), zoom2)._subtract(topLeft)
            ]);
          },
          _getCenterLayerPoint: function() {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
          },
          _getCenterOffset: function(latlng) {
            return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
          },
          _limitCenter: function(center, zoom2, bounds) {
            if (!bounds) {
              return center;
            }
            var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom2);
            if (offset.round().equals([0, 0])) {
              return center;
            }
            return this.unproject(centerPoint.add(offset), zoom2);
          },
          _limitOffset: function(offset, bounds) {
            if (!bounds) {
              return offset;
            }
            var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
            return offset.add(this._getBoundsOffset(newBounds, bounds));
          },
          _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
            var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom2), this.project(maxBounds.getSouthWest(), zoom2)), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
            return new Point(dx, dy);
          },
          _rebound: function(left, right) {
            return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
          },
          _limitZoom: function(zoom2) {
            var min = this.getMinZoom(), max = this.getMaxZoom(), snap = any3d ? this.options.zoomSnap : 1;
            if (snap) {
              zoom2 = Math.round(zoom2 / snap) * snap;
            }
            return Math.max(min, Math.min(max, zoom2));
          },
          _onPanTransitionStep: function() {
            this.fire("move");
          },
          _onPanTransitionEnd: function() {
            removeClass(this._mapPane, "leaflet-pan-anim");
            this.fire("moveend");
          },
          _tryAnimatedPan: function(center, options) {
            var offset = this._getCenterOffset(center)._trunc();
            if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
              return false;
            }
            this.panBy(offset, options);
            return true;
          },
          _createAnimProxy: function() {
            var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
            this._panes.mapPane.appendChild(proxy);
            this.on("zoomanim", function(e) {
              var prop = TRANSFORM, transform = this._proxy.style[prop];
              setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
              if (transform === this._proxy.style[prop] && this._animatingZoom) {
                this._onZoomTransitionEnd();
              }
            }, this);
            this.on("load moveend", this._animMoveEnd, this);
            this._on("unload", this._destroyAnimProxy, this);
          },
          _destroyAnimProxy: function() {
            remove(this._proxy);
            this.off("load moveend", this._animMoveEnd, this);
            delete this._proxy;
          },
          _animMoveEnd: function() {
            var c = this.getCenter(), z = this.getZoom();
            setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
          },
          _catchTransitionEnd: function(e) {
            if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
              this._onZoomTransitionEnd();
            }
          },
          _nothingToAnimate: function() {
            return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
          },
          _tryAnimatedZoom: function(center, zoom2, options) {
            if (this._animatingZoom) {
              return true;
            }
            options = options || {};
            if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
              return false;
            }
            var scale2 = this.getZoomScale(zoom2), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale2);
            if (options.animate !== true && !this.getSize().contains(offset)) {
              return false;
            }
            requestAnimFrame(function() {
              this._moveStart(true, false)._animateZoom(center, zoom2, true);
            }, this);
            return true;
          },
          _animateZoom: function(center, zoom2, startAnim, noUpdate) {
            if (!this._mapPane) {
              return;
            }
            if (startAnim) {
              this._animatingZoom = true;
              this._animateToCenter = center;
              this._animateToZoom = zoom2;
              addClass(this._mapPane, "leaflet-zoom-anim");
            }
            this.fire("zoomanim", {
              center,
              zoom: zoom2,
              noUpdate
            });
            setTimeout(bind(this._onZoomTransitionEnd, this), 250);
          },
          _onZoomTransitionEnd: function() {
            if (!this._animatingZoom) {
              return;
            }
            if (this._mapPane) {
              removeClass(this._mapPane, "leaflet-zoom-anim");
            }
            this._animatingZoom = false;
            this._move(this._animateToCenter, this._animateToZoom);
            requestAnimFrame(function() {
              this._moveEnd(true);
            }, this);
          }
        });
        function createMap(id, options) {
          return new Map2(id, options);
        }
        var Control = Class.extend({
          options: {
            position: "topright"
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          getPosition: function() {
            return this.options.position;
          },
          setPosition: function(position) {
            var map2 = this._map;
            if (map2) {
              map2.removeControl(this);
            }
            this.options.position = position;
            if (map2) {
              map2.addControl(this);
            }
            return this;
          },
          getContainer: function() {
            return this._container;
          },
          addTo: function(map2) {
            this.remove();
            this._map = map2;
            var container = this._container = this.onAdd(map2), pos = this.getPosition(), corner = map2._controlCorners[pos];
            addClass(container, "leaflet-control");
            if (pos.indexOf("bottom") !== -1) {
              corner.insertBefore(container, corner.firstChild);
            } else {
              corner.appendChild(container);
            }
            this._map.on("unload", this.remove, this);
            return this;
          },
          remove: function() {
            if (!this._map) {
              return this;
            }
            remove(this._container);
            if (this.onRemove) {
              this.onRemove(this._map);
            }
            this._map.off("unload", this.remove, this);
            this._map = null;
            return this;
          },
          _refocusOnMap: function(e) {
            if (this._map && e && e.screenX > 0 && e.screenY > 0) {
              this._map.getContainer().focus();
            }
          }
        });
        var control = function(options) {
          return new Control(options);
        };
        Map2.include({
          addControl: function(control2) {
            control2.addTo(this);
            return this;
          },
          removeControl: function(control2) {
            control2.remove();
            return this;
          },
          _initControlPos: function() {
            var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create$1("div", l + "control-container", this._container);
            function createCorner(vSide, hSide) {
              var className = l + vSide + " " + l + hSide;
              corners[vSide + hSide] = create$1("div", className, container);
            }
            createCorner("top", "left");
            createCorner("top", "right");
            createCorner("bottom", "left");
            createCorner("bottom", "right");
          },
          _clearControlPos: function() {
            for (var i in this._controlCorners) {
              remove(this._controlCorners[i]);
            }
            remove(this._controlContainer);
            delete this._controlCorners;
            delete this._controlContainer;
          }
        });
        var Layers = Control.extend({
          options: {
            collapsed: true,
            position: "topright",
            autoZIndex: true,
            hideSingleBase: false,
            sortLayers: false,
            sortFunction: function(layerA, layerB, nameA, nameB) {
              return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
            }
          },
          initialize: function(baseLayers, overlays, options) {
            setOptions(this, options);
            this._layerControlInputs = [];
            this._layers = [];
            this._lastZIndex = 0;
            this._handlingClick = false;
            for (var i in baseLayers) {
              this._addLayer(baseLayers[i], i);
            }
            for (i in overlays) {
              this._addLayer(overlays[i], i, true);
            }
          },
          onAdd: function(map2) {
            this._initLayout();
            this._update();
            this._map = map2;
            map2.on("zoomend", this._checkDisabledLayers, this);
            for (var i = 0; i < this._layers.length; i++) {
              this._layers[i].layer.on("add remove", this._onLayerChange, this);
            }
            return this._container;
          },
          addTo: function(map2) {
            Control.prototype.addTo.call(this, map2);
            return this._expandIfNotCollapsed();
          },
          onRemove: function() {
            this._map.off("zoomend", this._checkDisabledLayers, this);
            for (var i = 0; i < this._layers.length; i++) {
              this._layers[i].layer.off("add remove", this._onLayerChange, this);
            }
          },
          addBaseLayer: function(layer, name) {
            this._addLayer(layer, name);
            return this._map ? this._update() : this;
          },
          addOverlay: function(layer, name) {
            this._addLayer(layer, name, true);
            return this._map ? this._update() : this;
          },
          removeLayer: function(layer) {
            layer.off("add remove", this._onLayerChange, this);
            var obj = this._getLayer(stamp(layer));
            if (obj) {
              this._layers.splice(this._layers.indexOf(obj), 1);
            }
            return this._map ? this._update() : this;
          },
          expand: function() {
            addClass(this._container, "leaflet-control-layers-expanded");
            this._section.style.height = null;
            var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
            if (acceptableHeight < this._section.clientHeight) {
              addClass(this._section, "leaflet-control-layers-scrollbar");
              this._section.style.height = acceptableHeight + "px";
            } else {
              removeClass(this._section, "leaflet-control-layers-scrollbar");
            }
            this._checkDisabledLayers();
            return this;
          },
          collapse: function() {
            removeClass(this._container, "leaflet-control-layers-expanded");
            return this;
          },
          _initLayout: function() {
            var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
            container.setAttribute("aria-haspopup", true);
            disableClickPropagation(container);
            disableScrollPropagation(container);
            var section = this._section = create$1("section", className + "-list");
            if (collapsed) {
              this._map.on("click", this.collapse, this);
              if (!android) {
                on(container, {
                  mouseenter: this.expand,
                  mouseleave: this.collapse
                }, this);
              }
            }
            var link2 = this._layersLink = create$1("a", className + "-toggle", container);
            link2.href = "#";
            link2.title = "Layers";
            if (touch) {
              on(link2, "click", stop);
              on(link2, "click", this.expand, this);
            } else {
              on(link2, "focus", this.expand, this);
            }
            if (!collapsed) {
              this.expand();
            }
            this._baseLayersList = create$1("div", className + "-base", section);
            this._separator = create$1("div", className + "-separator", section);
            this._overlaysList = create$1("div", className + "-overlays", section);
            container.appendChild(section);
          },
          _getLayer: function(id) {
            for (var i = 0; i < this._layers.length; i++) {
              if (this._layers[i] && stamp(this._layers[i].layer) === id) {
                return this._layers[i];
              }
            }
          },
          _addLayer: function(layer, name, overlay) {
            if (this._map) {
              layer.on("add remove", this._onLayerChange, this);
            }
            this._layers.push({
              layer,
              name,
              overlay
            });
            if (this.options.sortLayers) {
              this._layers.sort(bind(function(a, b) {
                return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
              }, this));
            }
            if (this.options.autoZIndex && layer.setZIndex) {
              this._lastZIndex++;
              layer.setZIndex(this._lastZIndex);
            }
            this._expandIfNotCollapsed();
          },
          _update: function() {
            if (!this._container) {
              return this;
            }
            empty(this._baseLayersList);
            empty(this._overlaysList);
            this._layerControlInputs = [];
            var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;
            for (i = 0; i < this._layers.length; i++) {
              obj = this._layers[i];
              this._addItem(obj);
              overlaysPresent = overlaysPresent || obj.overlay;
              baseLayersPresent = baseLayersPresent || !obj.overlay;
              baseLayersCount += !obj.overlay ? 1 : 0;
            }
            if (this.options.hideSingleBase) {
              baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
              this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
            }
            this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
            return this;
          },
          _onLayerChange: function(e) {
            if (!this._handlingClick) {
              this._update();
            }
            var obj = this._getLayer(stamp(e.target));
            var type = obj.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
            if (type) {
              this._map.fire(type, obj);
            }
          },
          _createRadioElement: function(name, checked) {
            var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
            var radioFragment = document.createElement("div");
            radioFragment.innerHTML = radioHtml;
            return radioFragment.firstChild;
          },
          _addItem: function(obj) {
            var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
            if (obj.overlay) {
              input = document.createElement("input");
              input.type = "checkbox";
              input.className = "leaflet-control-layers-selector";
              input.defaultChecked = checked;
            } else {
              input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
            }
            this._layerControlInputs.push(input);
            input.layerId = stamp(obj.layer);
            on(input, "click", this._onInputClick, this);
            var name = document.createElement("span");
            name.innerHTML = " " + obj.name;
            var holder = document.createElement("div");
            label.appendChild(holder);
            holder.appendChild(input);
            holder.appendChild(name);
            var container = obj.overlay ? this._overlaysList : this._baseLayersList;
            container.appendChild(label);
            this._checkDisabledLayers();
            return label;
          },
          _onInputClick: function() {
            var inputs = this._layerControlInputs, input, layer;
            var addedLayers = [], removedLayers = [];
            this._handlingClick = true;
            for (var i = inputs.length - 1; i >= 0; i--) {
              input = inputs[i];
              layer = this._getLayer(input.layerId).layer;
              if (input.checked) {
                addedLayers.push(layer);
              } else if (!input.checked) {
                removedLayers.push(layer);
              }
            }
            for (i = 0; i < removedLayers.length; i++) {
              if (this._map.hasLayer(removedLayers[i])) {
                this._map.removeLayer(removedLayers[i]);
              }
            }
            for (i = 0; i < addedLayers.length; i++) {
              if (!this._map.hasLayer(addedLayers[i])) {
                this._map.addLayer(addedLayers[i]);
              }
            }
            this._handlingClick = false;
            this._refocusOnMap();
          },
          _checkDisabledLayers: function() {
            var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
            for (var i = inputs.length - 1; i >= 0; i--) {
              input = inputs[i];
              layer = this._getLayer(input.layerId).layer;
              input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
            }
          },
          _expandIfNotCollapsed: function() {
            if (this._map && !this.options.collapsed) {
              this.expand();
            }
            return this;
          },
          _expand: function() {
            return this.expand();
          },
          _collapse: function() {
            return this.collapse();
          }
        });
        var layers = function(baseLayers, overlays, options) {
          return new Layers(baseLayers, overlays, options);
        };
        var Zoom = Control.extend({
          options: {
            position: "topleft",
            zoomInText: "+",
            zoomInTitle: "Zoom in",
            zoomOutText: "&#x2212;",
            zoomOutTitle: "Zoom out"
          },
          onAdd: function(map2) {
            var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
            this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + "-in", container, this._zoomIn);
            this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + "-out", container, this._zoomOut);
            this._updateDisabled();
            map2.on("zoomend zoomlevelschange", this._updateDisabled, this);
            return container;
          },
          onRemove: function(map2) {
            map2.off("zoomend zoomlevelschange", this._updateDisabled, this);
          },
          disable: function() {
            this._disabled = true;
            this._updateDisabled();
            return this;
          },
          enable: function() {
            this._disabled = false;
            this._updateDisabled();
            return this;
          },
          _zoomIn: function(e) {
            if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
              this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
          },
          _zoomOut: function(e) {
            if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
              this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
          },
          _createButton: function(html, title, className, container, fn) {
            var link2 = create$1("a", className, container);
            link2.innerHTML = html;
            link2.href = "#";
            link2.title = title;
            link2.setAttribute("role", "button");
            link2.setAttribute("aria-label", title);
            disableClickPropagation(link2);
            on(link2, "click", stop);
            on(link2, "click", fn, this);
            on(link2, "click", this._refocusOnMap, this);
            return link2;
          },
          _updateDisabled: function() {
            var map2 = this._map, className = "leaflet-disabled";
            removeClass(this._zoomInButton, className);
            removeClass(this._zoomOutButton, className);
            if (this._disabled || map2._zoom === map2.getMinZoom()) {
              addClass(this._zoomOutButton, className);
            }
            if (this._disabled || map2._zoom === map2.getMaxZoom()) {
              addClass(this._zoomInButton, className);
            }
          }
        });
        Map2.mergeOptions({
          zoomControl: true
        });
        Map2.addInitHook(function() {
          if (this.options.zoomControl) {
            this.zoomControl = new Zoom();
            this.addControl(this.zoomControl);
          }
        });
        var zoom = function(options) {
          return new Zoom(options);
        };
        var Scale = Control.extend({
          options: {
            position: "bottomleft",
            maxWidth: 100,
            metric: true,
            imperial: true
          },
          onAdd: function(map2) {
            var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
            this._addScales(options, className + "-line", container);
            map2.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
            map2.whenReady(this._update, this);
            return container;
          },
          onRemove: function(map2) {
            map2.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
          },
          _addScales: function(options, className, container) {
            if (options.metric) {
              this._mScale = create$1("div", className, container);
            }
            if (options.imperial) {
              this._iScale = create$1("div", className, container);
            }
          },
          _update: function() {
            var map2 = this._map, y2 = map2.getSize().y / 2;
            var maxMeters = map2.distance(map2.containerPointToLatLng([0, y2]), map2.containerPointToLatLng([this.options.maxWidth, y2]));
            this._updateScales(maxMeters);
          },
          _updateScales: function(maxMeters) {
            if (this.options.metric && maxMeters) {
              this._updateMetric(maxMeters);
            }
            if (this.options.imperial && maxMeters) {
              this._updateImperial(maxMeters);
            }
          },
          _updateMetric: function(maxMeters) {
            var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
            this._updateScale(this._mScale, label, meters / maxMeters);
          },
          _updateImperial: function(maxMeters) {
            var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
            if (maxFeet > 5280) {
              maxMiles = maxFeet / 5280;
              miles = this._getRoundNum(maxMiles);
              this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
            } else {
              feet = this._getRoundNum(maxFeet);
              this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
            }
          },
          _updateScale: function(scale2, text, ratio) {
            scale2.style.width = Math.round(this.options.maxWidth * ratio) + "px";
            scale2.innerHTML = text;
          },
          _getRoundNum: function(num) {
            var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
            d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
            return pow10 * d;
          }
        });
        var scale = function(options) {
          return new Scale(options);
        };
        var Attribution = Control.extend({
          options: {
            position: "bottomright",
            prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
          },
          initialize: function(options) {
            setOptions(this, options);
            this._attributions = {};
          },
          onAdd: function(map2) {
            map2.attributionControl = this;
            this._container = create$1("div", "leaflet-control-attribution");
            disableClickPropagation(this._container);
            for (var i in map2._layers) {
              if (map2._layers[i].getAttribution) {
                this.addAttribution(map2._layers[i].getAttribution());
              }
            }
            this._update();
            return this._container;
          },
          setPrefix: function(prefix) {
            this.options.prefix = prefix;
            this._update();
            return this;
          },
          addAttribution: function(text) {
            if (!text) {
              return this;
            }
            if (!this._attributions[text]) {
              this._attributions[text] = 0;
            }
            this._attributions[text]++;
            this._update();
            return this;
          },
          removeAttribution: function(text) {
            if (!text) {
              return this;
            }
            if (this._attributions[text]) {
              this._attributions[text]--;
              this._update();
            }
            return this;
          },
          _update: function() {
            if (!this._map) {
              return;
            }
            var attribs = [];
            for (var i in this._attributions) {
              if (this._attributions[i]) {
                attribs.push(i);
              }
            }
            var prefixAndAttribs = [];
            if (this.options.prefix) {
              prefixAndAttribs.push(this.options.prefix);
            }
            if (attribs.length) {
              prefixAndAttribs.push(attribs.join(", "));
            }
            this._container.innerHTML = prefixAndAttribs.join(" | ");
          }
        });
        Map2.mergeOptions({
          attributionControl: true
        });
        Map2.addInitHook(function() {
          if (this.options.attributionControl) {
            new Attribution().addTo(this);
          }
        });
        var attribution = function(options) {
          return new Attribution(options);
        };
        Control.Layers = Layers;
        Control.Zoom = Zoom;
        Control.Scale = Scale;
        Control.Attribution = Attribution;
        control.layers = layers;
        control.zoom = zoom;
        control.scale = scale;
        control.attribution = attribution;
        var Handler = Class.extend({
          initialize: function(map2) {
            this._map = map2;
          },
          enable: function() {
            if (this._enabled) {
              return this;
            }
            this._enabled = true;
            this.addHooks();
            return this;
          },
          disable: function() {
            if (!this._enabled) {
              return this;
            }
            this._enabled = false;
            this.removeHooks();
            return this;
          },
          enabled: function() {
            return !!this._enabled;
          }
        });
        Handler.addTo = function(map2, name) {
          map2.addHandler(name, this);
          return this;
        };
        var Mixin = { Events };
        var START = touch ? "touchstart mousedown" : "mousedown";
        var END = {
          mousedown: "mouseup",
          touchstart: "touchend",
          pointerdown: "touchend",
          MSPointerDown: "touchend"
        };
        var MOVE = {
          mousedown: "mousemove",
          touchstart: "touchmove",
          pointerdown: "touchmove",
          MSPointerDown: "touchmove"
        };
        var Draggable = Evented.extend({
          options: {
            clickTolerance: 3
          },
          initialize: function(element, dragStartTarget, preventOutline$$1, options) {
            setOptions(this, options);
            this._element = element;
            this._dragStartTarget = dragStartTarget || element;
            this._preventOutline = preventOutline$$1;
          },
          enable: function() {
            if (this._enabled) {
              return;
            }
            on(this._dragStartTarget, START, this._onDown, this);
            this._enabled = true;
          },
          disable: function() {
            if (!this._enabled) {
              return;
            }
            if (Draggable._dragging === this) {
              this.finishDrag();
            }
            off(this._dragStartTarget, START, this._onDown, this);
            this._enabled = false;
            this._moved = false;
          },
          _onDown: function(e) {
            if (e._simulated || !this._enabled) {
              return;
            }
            this._moved = false;
            if (hasClass(this._element, "leaflet-zoom-anim")) {
              return;
            }
            if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
              return;
            }
            Draggable._dragging = this;
            if (this._preventOutline) {
              preventOutline(this._element);
            }
            disableImageDrag();
            disableTextSelection();
            if (this._moving) {
              return;
            }
            this.fire("down");
            var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
            this._startPoint = new Point(first.clientX, first.clientY);
            this._parentScale = getScale(sizedParent);
            on(document, MOVE[e.type], this._onMove, this);
            on(document, END[e.type], this._onUp, this);
          },
          _onMove: function(e) {
            if (e._simulated || !this._enabled) {
              return;
            }
            if (e.touches && e.touches.length > 1) {
              this._moved = true;
              return;
            }
            var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
            if (!offset.x && !offset.y) {
              return;
            }
            if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
              return;
            }
            offset.x /= this._parentScale.x;
            offset.y /= this._parentScale.y;
            preventDefault(e);
            if (!this._moved) {
              this.fire("dragstart");
              this._moved = true;
              this._startPos = getPosition(this._element).subtract(offset);
              addClass(document.body, "leaflet-dragging");
              this._lastTarget = e.target || e.srcElement;
              if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
                this._lastTarget = this._lastTarget.correspondingUseElement;
              }
              addClass(this._lastTarget, "leaflet-drag-target");
            }
            this._newPos = this._startPos.add(offset);
            this._moving = true;
            cancelAnimFrame(this._animRequest);
            this._lastEvent = e;
            this._animRequest = requestAnimFrame(this._updatePosition, this, true);
          },
          _updatePosition: function() {
            var e = { originalEvent: this._lastEvent };
            this.fire("predrag", e);
            setPosition(this._element, this._newPos);
            this.fire("drag", e);
          },
          _onUp: function(e) {
            if (e._simulated || !this._enabled) {
              return;
            }
            this.finishDrag();
          },
          finishDrag: function() {
            removeClass(document.body, "leaflet-dragging");
            if (this._lastTarget) {
              removeClass(this._lastTarget, "leaflet-drag-target");
              this._lastTarget = null;
            }
            for (var i in MOVE) {
              off(document, MOVE[i], this._onMove, this);
              off(document, END[i], this._onUp, this);
            }
            enableImageDrag();
            enableTextSelection();
            if (this._moved && this._moving) {
              cancelAnimFrame(this._animRequest);
              this.fire("dragend", {
                distance: this._newPos.distanceTo(this._startPos)
              });
            }
            this._moving = false;
            Draggable._dragging = false;
          }
        });
        function simplify(points, tolerance) {
          if (!tolerance || !points.length) {
            return points.slice();
          }
          var sqTolerance = tolerance * tolerance;
          points = _reducePoints(points, sqTolerance);
          points = _simplifyDP(points, sqTolerance);
          return points;
        }
        function pointToSegmentDistance(p, p1, p2) {
          return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
        }
        function closestPointOnSegment(p, p1, p2) {
          return _sqClosestPointOnSegment(p, p1, p2);
        }
        function _simplifyDP(points, sqTolerance) {
          var len = points.length, ArrayConstructor = typeof Uint8Array !== void 0 + "" ? Uint8Array : Array, markers = new ArrayConstructor(len);
          markers[0] = markers[len - 1] = 1;
          _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
          var i, newPoints = [];
          for (i = 0; i < len; i++) {
            if (markers[i]) {
              newPoints.push(points[i]);
            }
          }
          return newPoints;
        }
        function _simplifyDPStep(points, markers, sqTolerance, first, last) {
          var maxSqDist = 0, index2, i, sqDist;
          for (i = first + 1; i <= last - 1; i++) {
            sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);
            if (sqDist > maxSqDist) {
              index2 = i;
              maxSqDist = sqDist;
            }
          }
          if (maxSqDist > sqTolerance) {
            markers[index2] = 1;
            _simplifyDPStep(points, markers, sqTolerance, first, index2);
            _simplifyDPStep(points, markers, sqTolerance, index2, last);
          }
        }
        function _reducePoints(points, sqTolerance) {
          var reducedPoints = [points[0]];
          for (var i = 1, prev = 0, len = points.length; i < len; i++) {
            if (_sqDist(points[i], points[prev]) > sqTolerance) {
              reducedPoints.push(points[i]);
              prev = i;
            }
          }
          if (prev < len - 1) {
            reducedPoints.push(points[len - 1]);
          }
          return reducedPoints;
        }
        var _lastCode;
        function clipSegment(a, b, bounds, useLastCode, round) {
          var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p, newCode;
          _lastCode = codeB;
          while (true) {
            if (!(codeA | codeB)) {
              return [a, b];
            }
            if (codeA & codeB) {
              return false;
            }
            codeOut = codeA || codeB;
            p = _getEdgeIntersection(a, b, codeOut, bounds, round);
            newCode = _getBitCode(p, bounds);
            if (codeOut === codeA) {
              a = p;
              codeA = newCode;
            } else {
              b = p;
              codeB = newCode;
            }
          }
        }
        function _getEdgeIntersection(a, b, code, bounds, round) {
          var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max, x2, y2;
          if (code & 8) {
            x2 = a.x + dx * (max.y - a.y) / dy;
            y2 = max.y;
          } else if (code & 4) {
            x2 = a.x + dx * (min.y - a.y) / dy;
            y2 = min.y;
          } else if (code & 2) {
            x2 = max.x;
            y2 = a.y + dy * (max.x - a.x) / dx;
          } else if (code & 1) {
            x2 = min.x;
            y2 = a.y + dy * (min.x - a.x) / dx;
          }
          return new Point(x2, y2, round);
        }
        function _getBitCode(p, bounds) {
          var code = 0;
          if (p.x < bounds.min.x) {
            code |= 1;
          } else if (p.x > bounds.max.x) {
            code |= 2;
          }
          if (p.y < bounds.min.y) {
            code |= 4;
          } else if (p.y > bounds.max.y) {
            code |= 8;
          }
          return code;
        }
        function _sqDist(p1, p2) {
          var dx = p2.x - p1.x, dy = p2.y - p1.y;
          return dx * dx + dy * dy;
        }
        function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
          var x2 = p1.x, y2 = p1.y, dx = p2.x - x2, dy = p2.y - y2, dot = dx * dx + dy * dy, t;
          if (dot > 0) {
            t = ((p.x - x2) * dx + (p.y - y2) * dy) / dot;
            if (t > 1) {
              x2 = p2.x;
              y2 = p2.y;
            } else if (t > 0) {
              x2 += dx * t;
              y2 += dy * t;
            }
          }
          dx = p.x - x2;
          dy = p.y - y2;
          return sqDist ? dx * dx + dy * dy : new Point(x2, y2);
        }
        function isFlat(latlngs) {
          return !isArray(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
        }
        function _flat(latlngs) {
          console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
          return isFlat(latlngs);
        }
        var LineUtil = {
          simplify,
          pointToSegmentDistance,
          closestPointOnSegment,
          clipSegment,
          _getEdgeIntersection,
          _getBitCode,
          _sqClosestPointOnSegment,
          isFlat,
          _flat
        };
        function clipPolygon(points, bounds, round) {
          var clippedPoints, edges2 = [1, 4, 2, 8], i, j, k, a, b, len, edge2, p;
          for (i = 0, len = points.length; i < len; i++) {
            points[i]._code = _getBitCode(points[i], bounds);
          }
          for (k = 0; k < 4; k++) {
            edge2 = edges2[k];
            clippedPoints = [];
            for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
              a = points[i];
              b = points[j];
              if (!(a._code & edge2)) {
                if (b._code & edge2) {
                  p = _getEdgeIntersection(b, a, edge2, bounds, round);
                  p._code = _getBitCode(p, bounds);
                  clippedPoints.push(p);
                }
                clippedPoints.push(a);
              } else if (!(b._code & edge2)) {
                p = _getEdgeIntersection(b, a, edge2, bounds, round);
                p._code = _getBitCode(p, bounds);
                clippedPoints.push(p);
              }
            }
            points = clippedPoints;
          }
          return points;
        }
        var PolyUtil = {
          clipPolygon
        };
        var LonLat = {
          project: function(latlng) {
            return new Point(latlng.lng, latlng.lat);
          },
          unproject: function(point2) {
            return new LatLng(point2.y, point2.x);
          },
          bounds: new Bounds([-180, -90], [180, 90])
        };
        var Mercator = {
          R: 6378137,
          R_MINOR: 6356752314245179e-9,
          bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
          project: function(latlng) {
            var d = Math.PI / 180, r = this.R, y2 = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y2);
            var ts = Math.tan(Math.PI / 4 - y2 / 2) / Math.pow((1 - con) / (1 + con), e / 2);
            y2 = -r * Math.log(Math.max(ts, 1e-10));
            return new Point(latlng.lng * d * r, y2);
          },
          unproject: function(point2) {
            var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point2.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);
            for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
              con = e * Math.sin(phi);
              con = Math.pow((1 - con) / (1 + con), e / 2);
              dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
              phi += dphi;
            }
            return new LatLng(phi * d, point2.x * d / r);
          }
        };
        var index = {
          LonLat,
          Mercator,
          SphericalMercator
        };
        var EPSG3395 = extend({}, Earth, {
          code: "EPSG:3395",
          projection: Mercator,
          transformation: function() {
            var scale2 = 0.5 / (Math.PI * Mercator.R);
            return toTransformation(scale2, 0.5, -scale2, 0.5);
          }()
        });
        var EPSG4326 = extend({}, Earth, {
          code: "EPSG:4326",
          projection: LonLat,
          transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
        });
        var Simple = extend({}, CRS, {
          projection: LonLat,
          transformation: toTransformation(1, 0, -1, 0),
          scale: function(zoom2) {
            return Math.pow(2, zoom2);
          },
          zoom: function(scale2) {
            return Math.log(scale2) / Math.LN2;
          },
          distance: function(latlng1, latlng2) {
            var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
            return Math.sqrt(dx * dx + dy * dy);
          },
          infinite: true
        });
        CRS.Earth = Earth;
        CRS.EPSG3395 = EPSG3395;
        CRS.EPSG3857 = EPSG3857;
        CRS.EPSG900913 = EPSG900913;
        CRS.EPSG4326 = EPSG4326;
        CRS.Simple = Simple;
        var Layer = Evented.extend({
          options: {
            pane: "overlayPane",
            attribution: null,
            bubblingMouseEvents: true
          },
          addTo: function(map2) {
            map2.addLayer(this);
            return this;
          },
          remove: function() {
            return this.removeFrom(this._map || this._mapToAdd);
          },
          removeFrom: function(obj) {
            if (obj) {
              obj.removeLayer(this);
            }
            return this;
          },
          getPane: function(name) {
            return this._map.getPane(name ? this.options[name] || name : this.options.pane);
          },
          addInteractiveTarget: function(targetEl) {
            this._map._targets[stamp(targetEl)] = this;
            return this;
          },
          removeInteractiveTarget: function(targetEl) {
            delete this._map._targets[stamp(targetEl)];
            return this;
          },
          getAttribution: function() {
            return this.options.attribution;
          },
          _layerAdd: function(e) {
            var map2 = e.target;
            if (!map2.hasLayer(this)) {
              return;
            }
            this._map = map2;
            this._zoomAnimated = map2._zoomAnimated;
            if (this.getEvents) {
              var events = this.getEvents();
              map2.on(events, this);
              this.once("remove", function() {
                map2.off(events, this);
              }, this);
            }
            this.onAdd(map2);
            if (this.getAttribution && map2.attributionControl) {
              map2.attributionControl.addAttribution(this.getAttribution());
            }
            this.fire("add");
            map2.fire("layeradd", { layer: this });
          }
        });
        Map2.include({
          addLayer: function(layer) {
            if (!layer._layerAdd) {
              throw new Error("The provided object is not a Layer.");
            }
            var id = stamp(layer);
            if (this._layers[id]) {
              return this;
            }
            this._layers[id] = layer;
            layer._mapToAdd = this;
            if (layer.beforeAdd) {
              layer.beforeAdd(this);
            }
            this.whenReady(layer._layerAdd, layer);
            return this;
          },
          removeLayer: function(layer) {
            var id = stamp(layer);
            if (!this._layers[id]) {
              return this;
            }
            if (this._loaded) {
              layer.onRemove(this);
            }
            if (layer.getAttribution && this.attributionControl) {
              this.attributionControl.removeAttribution(layer.getAttribution());
            }
            delete this._layers[id];
            if (this._loaded) {
              this.fire("layerremove", { layer });
              layer.fire("remove");
            }
            layer._map = layer._mapToAdd = null;
            return this;
          },
          hasLayer: function(layer) {
            return !!layer && stamp(layer) in this._layers;
          },
          eachLayer: function(method, context) {
            for (var i in this._layers) {
              method.call(context, this._layers[i]);
            }
            return this;
          },
          _addLayers: function(layers2) {
            layers2 = layers2 ? isArray(layers2) ? layers2 : [layers2] : [];
            for (var i = 0, len = layers2.length; i < len; i++) {
              this.addLayer(layers2[i]);
            }
          },
          _addZoomLimit: function(layer) {
            if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
              this._zoomBoundLayers[stamp(layer)] = layer;
              this._updateZoomLevels();
            }
          },
          _removeZoomLimit: function(layer) {
            var id = stamp(layer);
            if (this._zoomBoundLayers[id]) {
              delete this._zoomBoundLayers[id];
              this._updateZoomLevels();
            }
          },
          _updateZoomLevels: function() {
            var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
            for (var i in this._zoomBoundLayers) {
              var options = this._zoomBoundLayers[i].options;
              minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
              maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
            }
            this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
            this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
            if (oldZoomSpan !== this._getZoomSpan()) {
              this.fire("zoomlevelschange");
            }
            if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
              this.setZoom(this._layersMaxZoom);
            }
            if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
              this.setZoom(this._layersMinZoom);
            }
          }
        });
        var LayerGroup = Layer.extend({
          initialize: function(layers2, options) {
            setOptions(this, options);
            this._layers = {};
            var i, len;
            if (layers2) {
              for (i = 0, len = layers2.length; i < len; i++) {
                this.addLayer(layers2[i]);
              }
            }
          },
          addLayer: function(layer) {
            var id = this.getLayerId(layer);
            this._layers[id] = layer;
            if (this._map) {
              this._map.addLayer(layer);
            }
            return this;
          },
          removeLayer: function(layer) {
            var id = layer in this._layers ? layer : this.getLayerId(layer);
            if (this._map && this._layers[id]) {
              this._map.removeLayer(this._layers[id]);
            }
            delete this._layers[id];
            return this;
          },
          hasLayer: function(layer) {
            if (!layer) {
              return false;
            }
            var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
            return layerId in this._layers;
          },
          clearLayers: function() {
            return this.eachLayer(this.removeLayer, this);
          },
          invoke: function(methodName) {
            var args = Array.prototype.slice.call(arguments, 1), i, layer;
            for (i in this._layers) {
              layer = this._layers[i];
              if (layer[methodName]) {
                layer[methodName].apply(layer, args);
              }
            }
            return this;
          },
          onAdd: function(map2) {
            this.eachLayer(map2.addLayer, map2);
          },
          onRemove: function(map2) {
            this.eachLayer(map2.removeLayer, map2);
          },
          eachLayer: function(method, context) {
            for (var i in this._layers) {
              method.call(context, this._layers[i]);
            }
            return this;
          },
          getLayer: function(id) {
            return this._layers[id];
          },
          getLayers: function() {
            var layers2 = [];
            this.eachLayer(layers2.push, layers2);
            return layers2;
          },
          setZIndex: function(zIndex) {
            return this.invoke("setZIndex", zIndex);
          },
          getLayerId: function(layer) {
            return stamp(layer);
          }
        });
        var layerGroup = function(layers2, options) {
          return new LayerGroup(layers2, options);
        };
        var FeatureGroup = LayerGroup.extend({
          addLayer: function(layer) {
            if (this.hasLayer(layer)) {
              return this;
            }
            layer.addEventParent(this);
            LayerGroup.prototype.addLayer.call(this, layer);
            return this.fire("layeradd", { layer });
          },
          removeLayer: function(layer) {
            if (!this.hasLayer(layer)) {
              return this;
            }
            if (layer in this._layers) {
              layer = this._layers[layer];
            }
            layer.removeEventParent(this);
            LayerGroup.prototype.removeLayer.call(this, layer);
            return this.fire("layerremove", { layer });
          },
          setStyle: function(style) {
            return this.invoke("setStyle", style);
          },
          bringToFront: function() {
            return this.invoke("bringToFront");
          },
          bringToBack: function() {
            return this.invoke("bringToBack");
          },
          getBounds: function() {
            var bounds = new LatLngBounds();
            for (var id in this._layers) {
              var layer = this._layers[id];
              bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
            }
            return bounds;
          }
        });
        var featureGroup = function(layers2, options) {
          return new FeatureGroup(layers2, options);
        };
        var Icon = Class.extend({
          options: {
            popupAnchor: [0, 0],
            tooltipAnchor: [0, 0]
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          createIcon: function(oldIcon) {
            return this._createIcon("icon", oldIcon);
          },
          createShadow: function(oldIcon) {
            return this._createIcon("shadow", oldIcon);
          },
          _createIcon: function(name, oldIcon) {
            var src = this._getIconUrl(name);
            if (!src) {
              if (name === "icon") {
                throw new Error("iconUrl not set in Icon options (see the docs).");
              }
              return null;
            }
            var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
            this._setIconStyles(img, name);
            return img;
          },
          _setIconStyles: function(img, name) {
            var options = this.options;
            var sizeOption = options[name + "Size"];
            if (typeof sizeOption === "number") {
              sizeOption = [sizeOption, sizeOption];
            }
            var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
            img.className = "leaflet-marker-" + name + " " + (options.className || "");
            if (anchor) {
              img.style.marginLeft = -anchor.x + "px";
              img.style.marginTop = -anchor.y + "px";
            }
            if (size) {
              img.style.width = size.x + "px";
              img.style.height = size.y + "px";
            }
          },
          _createImg: function(src, el) {
            el = el || document.createElement("img");
            el.src = src;
            return el;
          },
          _getIconUrl: function(name) {
            return retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
          }
        });
        function icon(options) {
          return new Icon(options);
        }
        var IconDefault = Icon.extend({
          options: {
            iconUrl: "marker-icon.png",
            iconRetinaUrl: "marker-icon-2x.png",
            shadowUrl: "marker-shadow.png",
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            tooltipAnchor: [16, -28],
            shadowSize: [41, 41]
          },
          _getIconUrl: function(name) {
            if (!IconDefault.imagePath) {
              IconDefault.imagePath = this._detectIconPath();
            }
            return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
          },
          _detectIconPath: function() {
            var el = create$1("div", "leaflet-default-icon-path", document.body);
            var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
            document.body.removeChild(el);
            if (path === null || path.indexOf("url") !== 0) {
              path = "";
            } else {
              path = path.replace(/^url\(["']?/, "").replace(/marker-icon\.png["']?\)$/, "");
            }
            return path;
          }
        });
        var MarkerDrag = Handler.extend({
          initialize: function(marker2) {
            this._marker = marker2;
          },
          addHooks: function() {
            var icon2 = this._marker._icon;
            if (!this._draggable) {
              this._draggable = new Draggable(icon2, icon2, true);
            }
            this._draggable.on({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).enable();
            addClass(icon2, "leaflet-marker-draggable");
          },
          removeHooks: function() {
            this._draggable.off({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).disable();
            if (this._marker._icon) {
              removeClass(this._marker._icon, "leaflet-marker-draggable");
            }
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          _adjustPan: function(e) {
            var marker2 = this._marker, map2 = marker2._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker2._icon), bounds = map2.getPixelBounds(), origin = map2.getPixelOrigin();
            var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));
            if (!panBounds.contains(iconPos)) {
              var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);
              map2.panBy(movement, { animate: false });
              this._draggable._newPos._add(movement);
              this._draggable._startPos._add(movement);
              setPosition(marker2._icon, this._draggable._newPos);
              this._onDrag(e);
              this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
            }
          },
          _onDragStart: function() {
            this._oldLatLng = this._marker.getLatLng();
            this._marker.closePopup && this._marker.closePopup();
            this._marker.fire("movestart").fire("dragstart");
          },
          _onPreDrag: function(e) {
            if (this._marker.options.autoPan) {
              cancelAnimFrame(this._panRequest);
              this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
            }
          },
          _onDrag: function(e) {
            var marker2 = this._marker, shadow = marker2._shadow, iconPos = getPosition(marker2._icon), latlng = marker2._map.layerPointToLatLng(iconPos);
            if (shadow) {
              setPosition(shadow, iconPos);
            }
            marker2._latlng = latlng;
            e.latlng = latlng;
            e.oldLatLng = this._oldLatLng;
            marker2.fire("move", e).fire("drag", e);
          },
          _onDragEnd: function(e) {
            cancelAnimFrame(this._panRequest);
            delete this._oldLatLng;
            this._marker.fire("moveend").fire("dragend", e);
          }
        });
        var Marker = Layer.extend({
          options: {
            icon: new IconDefault(),
            interactive: true,
            keyboard: true,
            title: "",
            alt: "",
            zIndexOffset: 0,
            opacity: 1,
            riseOnHover: false,
            riseOffset: 250,
            pane: "markerPane",
            shadowPane: "shadowPane",
            bubblingMouseEvents: false,
            draggable: false,
            autoPan: false,
            autoPanPadding: [50, 50],
            autoPanSpeed: 10
          },
          initialize: function(latlng, options) {
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
          },
          onAdd: function(map2) {
            this._zoomAnimated = this._zoomAnimated && map2.options.markerZoomAnimation;
            if (this._zoomAnimated) {
              map2.on("zoomanim", this._animateZoom, this);
            }
            this._initIcon();
            this.update();
          },
          onRemove: function(map2) {
            if (this.dragging && this.dragging.enabled()) {
              this.options.draggable = true;
              this.dragging.removeHooks();
            }
            delete this.dragging;
            if (this._zoomAnimated) {
              map2.off("zoomanim", this._animateZoom, this);
            }
            this._removeIcon();
            this._removeShadow();
          },
          getEvents: function() {
            return {
              zoom: this.update,
              viewreset: this.update
            };
          },
          getLatLng: function() {
            return this._latlng;
          },
          setLatLng: function(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.update();
            return this.fire("move", { oldLatLng, latlng: this._latlng });
          },
          setZIndexOffset: function(offset) {
            this.options.zIndexOffset = offset;
            return this.update();
          },
          getIcon: function() {
            return this.options.icon;
          },
          setIcon: function(icon2) {
            this.options.icon = icon2;
            if (this._map) {
              this._initIcon();
              this.update();
            }
            if (this._popup) {
              this.bindPopup(this._popup, this._popup.options);
            }
            return this;
          },
          getElement: function() {
            return this._icon;
          },
          update: function() {
            if (this._icon && this._map) {
              var pos = this._map.latLngToLayerPoint(this._latlng).round();
              this._setPos(pos);
            }
            return this;
          },
          _initIcon: function() {
            var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            var icon2 = options.icon.createIcon(this._icon), addIcon = false;
            if (icon2 !== this._icon) {
              if (this._icon) {
                this._removeIcon();
              }
              addIcon = true;
              if (options.title) {
                icon2.title = options.title;
              }
              if (icon2.tagName === "IMG") {
                icon2.alt = options.alt || "";
              }
            }
            addClass(icon2, classToAdd);
            if (options.keyboard) {
              icon2.tabIndex = "0";
            }
            this._icon = icon2;
            if (options.riseOnHover) {
              this.on({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
              });
            }
            var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
            if (newShadow !== this._shadow) {
              this._removeShadow();
              addShadow = true;
            }
            if (newShadow) {
              addClass(newShadow, classToAdd);
              newShadow.alt = "";
            }
            this._shadow = newShadow;
            if (options.opacity < 1) {
              this._updateOpacity();
            }
            if (addIcon) {
              this.getPane().appendChild(this._icon);
            }
            this._initInteraction();
            if (newShadow && addShadow) {
              this.getPane(options.shadowPane).appendChild(this._shadow);
            }
          },
          _removeIcon: function() {
            if (this.options.riseOnHover) {
              this.off({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
              });
            }
            remove(this._icon);
            this.removeInteractiveTarget(this._icon);
            this._icon = null;
          },
          _removeShadow: function() {
            if (this._shadow) {
              remove(this._shadow);
            }
            this._shadow = null;
          },
          _setPos: function(pos) {
            if (this._icon) {
              setPosition(this._icon, pos);
            }
            if (this._shadow) {
              setPosition(this._shadow, pos);
            }
            this._zIndex = pos.y + this.options.zIndexOffset;
            this._resetZIndex();
          },
          _updateZIndex: function(offset) {
            if (this._icon) {
              this._icon.style.zIndex = this._zIndex + offset;
            }
          },
          _animateZoom: function(opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
            this._setPos(pos);
          },
          _initInteraction: function() {
            if (!this.options.interactive) {
              return;
            }
            addClass(this._icon, "leaflet-interactive");
            this.addInteractiveTarget(this._icon);
            if (MarkerDrag) {
              var draggable = this.options.draggable;
              if (this.dragging) {
                draggable = this.dragging.enabled();
                this.dragging.disable();
              }
              this.dragging = new MarkerDrag(this);
              if (draggable) {
                this.dragging.enable();
              }
            }
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._map) {
              this._updateOpacity();
            }
            return this;
          },
          _updateOpacity: function() {
            var opacity = this.options.opacity;
            if (this._icon) {
              setOpacity(this._icon, opacity);
            }
            if (this._shadow) {
              setOpacity(this._shadow, opacity);
            }
          },
          _bringToFront: function() {
            this._updateZIndex(this.options.riseOffset);
          },
          _resetZIndex: function() {
            this._updateZIndex(0);
          },
          _getPopupAnchor: function() {
            return this.options.icon.options.popupAnchor;
          },
          _getTooltipAnchor: function() {
            return this.options.icon.options.tooltipAnchor;
          }
        });
        function marker(latlng, options) {
          return new Marker(latlng, options);
        }
        var Path = Layer.extend({
          options: {
            stroke: true,
            color: "#3388ff",
            weight: 3,
            opacity: 1,
            lineCap: "round",
            lineJoin: "round",
            dashArray: null,
            dashOffset: null,
            fill: false,
            fillColor: null,
            fillOpacity: 0.2,
            fillRule: "evenodd",
            interactive: true,
            bubblingMouseEvents: true
          },
          beforeAdd: function(map2) {
            this._renderer = map2.getRenderer(this);
          },
          onAdd: function() {
            this._renderer._initPath(this);
            this._reset();
            this._renderer._addPath(this);
          },
          onRemove: function() {
            this._renderer._removePath(this);
          },
          redraw: function() {
            if (this._map) {
              this._renderer._updatePath(this);
            }
            return this;
          },
          setStyle: function(style) {
            setOptions(this, style);
            if (this._renderer) {
              this._renderer._updateStyle(this);
              if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, "weight")) {
                this._updateBounds();
              }
            }
            return this;
          },
          bringToFront: function() {
            if (this._renderer) {
              this._renderer._bringToFront(this);
            }
            return this;
          },
          bringToBack: function() {
            if (this._renderer) {
              this._renderer._bringToBack(this);
            }
            return this;
          },
          getElement: function() {
            return this._path;
          },
          _reset: function() {
            this._project();
            this._update();
          },
          _clickTolerance: function() {
            return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
          }
        });
        var CircleMarker = Path.extend({
          options: {
            fill: true,
            radius: 10
          },
          initialize: function(latlng, options) {
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
            this._radius = this.options.radius;
          },
          setLatLng: function(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.redraw();
            return this.fire("move", { oldLatLng, latlng: this._latlng });
          },
          getLatLng: function() {
            return this._latlng;
          },
          setRadius: function(radius) {
            this.options.radius = this._radius = radius;
            return this.redraw();
          },
          getRadius: function() {
            return this._radius;
          },
          setStyle: function(options) {
            var radius = options && options.radius || this._radius;
            Path.prototype.setStyle.call(this, options);
            this.setRadius(radius);
            return this;
          },
          _project: function() {
            this._point = this._map.latLngToLayerPoint(this._latlng);
            this._updateBounds();
          },
          _updateBounds: function() {
            var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [r + w, r2 + w];
            this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
          },
          _update: function() {
            if (this._map) {
              this._updatePath();
            }
          },
          _updatePath: function() {
            this._renderer._updateCircle(this);
          },
          _empty: function() {
            return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
          },
          _containsPoint: function(p) {
            return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
          }
        });
        function circleMarker(latlng, options) {
          return new CircleMarker(latlng, options);
        }
        var Circle2 = CircleMarker.extend({
          initialize: function(latlng, options, legacyOptions) {
            if (typeof options === "number") {
              options = extend({}, legacyOptions, { radius: options });
            }
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
            if (isNaN(this.options.radius)) {
              throw new Error("Circle radius cannot be NaN");
            }
            this._mRadius = this.options.radius;
          },
          setRadius: function(radius) {
            this._mRadius = radius;
            return this.redraw();
          },
          getRadius: function() {
            return this._mRadius;
          },
          getBounds: function() {
            var half = [this._radius, this._radiusY || this._radius];
            return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
          },
          setStyle: Path.prototype.setStyle,
          _project: function() {
            var lng = this._latlng.lng, lat = this._latlng.lat, map2 = this._map, crs = map2.options.crs;
            if (crs.distance === Earth.distance) {
              var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map2.project([lat + latR, lng]), bottom = map2.project([lat - latR, lng]), p = top.add(bottom).divideBy(2), lat2 = map2.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
              if (isNaN(lngR) || lngR === 0) {
                lngR = latR / Math.cos(Math.PI / 180 * lat);
              }
              this._point = p.subtract(map2.getPixelOrigin());
              this._radius = isNaN(lngR) ? 0 : p.x - map2.project([lat2, lng - lngR]).x;
              this._radiusY = p.y - top.y;
            } else {
              var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
              this._point = map2.latLngToLayerPoint(this._latlng);
              this._radius = this._point.x - map2.latLngToLayerPoint(latlng2).x;
            }
            this._updateBounds();
          }
        });
        function circle2(latlng, options, legacyOptions) {
          return new Circle2(latlng, options, legacyOptions);
        }
        var Polyline = Path.extend({
          options: {
            smoothFactor: 1,
            noClip: false
          },
          initialize: function(latlngs, options) {
            setOptions(this, options);
            this._setLatLngs(latlngs);
          },
          getLatLngs: function() {
            return this._latlngs;
          },
          setLatLngs: function(latlngs) {
            this._setLatLngs(latlngs);
            return this.redraw();
          },
          isEmpty: function() {
            return !this._latlngs.length;
          },
          closestLayerPoint: function(p) {
            var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2;
            for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
              var points = this._parts[j];
              for (var i = 1, len = points.length; i < len; i++) {
                p1 = points[i - 1];
                p2 = points[i];
                var sqDist = closest(p, p1, p2, true);
                if (sqDist < minDistance) {
                  minDistance = sqDist;
                  minPoint = closest(p, p1, p2);
                }
              }
            }
            if (minPoint) {
              minPoint.distance = Math.sqrt(minDistance);
            }
            return minPoint;
          },
          getCenter: function() {
            if (!this._map) {
              throw new Error("Must add layer to map before using getCenter()");
            }
            var i, halfDist, segDist, dist, p1, p2, ratio, points = this._rings[0], len = points.length;
            if (!len) {
              return null;
            }
            for (i = 0, halfDist = 0; i < len - 1; i++) {
              halfDist += points[i].distanceTo(points[i + 1]) / 2;
            }
            if (halfDist === 0) {
              return this._map.layerPointToLatLng(points[0]);
            }
            for (i = 0, dist = 0; i < len - 1; i++) {
              p1 = points[i];
              p2 = points[i + 1];
              segDist = p1.distanceTo(p2);
              dist += segDist;
              if (dist > halfDist) {
                ratio = (dist - halfDist) / segDist;
                return this._map.layerPointToLatLng([
                  p2.x - ratio * (p2.x - p1.x),
                  p2.y - ratio * (p2.y - p1.y)
                ]);
              }
            }
          },
          getBounds: function() {
            return this._bounds;
          },
          addLatLng: function(latlng, latlngs) {
            latlngs = latlngs || this._defaultShape();
            latlng = toLatLng(latlng);
            latlngs.push(latlng);
            this._bounds.extend(latlng);
            return this.redraw();
          },
          _setLatLngs: function(latlngs) {
            this._bounds = new LatLngBounds();
            this._latlngs = this._convertLatLngs(latlngs);
          },
          _defaultShape: function() {
            return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
          },
          _convertLatLngs: function(latlngs) {
            var result = [], flat = isFlat(latlngs);
            for (var i = 0, len = latlngs.length; i < len; i++) {
              if (flat) {
                result[i] = toLatLng(latlngs[i]);
                this._bounds.extend(result[i]);
              } else {
                result[i] = this._convertLatLngs(latlngs[i]);
              }
            }
            return result;
          },
          _project: function() {
            var pxBounds = new Bounds();
            this._rings = [];
            this._projectLatlngs(this._latlngs, this._rings, pxBounds);
            if (this._bounds.isValid() && pxBounds.isValid()) {
              this._rawPxBounds = pxBounds;
              this._updateBounds();
            }
          },
          _updateBounds: function() {
            var w = this._clickTolerance(), p = new Point(w, w);
            this._pxBounds = new Bounds([
              this._rawPxBounds.min.subtract(p),
              this._rawPxBounds.max.add(p)
            ]);
          },
          _projectLatlngs: function(latlngs, result, projectedBounds) {
            var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i, ring;
            if (flat) {
              ring = [];
              for (i = 0; i < len; i++) {
                ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
                projectedBounds.extend(ring[i]);
              }
              result.push(ring);
            } else {
              for (i = 0; i < len; i++) {
                this._projectLatlngs(latlngs[i], result, projectedBounds);
              }
            }
          },
          _clipPoints: function() {
            var bounds = this._renderer._bounds;
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
              return;
            }
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            var parts = this._parts, i, j, k, len, len2, segment, points;
            for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
              points = this._rings[i];
              for (j = 0, len2 = points.length; j < len2 - 1; j++) {
                segment = clipSegment(points[j], points[j + 1], bounds, j, true);
                if (!segment) {
                  continue;
                }
                parts[k] = parts[k] || [];
                parts[k].push(segment[0]);
                if (segment[1] !== points[j + 1] || j === len2 - 2) {
                  parts[k].push(segment[1]);
                  k++;
                }
              }
            }
          },
          _simplifyPoints: function() {
            var parts = this._parts, tolerance = this.options.smoothFactor;
            for (var i = 0, len = parts.length; i < len; i++) {
              parts[i] = simplify(parts[i], tolerance);
            }
          },
          _update: function() {
            if (!this._map) {
              return;
            }
            this._clipPoints();
            this._simplifyPoints();
            this._updatePath();
          },
          _updatePath: function() {
            this._renderer._updatePoly(this);
          },
          _containsPoint: function(p, closed) {
            var i, j, k, len, len2, part, w = this._clickTolerance();
            if (!this._pxBounds || !this._pxBounds.contains(p)) {
              return false;
            }
            for (i = 0, len = this._parts.length; i < len; i++) {
              part = this._parts[i];
              for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                if (!closed && j === 0) {
                  continue;
                }
                if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
                  return true;
                }
              }
            }
            return false;
          }
        });
        function polyline(latlngs, options) {
          return new Polyline(latlngs, options);
        }
        Polyline._flat = _flat;
        var Polygon = Polyline.extend({
          options: {
            fill: true
          },
          isEmpty: function() {
            return !this._latlngs.length || !this._latlngs[0].length;
          },
          getCenter: function() {
            if (!this._map) {
              throw new Error("Must add layer to map before using getCenter()");
            }
            var i, j, p1, p2, f, area2, x2, y2, center, points = this._rings[0], len = points.length;
            if (!len) {
              return null;
            }
            area2 = x2 = y2 = 0;
            for (i = 0, j = len - 1; i < len; j = i++) {
              p1 = points[i];
              p2 = points[j];
              f = p1.y * p2.x - p2.y * p1.x;
              x2 += (p1.x + p2.x) * f;
              y2 += (p1.y + p2.y) * f;
              area2 += f * 3;
            }
            if (area2 === 0) {
              center = points[0];
            } else {
              center = [x2 / area2, y2 / area2];
            }
            return this._map.layerPointToLatLng(center);
          },
          _convertLatLngs: function(latlngs) {
            var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
            if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
              result.pop();
            }
            return result;
          },
          _setLatLngs: function(latlngs) {
            Polyline.prototype._setLatLngs.call(this, latlngs);
            if (isFlat(this._latlngs)) {
              this._latlngs = [this._latlngs];
            }
          },
          _defaultShape: function() {
            return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
          },
          _clipPoints: function() {
            var bounds = this._renderer._bounds, w = this.options.weight, p = new Point(w, w);
            bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
              return;
            }
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
              clipped = clipPolygon(this._rings[i], bounds, true);
              if (clipped.length) {
                this._parts.push(clipped);
              }
            }
          },
          _updatePath: function() {
            this._renderer._updatePoly(this, true);
          },
          _containsPoint: function(p) {
            var inside = false, part, p1, p2, i, j, k, len, len2;
            if (!this._pxBounds || !this._pxBounds.contains(p)) {
              return false;
            }
            for (i = 0, len = this._parts.length; i < len; i++) {
              part = this._parts[i];
              for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                p1 = part[j];
                p2 = part[k];
                if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
                  inside = !inside;
                }
              }
            }
            return inside || Polyline.prototype._containsPoint.call(this, p, true);
          }
        });
        function polygon2(latlngs, options) {
          return new Polygon(latlngs, options);
        }
        var GeoJSON = FeatureGroup.extend({
          initialize: function(geojson, options) {
            setOptions(this, options);
            this._layers = {};
            if (geojson) {
              this.addData(geojson);
            }
          },
          addData: function(geojson) {
            var features = isArray(geojson) ? geojson : geojson.features, i, len, feature2;
            if (features) {
              for (i = 0, len = features.length; i < len; i++) {
                feature2 = features[i];
                if (feature2.geometries || feature2.geometry || feature2.features || feature2.coordinates) {
                  this.addData(feature2);
                }
              }
              return this;
            }
            var options = this.options;
            if (options.filter && !options.filter(geojson)) {
              return this;
            }
            var layer = geometryToLayer(geojson, options);
            if (!layer) {
              return this;
            }
            layer.feature = asFeature(geojson);
            layer.defaultOptions = layer.options;
            this.resetStyle(layer);
            if (options.onEachFeature) {
              options.onEachFeature(geojson, layer);
            }
            return this.addLayer(layer);
          },
          resetStyle: function(layer) {
            if (layer === void 0) {
              return this.eachLayer(this.resetStyle, this);
            }
            layer.options = extend({}, layer.defaultOptions);
            this._setLayerStyle(layer, this.options.style);
            return this;
          },
          setStyle: function(style) {
            return this.eachLayer(function(layer) {
              this._setLayerStyle(layer, style);
            }, this);
          },
          _setLayerStyle: function(layer, style) {
            if (layer.setStyle) {
              if (typeof style === "function") {
                style = style(layer.feature);
              }
              layer.setStyle(style);
            }
          }
        });
        function geometryToLayer(geojson, options) {
          var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;
          if (!coords && !geometry) {
            return null;
          }
          switch (geometry.type) {
            case "Point":
              latlng = _coordsToLatLng(coords);
              return _pointToLayer(pointToLayer, geojson, latlng, options);
            case "MultiPoint":
              for (i = 0, len = coords.length; i < len; i++) {
                latlng = _coordsToLatLng(coords[i]);
                layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options));
              }
              return new FeatureGroup(layers2);
            case "LineString":
            case "MultiLineString":
              latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
              return new Polyline(latlngs, options);
            case "Polygon":
            case "MultiPolygon":
              latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
              return new Polygon(latlngs, options);
            case "GeometryCollection":
              for (i = 0, len = geometry.geometries.length; i < len; i++) {
                var layer = geometryToLayer({
                  geometry: geometry.geometries[i],
                  type: "Feature",
                  properties: geojson.properties
                }, options);
                if (layer) {
                  layers2.push(layer);
                }
              }
              return new FeatureGroup(layers2);
            default:
              throw new Error("Invalid GeoJSON object.");
          }
        }
        function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
          return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
        }
        function coordsToLatLng(coords) {
          return new LatLng(coords[1], coords[0], coords[2]);
        }
        function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
          var latlngs = [];
          for (var i = 0, len = coords.length, latlng; i < len; i++) {
            latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
            latlngs.push(latlng);
          }
          return latlngs;
        }
        function latLngToCoords(latlng, precision) {
          precision = typeof precision === "number" ? precision : 6;
          return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
        }
        function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
          var coords = [];
          for (var i = 0, len = latlngs.length; i < len; i++) {
            coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
          }
          if (!levelsDeep && closed) {
            coords.push(coords[0]);
          }
          return coords;
        }
        function getFeature(layer, newGeometry) {
          return layer.feature ? extend({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
        }
        function asFeature(geojson) {
          if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
            return geojson;
          }
          return {
            type: "Feature",
            properties: {},
            geometry: geojson
          };
        }
        var PointToGeoJSON = {
          toGeoJSON: function(precision) {
            return getFeature(this, {
              type: "Point",
              coordinates: latLngToCoords(this.getLatLng(), precision)
            });
          }
        };
        Marker.include(PointToGeoJSON);
        Circle2.include(PointToGeoJSON);
        CircleMarker.include(PointToGeoJSON);
        Polyline.include({
          toGeoJSON: function(precision) {
            var multi = !isFlat(this._latlngs);
            var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
            return getFeature(this, {
              type: (multi ? "Multi" : "") + "LineString",
              coordinates: coords
            });
          }
        });
        Polygon.include({
          toGeoJSON: function(precision) {
            var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
            var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
            if (!holes) {
              coords = [coords];
            }
            return getFeature(this, {
              type: (multi ? "Multi" : "") + "Polygon",
              coordinates: coords
            });
          }
        });
        LayerGroup.include({
          toMultiPoint: function(precision) {
            var coords = [];
            this.eachLayer(function(layer) {
              coords.push(layer.toGeoJSON(precision).geometry.coordinates);
            });
            return getFeature(this, {
              type: "MultiPoint",
              coordinates: coords
            });
          },
          toGeoJSON: function(precision) {
            var type = this.feature && this.feature.geometry && this.feature.geometry.type;
            if (type === "MultiPoint") {
              return this.toMultiPoint(precision);
            }
            var isGeometryCollection = type === "GeometryCollection", jsons = [];
            this.eachLayer(function(layer) {
              if (layer.toGeoJSON) {
                var json = layer.toGeoJSON(precision);
                if (isGeometryCollection) {
                  jsons.push(json.geometry);
                } else {
                  var feature2 = asFeature(json);
                  if (feature2.type === "FeatureCollection") {
                    jsons.push.apply(jsons, feature2.features);
                  } else {
                    jsons.push(feature2);
                  }
                }
              }
            });
            if (isGeometryCollection) {
              return getFeature(this, {
                geometries: jsons,
                type: "GeometryCollection"
              });
            }
            return {
              type: "FeatureCollection",
              features: jsons
            };
          }
        });
        function geoJSON(geojson, options) {
          return new GeoJSON(geojson, options);
        }
        var geoJson = geoJSON;
        var ImageOverlay = Layer.extend({
          options: {
            opacity: 1,
            alt: "",
            interactive: false,
            crossOrigin: false,
            errorOverlayUrl: "",
            zIndex: 1,
            className: ""
          },
          initialize: function(url, bounds, options) {
            this._url = url;
            this._bounds = toLatLngBounds(bounds);
            setOptions(this, options);
          },
          onAdd: function() {
            if (!this._image) {
              this._initImage();
              if (this.options.opacity < 1) {
                this._updateOpacity();
              }
            }
            if (this.options.interactive) {
              addClass(this._image, "leaflet-interactive");
              this.addInteractiveTarget(this._image);
            }
            this.getPane().appendChild(this._image);
            this._reset();
          },
          onRemove: function() {
            remove(this._image);
            if (this.options.interactive) {
              this.removeInteractiveTarget(this._image);
            }
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._image) {
              this._updateOpacity();
            }
            return this;
          },
          setStyle: function(styleOpts) {
            if (styleOpts.opacity) {
              this.setOpacity(styleOpts.opacity);
            }
            return this;
          },
          bringToFront: function() {
            if (this._map) {
              toFront(this._image);
            }
            return this;
          },
          bringToBack: function() {
            if (this._map) {
              toBack(this._image);
            }
            return this;
          },
          setUrl: function(url) {
            this._url = url;
            if (this._image) {
              this._image.src = url;
            }
            return this;
          },
          setBounds: function(bounds) {
            this._bounds = toLatLngBounds(bounds);
            if (this._map) {
              this._reset();
            }
            return this;
          },
          getEvents: function() {
            var events = {
              zoom: this._reset,
              viewreset: this._reset
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          setZIndex: function(value) {
            this.options.zIndex = value;
            this._updateZIndex();
            return this;
          },
          getBounds: function() {
            return this._bounds;
          },
          getElement: function() {
            return this._image;
          },
          _initImage: function() {
            var wasElementSupplied = this._url.tagName === "IMG";
            var img = this._image = wasElementSupplied ? this._url : create$1("img");
            addClass(img, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(img, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(img, this.options.className);
            }
            img.onselectstart = falseFn;
            img.onmousemove = falseFn;
            img.onload = bind(this.fire, this, "load");
            img.onerror = bind(this._overlayOnError, this, "error");
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            if (this.options.zIndex) {
              this._updateZIndex();
            }
            if (wasElementSupplied) {
              this._url = img.src;
              return;
            }
            img.src = this._url;
            img.alt = this.options.alt;
          },
          _animateZoom: function(e) {
            var scale2 = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
            setTransform(this._image, offset, scale2);
          },
          _reset: function() {
            var image = this._image, bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())), size = bounds.getSize();
            setPosition(image, bounds.min);
            image.style.width = size.x + "px";
            image.style.height = size.y + "px";
          },
          _updateOpacity: function() {
            setOpacity(this._image, this.options.opacity);
          },
          _updateZIndex: function() {
            if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
              this._image.style.zIndex = this.options.zIndex;
            }
          },
          _overlayOnError: function() {
            this.fire("error");
            var errorUrl = this.options.errorOverlayUrl;
            if (errorUrl && this._url !== errorUrl) {
              this._url = errorUrl;
              this._image.src = errorUrl;
            }
          }
        });
        var imageOverlay = function(url, bounds, options) {
          return new ImageOverlay(url, bounds, options);
        };
        var VideoOverlay = ImageOverlay.extend({
          options: {
            autoplay: true,
            loop: true,
            keepAspectRatio: true,
            muted: false
          },
          _initImage: function() {
            var wasElementSupplied = this._url.tagName === "VIDEO";
            var vid = this._image = wasElementSupplied ? this._url : create$1("video");
            addClass(vid, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(vid, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(vid, this.options.className);
            }
            vid.onselectstart = falseFn;
            vid.onmousemove = falseFn;
            vid.onloadeddata = bind(this.fire, this, "load");
            if (wasElementSupplied) {
              var sourceElements = vid.getElementsByTagName("source");
              var sources = [];
              for (var j = 0; j < sourceElements.length; j++) {
                sources.push(sourceElements[j].src);
              }
              this._url = sourceElements.length > 0 ? sources : [vid.src];
              return;
            }
            if (!isArray(this._url)) {
              this._url = [this._url];
            }
            if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
              vid.style["objectFit"] = "fill";
            }
            vid.autoplay = !!this.options.autoplay;
            vid.loop = !!this.options.loop;
            vid.muted = !!this.options.muted;
            for (var i = 0; i < this._url.length; i++) {
              var source = create$1("source");
              source.src = this._url[i];
              vid.appendChild(source);
            }
          }
        });
        function videoOverlay(video, bounds, options) {
          return new VideoOverlay(video, bounds, options);
        }
        var SVGOverlay = ImageOverlay.extend({
          _initImage: function() {
            var el = this._image = this._url;
            addClass(el, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(el, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(el, this.options.className);
            }
            el.onselectstart = falseFn;
            el.onmousemove = falseFn;
          }
        });
        function svgOverlay(el, bounds, options) {
          return new SVGOverlay(el, bounds, options);
        }
        var DivOverlay = Layer.extend({
          options: {
            offset: [0, 7],
            className: "",
            pane: "popupPane"
          },
          initialize: function(options, source) {
            setOptions(this, options);
            this._source = source;
          },
          onAdd: function(map2) {
            this._zoomAnimated = map2._zoomAnimated;
            if (!this._container) {
              this._initLayout();
            }
            if (map2._fadeAnimated) {
              setOpacity(this._container, 0);
            }
            clearTimeout(this._removeTimeout);
            this.getPane().appendChild(this._container);
            this.update();
            if (map2._fadeAnimated) {
              setOpacity(this._container, 1);
            }
            this.bringToFront();
          },
          onRemove: function(map2) {
            if (map2._fadeAnimated) {
              setOpacity(this._container, 0);
              this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200);
            } else {
              remove(this._container);
            }
          },
          getLatLng: function() {
            return this._latlng;
          },
          setLatLng: function(latlng) {
            this._latlng = toLatLng(latlng);
            if (this._map) {
              this._updatePosition();
              this._adjustPan();
            }
            return this;
          },
          getContent: function() {
            return this._content;
          },
          setContent: function(content) {
            this._content = content;
            this.update();
            return this;
          },
          getElement: function() {
            return this._container;
          },
          update: function() {
            if (!this._map) {
              return;
            }
            this._container.style.visibility = "hidden";
            this._updateContent();
            this._updateLayout();
            this._updatePosition();
            this._container.style.visibility = "";
            this._adjustPan();
          },
          getEvents: function() {
            var events = {
              zoom: this._updatePosition,
              viewreset: this._updatePosition
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          isOpen: function() {
            return !!this._map && this._map.hasLayer(this);
          },
          bringToFront: function() {
            if (this._map) {
              toFront(this._container);
            }
            return this;
          },
          bringToBack: function() {
            if (this._map) {
              toBack(this._container);
            }
            return this;
          },
          _prepareOpen: function(parent, layer, latlng) {
            if (!(layer instanceof Layer)) {
              latlng = layer;
              layer = parent;
            }
            if (layer instanceof FeatureGroup) {
              for (var id in parent._layers) {
                layer = parent._layers[id];
                break;
              }
            }
            if (!latlng) {
              if (layer.getCenter) {
                latlng = layer.getCenter();
              } else if (layer.getLatLng) {
                latlng = layer.getLatLng();
              } else {
                throw new Error("Unable to get source layer LatLng.");
              }
            }
            this._source = layer;
            this.update();
            return latlng;
          },
          _updateContent: function() {
            if (!this._content) {
              return;
            }
            var node = this._contentNode;
            var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
            if (typeof content === "string") {
              node.innerHTML = content;
            } else {
              while (node.hasChildNodes()) {
                node.removeChild(node.firstChild);
              }
              node.appendChild(content);
            }
            this.fire("contentupdate");
          },
          _updatePosition: function() {
            if (!this._map) {
              return;
            }
            var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (this._zoomAnimated) {
              setPosition(this._container, pos.add(anchor));
            } else {
              offset = offset.add(pos).add(anchor);
            }
            var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
            this._container.style.bottom = bottom + "px";
            this._container.style.left = left + "px";
          },
          _getAnchor: function() {
            return [0, 0];
          }
        });
        var Popup = DivOverlay.extend({
          options: {
            maxWidth: 300,
            minWidth: 50,
            maxHeight: null,
            autoPan: true,
            autoPanPaddingTopLeft: null,
            autoPanPaddingBottomRight: null,
            autoPanPadding: [5, 5],
            keepInView: false,
            closeButton: true,
            autoClose: true,
            closeOnEscapeKey: true,
            className: ""
          },
          openOn: function(map2) {
            map2.openPopup(this);
            return this;
          },
          onAdd: function(map2) {
            DivOverlay.prototype.onAdd.call(this, map2);
            map2.fire("popupopen", { popup: this });
            if (this._source) {
              this._source.fire("popupopen", { popup: this }, true);
              if (!(this._source instanceof Path)) {
                this._source.on("preclick", stopPropagation);
              }
            }
          },
          onRemove: function(map2) {
            DivOverlay.prototype.onRemove.call(this, map2);
            map2.fire("popupclose", { popup: this });
            if (this._source) {
              this._source.fire("popupclose", { popup: this }, true);
              if (!(this._source instanceof Path)) {
                this._source.off("preclick", stopPropagation);
              }
            }
          },
          getEvents: function() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
              events.preclick = this._close;
            }
            if (this.options.keepInView) {
              events.moveend = this._adjustPan;
            }
            return events;
          },
          _close: function() {
            if (this._map) {
              this._map.closePopup(this);
            }
          },
          _initLayout: function() {
            var prefix = "leaflet-popup", container = this._container = create$1("div", prefix + " " + (this.options.className || "") + " leaflet-zoom-animated");
            var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
            this._contentNode = create$1("div", prefix + "-content", wrapper);
            disableClickPropagation(container);
            disableScrollPropagation(this._contentNode);
            on(container, "contextmenu", stopPropagation);
            this._tipContainer = create$1("div", prefix + "-tip-container", container);
            this._tip = create$1("div", prefix + "-tip", this._tipContainer);
            if (this.options.closeButton) {
              var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
              closeButton.href = "#close";
              closeButton.innerHTML = "&#215;";
              on(closeButton, "click", this._onCloseButtonClick, this);
            }
          },
          _updateLayout: function() {
            var container = this._contentNode, style = container.style;
            style.width = "";
            style.whiteSpace = "nowrap";
            var width = container.offsetWidth;
            width = Math.min(width, this.options.maxWidth);
            width = Math.max(width, this.options.minWidth);
            style.width = width + 1 + "px";
            style.whiteSpace = "";
            style.height = "";
            var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
            if (maxHeight && height > maxHeight) {
              style.height = maxHeight + "px";
              addClass(container, scrolledClass);
            } else {
              removeClass(container, scrolledClass);
            }
            this._containerWidth = this._container.offsetWidth;
          },
          _animateZoom: function(e) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
            setPosition(this._container, pos.add(anchor));
          },
          _adjustPan: function() {
            if (!this.options.autoPan) {
              return;
            }
            if (this._map._panAnim) {
              this._map._panAnim.stop();
            }
            var map2 = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
            layerPos._add(getPosition(this._container));
            var containerPos = map2.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map2.getSize(), dx = 0, dy = 0;
            if (containerPos.x + containerWidth + paddingBR.x > size.x) {
              dx = containerPos.x + containerWidth - size.x + paddingBR.x;
            }
            if (containerPos.x - dx - paddingTL.x < 0) {
              dx = containerPos.x - paddingTL.x;
            }
            if (containerPos.y + containerHeight + paddingBR.y > size.y) {
              dy = containerPos.y + containerHeight - size.y + paddingBR.y;
            }
            if (containerPos.y - dy - paddingTL.y < 0) {
              dy = containerPos.y - paddingTL.y;
            }
            if (dx || dy) {
              map2.fire("autopanstart").panBy([dx, dy]);
            }
          },
          _onCloseButtonClick: function(e) {
            this._close();
            stop(e);
          },
          _getAnchor: function() {
            return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
          }
        });
        var popup = function(options, source) {
          return new Popup(options, source);
        };
        Map2.mergeOptions({
          closePopupOnClick: true
        });
        Map2.include({
          openPopup: function(popup2, latlng, options) {
            if (!(popup2 instanceof Popup)) {
              popup2 = new Popup(options).setContent(popup2);
            }
            if (latlng) {
              popup2.setLatLng(latlng);
            }
            if (this.hasLayer(popup2)) {
              return this;
            }
            if (this._popup && this._popup.options.autoClose) {
              this.closePopup();
            }
            this._popup = popup2;
            return this.addLayer(popup2);
          },
          closePopup: function(popup2) {
            if (!popup2 || popup2 === this._popup) {
              popup2 = this._popup;
              this._popup = null;
            }
            if (popup2) {
              this.removeLayer(popup2);
            }
            return this;
          }
        });
        Layer.include({
          bindPopup: function(content, options) {
            if (content instanceof Popup) {
              setOptions(content, options);
              this._popup = content;
              content._source = this;
            } else {
              if (!this._popup || options) {
                this._popup = new Popup(options, this);
              }
              this._popup.setContent(content);
            }
            if (!this._popupHandlersAdded) {
              this.on({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
              });
              this._popupHandlersAdded = true;
            }
            return this;
          },
          unbindPopup: function() {
            if (this._popup) {
              this.off({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
              });
              this._popupHandlersAdded = false;
              this._popup = null;
            }
            return this;
          },
          openPopup: function(layer, latlng) {
            if (this._popup && this._map) {
              latlng = this._popup._prepareOpen(this, layer, latlng);
              this._map.openPopup(this._popup, latlng);
            }
            return this;
          },
          closePopup: function() {
            if (this._popup) {
              this._popup._close();
            }
            return this;
          },
          togglePopup: function(target) {
            if (this._popup) {
              if (this._popup._map) {
                this.closePopup();
              } else {
                this.openPopup(target);
              }
            }
            return this;
          },
          isPopupOpen: function() {
            return this._popup ? this._popup.isOpen() : false;
          },
          setPopupContent: function(content) {
            if (this._popup) {
              this._popup.setContent(content);
            }
            return this;
          },
          getPopup: function() {
            return this._popup;
          },
          _openPopup: function(e) {
            var layer = e.layer || e.target;
            if (!this._popup) {
              return;
            }
            if (!this._map) {
              return;
            }
            stop(e);
            if (layer instanceof Path) {
              this.openPopup(e.layer || e.target, e.latlng);
              return;
            }
            if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
              this.closePopup();
            } else {
              this.openPopup(layer, e.latlng);
            }
          },
          _movePopup: function(e) {
            this._popup.setLatLng(e.latlng);
          },
          _onKeyPress: function(e) {
            if (e.originalEvent.keyCode === 13) {
              this._openPopup(e);
            }
          }
        });
        var Tooltip = DivOverlay.extend({
          options: {
            pane: "tooltipPane",
            offset: [0, 0],
            direction: "auto",
            permanent: false,
            sticky: false,
            interactive: false,
            opacity: 0.9
          },
          onAdd: function(map2) {
            DivOverlay.prototype.onAdd.call(this, map2);
            this.setOpacity(this.options.opacity);
            map2.fire("tooltipopen", { tooltip: this });
            if (this._source) {
              this._source.fire("tooltipopen", { tooltip: this }, true);
            }
          },
          onRemove: function(map2) {
            DivOverlay.prototype.onRemove.call(this, map2);
            map2.fire("tooltipclose", { tooltip: this });
            if (this._source) {
              this._source.fire("tooltipclose", { tooltip: this }, true);
            }
          },
          getEvents: function() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (touch && !this.options.permanent) {
              events.preclick = this._close;
            }
            return events;
          },
          _close: function() {
            if (this._map) {
              this._map.closeTooltip(this);
            }
          },
          _initLayout: function() {
            var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            this._contentNode = this._container = create$1("div", className);
          },
          _updateLayout: function() {
          },
          _adjustPan: function() {
          },
          _setPosition: function(pos) {
            var subX, subY, map2 = this._map, container = this._container, centerPoint = map2.latLngToContainerPoint(map2.getCenter()), tooltipPoint = map2.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (direction === "top") {
              subX = tooltipWidth / 2;
              subY = tooltipHeight;
            } else if (direction === "bottom") {
              subX = tooltipWidth / 2;
              subY = 0;
            } else if (direction === "center") {
              subX = tooltipWidth / 2;
              subY = tooltipHeight / 2;
            } else if (direction === "right") {
              subX = 0;
              subY = tooltipHeight / 2;
            } else if (direction === "left") {
              subX = tooltipWidth;
              subY = tooltipHeight / 2;
            } else if (tooltipPoint.x < centerPoint.x) {
              direction = "right";
              subX = 0;
              subY = tooltipHeight / 2;
            } else {
              direction = "left";
              subX = tooltipWidth + (offset.x + anchor.x) * 2;
              subY = tooltipHeight / 2;
            }
            pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
            removeClass(container, "leaflet-tooltip-right");
            removeClass(container, "leaflet-tooltip-left");
            removeClass(container, "leaflet-tooltip-top");
            removeClass(container, "leaflet-tooltip-bottom");
            addClass(container, "leaflet-tooltip-" + direction);
            setPosition(container, pos);
          },
          _updatePosition: function() {
            var pos = this._map.latLngToLayerPoint(this._latlng);
            this._setPosition(pos);
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._container) {
              setOpacity(this._container, opacity);
            }
          },
          _animateZoom: function(e) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
            this._setPosition(pos);
          },
          _getAnchor: function() {
            return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
          }
        });
        var tooltip = function(options, source) {
          return new Tooltip(options, source);
        };
        Map2.include({
          openTooltip: function(tooltip2, latlng, options) {
            if (!(tooltip2 instanceof Tooltip)) {
              tooltip2 = new Tooltip(options).setContent(tooltip2);
            }
            if (latlng) {
              tooltip2.setLatLng(latlng);
            }
            if (this.hasLayer(tooltip2)) {
              return this;
            }
            return this.addLayer(tooltip2);
          },
          closeTooltip: function(tooltip2) {
            if (tooltip2) {
              this.removeLayer(tooltip2);
            }
            return this;
          }
        });
        Layer.include({
          bindTooltip: function(content, options) {
            if (content instanceof Tooltip) {
              setOptions(content, options);
              this._tooltip = content;
              content._source = this;
            } else {
              if (!this._tooltip || options) {
                this._tooltip = new Tooltip(options, this);
              }
              this._tooltip.setContent(content);
            }
            this._initTooltipInteractions();
            if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
              this.openTooltip();
            }
            return this;
          },
          unbindTooltip: function() {
            if (this._tooltip) {
              this._initTooltipInteractions(true);
              this.closeTooltip();
              this._tooltip = null;
            }
            return this;
          },
          _initTooltipInteractions: function(remove$$1) {
            if (!remove$$1 && this._tooltipHandlersAdded) {
              return;
            }
            var onOff = remove$$1 ? "off" : "on", events = {
              remove: this.closeTooltip,
              move: this._moveTooltip
            };
            if (!this._tooltip.options.permanent) {
              events.mouseover = this._openTooltip;
              events.mouseout = this.closeTooltip;
              if (this._tooltip.options.sticky) {
                events.mousemove = this._moveTooltip;
              }
              if (touch) {
                events.click = this._openTooltip;
              }
            } else {
              events.add = this._openTooltip;
            }
            this[onOff](events);
            this._tooltipHandlersAdded = !remove$$1;
          },
          openTooltip: function(layer, latlng) {
            if (this._tooltip && this._map) {
              latlng = this._tooltip._prepareOpen(this, layer, latlng);
              this._map.openTooltip(this._tooltip, latlng);
              if (this._tooltip.options.interactive && this._tooltip._container) {
                addClass(this._tooltip._container, "leaflet-clickable");
                this.addInteractiveTarget(this._tooltip._container);
              }
            }
            return this;
          },
          closeTooltip: function() {
            if (this._tooltip) {
              this._tooltip._close();
              if (this._tooltip.options.interactive && this._tooltip._container) {
                removeClass(this._tooltip._container, "leaflet-clickable");
                this.removeInteractiveTarget(this._tooltip._container);
              }
            }
            return this;
          },
          toggleTooltip: function(target) {
            if (this._tooltip) {
              if (this._tooltip._map) {
                this.closeTooltip();
              } else {
                this.openTooltip(target);
              }
            }
            return this;
          },
          isTooltipOpen: function() {
            return this._tooltip.isOpen();
          },
          setTooltipContent: function(content) {
            if (this._tooltip) {
              this._tooltip.setContent(content);
            }
            return this;
          },
          getTooltip: function() {
            return this._tooltip;
          },
          _openTooltip: function(e) {
            var layer = e.layer || e.target;
            if (!this._tooltip || !this._map) {
              return;
            }
            this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : void 0);
          },
          _moveTooltip: function(e) {
            var latlng = e.latlng, containerPoint, layerPoint;
            if (this._tooltip.options.sticky && e.originalEvent) {
              containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
              layerPoint = this._map.containerPointToLayerPoint(containerPoint);
              latlng = this._map.layerPointToLatLng(layerPoint);
            }
            this._tooltip.setLatLng(latlng);
          }
        });
        var DivIcon = Icon.extend({
          options: {
            iconSize: [12, 12],
            html: false,
            bgPos: null,
            className: "leaflet-div-icon"
          },
          createIcon: function(oldIcon) {
            var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
            if (options.html instanceof Element) {
              empty(div);
              div.appendChild(options.html);
            } else {
              div.innerHTML = options.html !== false ? options.html : "";
            }
            if (options.bgPos) {
              var bgPos = toPoint(options.bgPos);
              div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
            }
            this._setIconStyles(div, "icon");
            return div;
          },
          createShadow: function() {
            return null;
          }
        });
        function divIcon(options) {
          return new DivIcon(options);
        }
        Icon.Default = IconDefault;
        var GridLayer = Layer.extend({
          options: {
            tileSize: 256,
            opacity: 1,
            updateWhenIdle: mobile,
            updateWhenZooming: true,
            updateInterval: 200,
            zIndex: 1,
            bounds: null,
            minZoom: 0,
            maxZoom: void 0,
            maxNativeZoom: void 0,
            minNativeZoom: void 0,
            noWrap: false,
            pane: "tilePane",
            className: "",
            keepBuffer: 2
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          onAdd: function() {
            this._initContainer();
            this._levels = {};
            this._tiles = {};
            this._resetView();
            this._update();
          },
          beforeAdd: function(map2) {
            map2._addZoomLimit(this);
          },
          onRemove: function(map2) {
            this._removeAllTiles();
            remove(this._container);
            map2._removeZoomLimit(this);
            this._container = null;
            this._tileZoom = void 0;
          },
          bringToFront: function() {
            if (this._map) {
              toFront(this._container);
              this._setAutoZIndex(Math.max);
            }
            return this;
          },
          bringToBack: function() {
            if (this._map) {
              toBack(this._container);
              this._setAutoZIndex(Math.min);
            }
            return this;
          },
          getContainer: function() {
            return this._container;
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            this._updateOpacity();
            return this;
          },
          setZIndex: function(zIndex) {
            this.options.zIndex = zIndex;
            this._updateZIndex();
            return this;
          },
          isLoading: function() {
            return this._loading;
          },
          redraw: function() {
            if (this._map) {
              this._removeAllTiles();
              this._update();
            }
            return this;
          },
          getEvents: function() {
            var events = {
              viewprereset: this._invalidateAll,
              viewreset: this._resetView,
              zoom: this._resetView,
              moveend: this._onMoveEnd
            };
            if (!this.options.updateWhenIdle) {
              if (!this._onMove) {
                this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
              }
              events.move = this._onMove;
            }
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          createTile: function() {
            return document.createElement("div");
          },
          getTileSize: function() {
            var s = this.options.tileSize;
            return s instanceof Point ? s : new Point(s, s);
          },
          _updateZIndex: function() {
            if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
              this._container.style.zIndex = this.options.zIndex;
            }
          },
          _setAutoZIndex: function(compare) {
            var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
            for (var i = 0, len = layers2.length, zIndex; i < len; i++) {
              zIndex = layers2[i].style.zIndex;
              if (layers2[i] !== this._container && zIndex) {
                edgeZIndex = compare(edgeZIndex, +zIndex);
              }
            }
            if (isFinite(edgeZIndex)) {
              this.options.zIndex = edgeZIndex + compare(-1, 1);
              this._updateZIndex();
            }
          },
          _updateOpacity: function() {
            if (!this._map) {
              return;
            }
            if (ielt9) {
              return;
            }
            setOpacity(this._container, this.options.opacity);
            var now = +new Date(), nextFrame = false, willPrune = false;
            for (var key in this._tiles) {
              var tile = this._tiles[key];
              if (!tile.current || !tile.loaded) {
                continue;
              }
              var fade = Math.min(1, (now - tile.loaded) / 200);
              setOpacity(tile.el, fade);
              if (fade < 1) {
                nextFrame = true;
              } else {
                if (tile.active) {
                  willPrune = true;
                } else {
                  this._onOpaqueTile(tile);
                }
                tile.active = true;
              }
            }
            if (willPrune && !this._noPrune) {
              this._pruneTiles();
            }
            if (nextFrame) {
              cancelAnimFrame(this._fadeFrame);
              this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
            }
          },
          _onOpaqueTile: falseFn,
          _initContainer: function() {
            if (this._container) {
              return;
            }
            this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
            this._updateZIndex();
            if (this.options.opacity < 1) {
              this._updateOpacity();
            }
            this.getPane().appendChild(this._container);
          },
          _updateLevels: function() {
            var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
            if (zoom2 === void 0) {
              return void 0;
            }
            for (var z in this._levels) {
              z = Number(z);
              if (this._levels[z].el.children.length || z === zoom2) {
                this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom2 - z);
                this._onUpdateLevel(z);
              } else {
                remove(this._levels[z].el);
                this._removeTilesAtZoom(z);
                this._onRemoveLevel(z);
                delete this._levels[z];
              }
            }
            var level = this._levels[zoom2], map2 = this._map;
            if (!level) {
              level = this._levels[zoom2] = {};
              level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
              level.el.style.zIndex = maxZoom;
              level.origin = map2.project(map2.unproject(map2.getPixelOrigin()), zoom2).round();
              level.zoom = zoom2;
              this._setZoomTransform(level, map2.getCenter(), map2.getZoom());
              falseFn(level.el.offsetWidth);
              this._onCreateLevel(level);
            }
            this._level = level;
            return level;
          },
          _onUpdateLevel: falseFn,
          _onRemoveLevel: falseFn,
          _onCreateLevel: falseFn,
          _pruneTiles: function() {
            if (!this._map) {
              return;
            }
            var key, tile;
            var zoom2 = this._map.getZoom();
            if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
              this._removeAllTiles();
              return;
            }
            for (key in this._tiles) {
              tile = this._tiles[key];
              tile.retain = tile.current;
            }
            for (key in this._tiles) {
              tile = this._tiles[key];
              if (tile.current && !tile.active) {
                var coords = tile.coords;
                if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                  this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
                }
              }
            }
            for (key in this._tiles) {
              if (!this._tiles[key].retain) {
                this._removeTile(key);
              }
            }
          },
          _removeTilesAtZoom: function(zoom2) {
            for (var key in this._tiles) {
              if (this._tiles[key].coords.z !== zoom2) {
                continue;
              }
              this._removeTile(key);
            }
          },
          _removeAllTiles: function() {
            for (var key in this._tiles) {
              this._removeTile(key);
            }
          },
          _invalidateAll: function() {
            for (var z in this._levels) {
              remove(this._levels[z].el);
              this._onRemoveLevel(Number(z));
              delete this._levels[z];
            }
            this._removeAllTiles();
            this._tileZoom = void 0;
          },
          _retainParent: function(x2, y2, z, minZoom) {
            var x22 = Math.floor(x2 / 2), y22 = Math.floor(y2 / 2), z2 = z - 1, coords2 = new Point(+x22, +y22);
            coords2.z = +z2;
            var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
            if (tile && tile.active) {
              tile.retain = true;
              return true;
            } else if (tile && tile.loaded) {
              tile.retain = true;
            }
            if (z2 > minZoom) {
              return this._retainParent(x22, y22, z2, minZoom);
            }
            return false;
          },
          _retainChildren: function(x2, y2, z, maxZoom) {
            for (var i = 2 * x2; i < 2 * x2 + 2; i++) {
              for (var j = 2 * y2; j < 2 * y2 + 2; j++) {
                var coords = new Point(i, j);
                coords.z = z + 1;
                var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
                if (tile && tile.active) {
                  tile.retain = true;
                  continue;
                } else if (tile && tile.loaded) {
                  tile.retain = true;
                }
                if (z + 1 < maxZoom) {
                  this._retainChildren(i, j, z + 1, maxZoom);
                }
              }
            }
          },
          _resetView: function(e) {
            var animating = e && (e.pinch || e.flyTo);
            this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
          },
          _animateZoom: function(e) {
            this._setView(e.center, e.zoom, true, e.noUpdate);
          },
          _clampZoom: function(zoom2) {
            var options = this.options;
            if (options.minNativeZoom !== void 0 && zoom2 < options.minNativeZoom) {
              return options.minNativeZoom;
            }
            if (options.maxNativeZoom !== void 0 && options.maxNativeZoom < zoom2) {
              return options.maxNativeZoom;
            }
            return zoom2;
          },
          _setView: function(center, zoom2, noPrune, noUpdate) {
            var tileZoom = Math.round(zoom2);
            if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
              tileZoom = void 0;
            } else {
              tileZoom = this._clampZoom(tileZoom);
            }
            var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
            if (!noUpdate || tileZoomChanged) {
              this._tileZoom = tileZoom;
              if (this._abortLoading) {
                this._abortLoading();
              }
              this._updateLevels();
              this._resetGrid();
              if (tileZoom !== void 0) {
                this._update(center);
              }
              if (!noPrune) {
                this._pruneTiles();
              }
              this._noPrune = !!noPrune;
            }
            this._setZoomTransforms(center, zoom2);
          },
          _setZoomTransforms: function(center, zoom2) {
            for (var i in this._levels) {
              this._setZoomTransform(this._levels[i], center, zoom2);
            }
          },
          _setZoomTransform: function(level, center, zoom2) {
            var scale2 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale2).subtract(this._map._getNewPixelOrigin(center, zoom2)).round();
            if (any3d) {
              setTransform(level.el, translate, scale2);
            } else {
              setPosition(level.el, translate);
            }
          },
          _resetGrid: function() {
            var map2 = this._map, crs = map2.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
            var bounds = this._map.getPixelWorldBounds(this._tileZoom);
            if (bounds) {
              this._globalTileRange = this._pxBoundsToTileRange(bounds);
            }
            this._wrapX = crs.wrapLng && !this.options.noWrap && [
              Math.floor(map2.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
              Math.ceil(map2.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
            ];
            this._wrapY = crs.wrapLat && !this.options.noWrap && [
              Math.floor(map2.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
              Math.ceil(map2.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
            ];
          },
          _onMoveEnd: function() {
            if (!this._map || this._map._animatingZoom) {
              return;
            }
            this._update();
          },
          _getTiledPixelBounds: function(center) {
            var map2 = this._map, mapZoom = map2._animatingZoom ? Math.max(map2._animateToZoom, map2.getZoom()) : map2.getZoom(), scale2 = map2.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map2.project(center, this._tileZoom).floor(), halfSize = map2.getSize().divideBy(scale2 * 2);
            return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
          },
          _update: function(center) {
            var map2 = this._map;
            if (!map2) {
              return;
            }
            var zoom2 = this._clampZoom(map2.getZoom());
            if (center === void 0) {
              center = map2.getCenter();
            }
            if (this._tileZoom === void 0) {
              return;
            }
            var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));
            if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
              throw new Error("Attempted to load an infinite number of tiles");
            }
            for (var key in this._tiles) {
              var c = this._tiles[key].coords;
              if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
                this._tiles[key].current = false;
              }
            }
            if (Math.abs(zoom2 - this._tileZoom) > 1) {
              this._setView(center, zoom2);
              return;
            }
            for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
              for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
                var coords = new Point(i, j);
                coords.z = this._tileZoom;
                if (!this._isValidTile(coords)) {
                  continue;
                }
                var tile = this._tiles[this._tileCoordsToKey(coords)];
                if (tile) {
                  tile.current = true;
                } else {
                  queue.push(coords);
                }
              }
            }
            queue.sort(function(a, b) {
              return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
            });
            if (queue.length !== 0) {
              if (!this._loading) {
                this._loading = true;
                this.fire("loading");
              }
              var fragment = document.createDocumentFragment();
              for (i = 0; i < queue.length; i++) {
                this._addTile(queue[i], fragment);
              }
              this._level.el.appendChild(fragment);
            }
          },
          _isValidTile: function(coords) {
            var crs = this._map.options.crs;
            if (!crs.infinite) {
              var bounds = this._globalTileRange;
              if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
                return false;
              }
            }
            if (!this.options.bounds) {
              return true;
            }
            var tileBounds = this._tileCoordsToBounds(coords);
            return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
          },
          _keyToBounds: function(key) {
            return this._tileCoordsToBounds(this._keyToTileCoords(key));
          },
          _tileCoordsToNwSe: function(coords) {
            var map2 = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map2.unproject(nwPoint, coords.z), se = map2.unproject(sePoint, coords.z);
            return [nw, se];
          },
          _tileCoordsToBounds: function(coords) {
            var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
            if (!this.options.noWrap) {
              bounds = this._map.wrapLatLngBounds(bounds);
            }
            return bounds;
          },
          _tileCoordsToKey: function(coords) {
            return coords.x + ":" + coords.y + ":" + coords.z;
          },
          _keyToTileCoords: function(key) {
            var k = key.split(":"), coords = new Point(+k[0], +k[1]);
            coords.z = +k[2];
            return coords;
          },
          _removeTile: function(key) {
            var tile = this._tiles[key];
            if (!tile) {
              return;
            }
            remove(tile.el);
            delete this._tiles[key];
            this.fire("tileunload", {
              tile: tile.el,
              coords: this._keyToTileCoords(key)
            });
          },
          _initTile: function(tile) {
            addClass(tile, "leaflet-tile");
            var tileSize = this.getTileSize();
            tile.style.width = tileSize.x + "px";
            tile.style.height = tileSize.y + "px";
            tile.onselectstart = falseFn;
            tile.onmousemove = falseFn;
            if (ielt9 && this.options.opacity < 1) {
              setOpacity(tile, this.options.opacity);
            }
            if (android && !android23) {
              tile.style.WebkitBackfaceVisibility = "hidden";
            }
          },
          _addTile: function(coords, container) {
            var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
            var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
            this._initTile(tile);
            if (this.createTile.length < 2) {
              requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
            }
            setPosition(tile, tilePos);
            this._tiles[key] = {
              el: tile,
              coords,
              current: true
            };
            container.appendChild(tile);
            this.fire("tileloadstart", {
              tile,
              coords
            });
          },
          _tileReady: function(coords, err, tile) {
            if (err) {
              this.fire("tileerror", {
                error: err,
                tile,
                coords
              });
            }
            var key = this._tileCoordsToKey(coords);
            tile = this._tiles[key];
            if (!tile) {
              return;
            }
            tile.loaded = +new Date();
            if (this._map._fadeAnimated) {
              setOpacity(tile.el, 0);
              cancelAnimFrame(this._fadeFrame);
              this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
            } else {
              tile.active = true;
              this._pruneTiles();
            }
            if (!err) {
              addClass(tile.el, "leaflet-tile-loaded");
              this.fire("tileload", {
                tile: tile.el,
                coords
              });
            }
            if (this._noTilesToLoad()) {
              this._loading = false;
              this.fire("load");
              if (ielt9 || !this._map._fadeAnimated) {
                requestAnimFrame(this._pruneTiles, this);
              } else {
                setTimeout(bind(this._pruneTiles, this), 250);
              }
            }
          },
          _getTilePos: function(coords) {
            return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
          },
          _wrapCoords: function(coords) {
            var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
            newCoords.z = coords.z;
            return newCoords;
          },
          _pxBoundsToTileRange: function(bounds) {
            var tileSize = this.getTileSize();
            return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
          },
          _noTilesToLoad: function() {
            for (var key in this._tiles) {
              if (!this._tiles[key].loaded) {
                return false;
              }
            }
            return true;
          }
        });
        function gridLayer(options) {
          return new GridLayer(options);
        }
        var TileLayer = GridLayer.extend({
          options: {
            minZoom: 0,
            maxZoom: 18,
            subdomains: "abc",
            errorTileUrl: "",
            zoomOffset: 0,
            tms: false,
            zoomReverse: false,
            detectRetina: false,
            crossOrigin: false
          },
          initialize: function(url, options) {
            this._url = url;
            options = setOptions(this, options);
            if (options.detectRetina && retina && options.maxZoom > 0) {
              options.tileSize = Math.floor(options.tileSize / 2);
              if (!options.zoomReverse) {
                options.zoomOffset++;
                options.maxZoom--;
              } else {
                options.zoomOffset--;
                options.minZoom++;
              }
              options.minZoom = Math.max(0, options.minZoom);
            }
            if (typeof options.subdomains === "string") {
              options.subdomains = options.subdomains.split("");
            }
            if (!android) {
              this.on("tileunload", this._onTileRemove);
            }
          },
          setUrl: function(url, noRedraw) {
            if (this._url === url && noRedraw === void 0) {
              noRedraw = true;
            }
            this._url = url;
            if (!noRedraw) {
              this.redraw();
            }
            return this;
          },
          createTile: function(coords, done) {
            var tile = document.createElement("img");
            on(tile, "load", bind(this._tileOnLoad, this, done, tile));
            on(tile, "error", bind(this._tileOnError, this, done, tile));
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            tile.alt = "";
            tile.setAttribute("role", "presentation");
            tile.src = this.getTileUrl(coords);
            return tile;
          },
          getTileUrl: function(coords) {
            var data = {
              r: retina ? "@2x" : "",
              s: this._getSubdomain(coords),
              x: coords.x,
              y: coords.y,
              z: this._getZoomForUrl()
            };
            if (this._map && !this._map.options.crs.infinite) {
              var invertedY = this._globalTileRange.max.y - coords.y;
              if (this.options.tms) {
                data["y"] = invertedY;
              }
              data["-y"] = invertedY;
            }
            return template(this._url, extend(data, this.options));
          },
          _tileOnLoad: function(done, tile) {
            if (ielt9) {
              setTimeout(bind(done, this, null, tile), 0);
            } else {
              done(null, tile);
            }
          },
          _tileOnError: function(done, tile, e) {
            var errorUrl = this.options.errorTileUrl;
            if (errorUrl && tile.getAttribute("src") !== errorUrl) {
              tile.src = errorUrl;
            }
            done(e, tile);
          },
          _onTileRemove: function(e) {
            e.tile.onload = null;
          },
          _getZoomForUrl: function() {
            var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
            if (zoomReverse) {
              zoom2 = maxZoom - zoom2;
            }
            return zoom2 + zoomOffset;
          },
          _getSubdomain: function(tilePoint) {
            var index2 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
            return this.options.subdomains[index2];
          },
          _abortLoading: function() {
            var i, tile;
            for (i in this._tiles) {
              if (this._tiles[i].coords.z !== this._tileZoom) {
                tile = this._tiles[i].el;
                tile.onload = falseFn;
                tile.onerror = falseFn;
                if (!tile.complete) {
                  tile.src = emptyImageUrl;
                  remove(tile);
                  delete this._tiles[i];
                }
              }
            }
          },
          _removeTile: function(key) {
            var tile = this._tiles[key];
            if (!tile) {
              return;
            }
            if (!androidStock) {
              tile.el.setAttribute("src", emptyImageUrl);
            }
            return GridLayer.prototype._removeTile.call(this, key);
          },
          _tileReady: function(coords, err, tile) {
            if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
              return;
            }
            return GridLayer.prototype._tileReady.call(this, coords, err, tile);
          }
        });
        function tileLayer(url, options) {
          return new TileLayer(url, options);
        }
        var TileLayerWMS = TileLayer.extend({
          defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            layers: "",
            styles: "",
            format: "image/jpeg",
            transparent: false,
            version: "1.1.1"
          },
          options: {
            crs: null,
            uppercase: false
          },
          initialize: function(url, options) {
            this._url = url;
            var wmsParams = extend({}, this.defaultWmsParams);
            for (var i in options) {
              if (!(i in this.options)) {
                wmsParams[i] = options[i];
              }
            }
            options = setOptions(this, options);
            var realRetina = options.detectRetina && retina ? 2 : 1;
            var tileSize = this.getTileSize();
            wmsParams.width = tileSize.x * realRetina;
            wmsParams.height = tileSize.y * realRetina;
            this.wmsParams = wmsParams;
          },
          onAdd: function(map2) {
            this._crs = this.options.crs || map2.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);
            var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
            this.wmsParams[projectionKey] = this._crs.code;
            TileLayer.prototype.onAdd.call(this, map2);
          },
          getTileUrl: function(coords) {
            var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox2 = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(","), url = TileLayer.prototype.getTileUrl.call(this, coords);
            return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox2;
          },
          setParams: function(params, noRedraw) {
            extend(this.wmsParams, params);
            if (!noRedraw) {
              this.redraw();
            }
            return this;
          }
        });
        function tileLayerWMS(url, options) {
          return new TileLayerWMS(url, options);
        }
        TileLayer.WMS = TileLayerWMS;
        tileLayer.wms = tileLayerWMS;
        var Renderer = Layer.extend({
          options: {
            padding: 0.1,
            tolerance: 0
          },
          initialize: function(options) {
            setOptions(this, options);
            stamp(this);
            this._layers = this._layers || {};
          },
          onAdd: function() {
            if (!this._container) {
              this._initContainer();
              if (this._zoomAnimated) {
                addClass(this._container, "leaflet-zoom-animated");
              }
            }
            this.getPane().appendChild(this._container);
            this._update();
            this.on("update", this._updatePaths, this);
          },
          onRemove: function() {
            this.off("update", this._updatePaths, this);
            this._destroyContainer();
          },
          getEvents: function() {
            var events = {
              viewreset: this._reset,
              zoom: this._onZoom,
              moveend: this._update,
              zoomend: this._onZoomEnd
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._onAnimZoom;
            }
            return events;
          },
          _onAnimZoom: function(ev) {
            this._updateTransform(ev.center, ev.zoom);
          },
          _onZoom: function() {
            this._updateTransform(this._map.getCenter(), this._map.getZoom());
          },
          _updateTransform: function(center, zoom2) {
            var scale2 = this._map.getZoomScale(zoom2, this._zoom), position = getPosition(this._container), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), destCenterPoint = this._map.project(center, zoom2), centerOffset = destCenterPoint.subtract(currentCenterPoint), topLeftOffset = viewHalf.multiplyBy(-scale2).add(position).add(viewHalf).subtract(centerOffset);
            if (any3d) {
              setTransform(this._container, topLeftOffset, scale2);
            } else {
              setPosition(this._container, topLeftOffset);
            }
          },
          _reset: function() {
            this._update();
            this._updateTransform(this._center, this._zoom);
            for (var id in this._layers) {
              this._layers[id]._reset();
            }
          },
          _onZoomEnd: function() {
            for (var id in this._layers) {
              this._layers[id]._project();
            }
          },
          _updatePaths: function() {
            for (var id in this._layers) {
              this._layers[id]._update();
            }
          },
          _update: function() {
            var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
            this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
            this._center = this._map.getCenter();
            this._zoom = this._map.getZoom();
          }
        });
        var Canvas = Renderer.extend({
          getEvents: function() {
            var events = Renderer.prototype.getEvents.call(this);
            events.viewprereset = this._onViewPreReset;
            return events;
          },
          _onViewPreReset: function() {
            this._postponeUpdatePaths = true;
          },
          onAdd: function() {
            Renderer.prototype.onAdd.call(this);
            this._draw();
          },
          _initContainer: function() {
            var container = this._container = document.createElement("canvas");
            on(container, "mousemove", this._onMouseMove, this);
            on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
            on(container, "mouseout", this._handleMouseOut, this);
            this._ctx = container.getContext("2d");
          },
          _destroyContainer: function() {
            cancelAnimFrame(this._redrawRequest);
            delete this._ctx;
            remove(this._container);
            off(this._container);
            delete this._container;
          },
          _updatePaths: function() {
            if (this._postponeUpdatePaths) {
              return;
            }
            var layer;
            this._redrawBounds = null;
            for (var id in this._layers) {
              layer = this._layers[id];
              layer._update();
            }
            this._redraw();
          },
          _update: function() {
            if (this._map._animatingZoom && this._bounds) {
              return;
            }
            Renderer.prototype._update.call(this);
            var b = this._bounds, container = this._container, size = b.getSize(), m = retina ? 2 : 1;
            setPosition(container, b.min);
            container.width = m * size.x;
            container.height = m * size.y;
            container.style.width = size.x + "px";
            container.style.height = size.y + "px";
            if (retina) {
              this._ctx.scale(2, 2);
            }
            this._ctx.translate(-b.min.x, -b.min.y);
            this.fire("update");
          },
          _reset: function() {
            Renderer.prototype._reset.call(this);
            if (this._postponeUpdatePaths) {
              this._postponeUpdatePaths = false;
              this._updatePaths();
            }
          },
          _initPath: function(layer) {
            this._updateDashArray(layer);
            this._layers[stamp(layer)] = layer;
            var order = layer._order = {
              layer,
              prev: this._drawLast,
              next: null
            };
            if (this._drawLast) {
              this._drawLast.next = order;
            }
            this._drawLast = order;
            this._drawFirst = this._drawFirst || this._drawLast;
          },
          _addPath: function(layer) {
            this._requestRedraw(layer);
          },
          _removePath: function(layer) {
            var order = layer._order;
            var next = order.next;
            var prev = order.prev;
            if (next) {
              next.prev = prev;
            } else {
              this._drawLast = prev;
            }
            if (prev) {
              prev.next = next;
            } else {
              this._drawFirst = next;
            }
            delete layer._order;
            delete this._layers[stamp(layer)];
            this._requestRedraw(layer);
          },
          _updatePath: function(layer) {
            this._extendRedrawBounds(layer);
            layer._project();
            layer._update();
            this._requestRedraw(layer);
          },
          _updateStyle: function(layer) {
            this._updateDashArray(layer);
            this._requestRedraw(layer);
          },
          _updateDashArray: function(layer) {
            if (typeof layer.options.dashArray === "string") {
              var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i;
              for (i = 0; i < parts.length; i++) {
                dashValue = Number(parts[i]);
                if (isNaN(dashValue)) {
                  return;
                }
                dashArray.push(dashValue);
              }
              layer.options._dashArray = dashArray;
            } else {
              layer.options._dashArray = layer.options.dashArray;
            }
          },
          _requestRedraw: function(layer) {
            if (!this._map) {
              return;
            }
            this._extendRedrawBounds(layer);
            this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
          },
          _extendRedrawBounds: function(layer) {
            if (layer._pxBounds) {
              var padding = (layer.options.weight || 0) + 1;
              this._redrawBounds = this._redrawBounds || new Bounds();
              this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
              this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
            }
          },
          _redraw: function() {
            this._redrawRequest = null;
            if (this._redrawBounds) {
              this._redrawBounds.min._floor();
              this._redrawBounds.max._ceil();
            }
            this._clear();
            this._draw();
            this._redrawBounds = null;
          },
          _clear: function() {
            var bounds = this._redrawBounds;
            if (bounds) {
              var size = bounds.getSize();
              this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
            } else {
              this._ctx.save();
              this._ctx.setTransform(1, 0, 0, 1, 0, 0);
              this._ctx.clearRect(0, 0, this._container.width, this._container.height);
              this._ctx.restore();
            }
          },
          _draw: function() {
            var layer, bounds = this._redrawBounds;
            this._ctx.save();
            if (bounds) {
              var size = bounds.getSize();
              this._ctx.beginPath();
              this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
              this._ctx.clip();
            }
            this._drawing = true;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
                layer._updatePath();
              }
            }
            this._drawing = false;
            this._ctx.restore();
          },
          _updatePoly: function(layer, closed) {
            if (!this._drawing) {
              return;
            }
            var i, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;
            if (!len) {
              return;
            }
            ctx.beginPath();
            for (i = 0; i < len; i++) {
              for (j = 0, len2 = parts[i].length; j < len2; j++) {
                p = parts[i][j];
                ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
              }
              if (closed) {
                ctx.closePath();
              }
            }
            this._fillStroke(ctx, layer);
          },
          _updateCircle: function(layer) {
            if (!this._drawing || layer._empty()) {
              return;
            }
            var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
            if (s !== 1) {
              ctx.save();
              ctx.scale(1, s);
            }
            ctx.beginPath();
            ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);
            if (s !== 1) {
              ctx.restore();
            }
            this._fillStroke(ctx, layer);
          },
          _fillStroke: function(ctx, layer) {
            var options = layer.options;
            if (options.fill) {
              ctx.globalAlpha = options.fillOpacity;
              ctx.fillStyle = options.fillColor || options.color;
              ctx.fill(options.fillRule || "evenodd");
            }
            if (options.stroke && options.weight !== 0) {
              if (ctx.setLineDash) {
                ctx.setLineDash(layer.options && layer.options._dashArray || []);
              }
              ctx.globalAlpha = options.opacity;
              ctx.lineWidth = options.weight;
              ctx.strokeStyle = options.color;
              ctx.lineCap = options.lineCap;
              ctx.lineJoin = options.lineJoin;
              ctx.stroke();
            }
          },
          _onClick: function(e) {
            var point2 = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (layer.options.interactive && layer._containsPoint(point2)) {
                if (!(e.type === "click" || e.type !== "preclick") || !this._map._draggableMoved(layer)) {
                  clickedLayer = layer;
                }
              }
            }
            if (clickedLayer) {
              fakeStop(e);
              this._fireEvent([clickedLayer], e);
            }
          },
          _onMouseMove: function(e) {
            if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
              return;
            }
            var point2 = this._map.mouseEventToLayerPoint(e);
            this._handleMouseHover(e, point2);
          },
          _handleMouseOut: function(e) {
            var layer = this._hoveredLayer;
            if (layer) {
              removeClass(this._container, "leaflet-interactive");
              this._fireEvent([layer], e, "mouseout");
              this._hoveredLayer = null;
              this._mouseHoverThrottled = false;
            }
          },
          _handleMouseHover: function(e, point2) {
            if (this._mouseHoverThrottled) {
              return;
            }
            var layer, candidateHoveredLayer;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (layer.options.interactive && layer._containsPoint(point2)) {
                candidateHoveredLayer = layer;
              }
            }
            if (candidateHoveredLayer !== this._hoveredLayer) {
              this._handleMouseOut(e);
              if (candidateHoveredLayer) {
                addClass(this._container, "leaflet-interactive");
                this._fireEvent([candidateHoveredLayer], e, "mouseover");
                this._hoveredLayer = candidateHoveredLayer;
              }
            }
            if (this._hoveredLayer) {
              this._fireEvent([this._hoveredLayer], e);
            }
            this._mouseHoverThrottled = true;
            setTimeout(bind(function() {
              this._mouseHoverThrottled = false;
            }, this), 32);
          },
          _fireEvent: function(layers2, e, type) {
            this._map._fireDOMEvent(e, type || e.type, layers2);
          },
          _bringToFront: function(layer) {
            var order = layer._order;
            if (!order) {
              return;
            }
            var next = order.next;
            var prev = order.prev;
            if (next) {
              next.prev = prev;
            } else {
              return;
            }
            if (prev) {
              prev.next = next;
            } else if (next) {
              this._drawFirst = next;
            }
            order.prev = this._drawLast;
            this._drawLast.next = order;
            order.next = null;
            this._drawLast = order;
            this._requestRedraw(layer);
          },
          _bringToBack: function(layer) {
            var order = layer._order;
            if (!order) {
              return;
            }
            var next = order.next;
            var prev = order.prev;
            if (prev) {
              prev.next = next;
            } else {
              return;
            }
            if (next) {
              next.prev = prev;
            } else if (prev) {
              this._drawLast = prev;
            }
            order.prev = null;
            order.next = this._drawFirst;
            this._drawFirst.prev = order;
            this._drawFirst = order;
            this._requestRedraw(layer);
          }
        });
        function canvas$1(options) {
          return canvas ? new Canvas(options) : null;
        }
        var vmlCreate = function() {
          try {
            document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
            return function(name) {
              return document.createElement("<lvml:" + name + ' class="lvml">');
            };
          } catch (e) {
            return function(name) {
              return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
            };
          }
        }();
        var vmlMixin = {
          _initContainer: function() {
            this._container = create$1("div", "leaflet-vml-container");
          },
          _update: function() {
            if (this._map._animatingZoom) {
              return;
            }
            Renderer.prototype._update.call(this);
            this.fire("update");
          },
          _initPath: function(layer) {
            var container = layer._container = vmlCreate("shape");
            addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
            container.coordsize = "1 1";
            layer._path = vmlCreate("path");
            container.appendChild(layer._path);
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
          },
          _addPath: function(layer) {
            var container = layer._container;
            this._container.appendChild(container);
            if (layer.options.interactive) {
              layer.addInteractiveTarget(container);
            }
          },
          _removePath: function(layer) {
            var container = layer._container;
            remove(container);
            layer.removeInteractiveTarget(container);
            delete this._layers[stamp(layer)];
          },
          _updateStyle: function(layer) {
            var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
            container.stroked = !!options.stroke;
            container.filled = !!options.fill;
            if (options.stroke) {
              if (!stroke) {
                stroke = layer._stroke = vmlCreate("stroke");
              }
              container.appendChild(stroke);
              stroke.weight = options.weight + "px";
              stroke.color = options.color;
              stroke.opacity = options.opacity;
              if (options.dashArray) {
                stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
              } else {
                stroke.dashStyle = "";
              }
              stroke.endcap = options.lineCap.replace("butt", "flat");
              stroke.joinstyle = options.lineJoin;
            } else if (stroke) {
              container.removeChild(stroke);
              layer._stroke = null;
            }
            if (options.fill) {
              if (!fill) {
                fill = layer._fill = vmlCreate("fill");
              }
              container.appendChild(fill);
              fill.color = options.fillColor || options.color;
              fill.opacity = options.fillOpacity;
            } else if (fill) {
              container.removeChild(fill);
              layer._fill = null;
            }
          },
          _updateCircle: function(layer) {
            var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
            this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0," + 65535 * 360);
          },
          _setPath: function(layer, path) {
            layer._path.v = path;
          },
          _bringToFront: function(layer) {
            toFront(layer._container);
          },
          _bringToBack: function(layer) {
            toBack(layer._container);
          }
        };
        var create$2 = vml ? vmlCreate : svgCreate;
        var SVG = Renderer.extend({
          getEvents: function() {
            var events = Renderer.prototype.getEvents.call(this);
            events.zoomstart = this._onZoomStart;
            return events;
          },
          _initContainer: function() {
            this._container = create$2("svg");
            this._container.setAttribute("pointer-events", "none");
            this._rootGroup = create$2("g");
            this._container.appendChild(this._rootGroup);
          },
          _destroyContainer: function() {
            remove(this._container);
            off(this._container);
            delete this._container;
            delete this._rootGroup;
            delete this._svgSize;
          },
          _onZoomStart: function() {
            this._update();
          },
          _update: function() {
            if (this._map._animatingZoom && this._bounds) {
              return;
            }
            Renderer.prototype._update.call(this);
            var b = this._bounds, size = b.getSize(), container = this._container;
            if (!this._svgSize || !this._svgSize.equals(size)) {
              this._svgSize = size;
              container.setAttribute("width", size.x);
              container.setAttribute("height", size.y);
            }
            setPosition(container, b.min);
            container.setAttribute("viewBox", [b.min.x, b.min.y, size.x, size.y].join(" "));
            this.fire("update");
          },
          _initPath: function(layer) {
            var path = layer._path = create$2("path");
            if (layer.options.className) {
              addClass(path, layer.options.className);
            }
            if (layer.options.interactive) {
              addClass(path, "leaflet-interactive");
            }
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
          },
          _addPath: function(layer) {
            if (!this._rootGroup) {
              this._initContainer();
            }
            this._rootGroup.appendChild(layer._path);
            layer.addInteractiveTarget(layer._path);
          },
          _removePath: function(layer) {
            remove(layer._path);
            layer.removeInteractiveTarget(layer._path);
            delete this._layers[stamp(layer)];
          },
          _updatePath: function(layer) {
            layer._project();
            layer._update();
          },
          _updateStyle: function(layer) {
            var path = layer._path, options = layer.options;
            if (!path) {
              return;
            }
            if (options.stroke) {
              path.setAttribute("stroke", options.color);
              path.setAttribute("stroke-opacity", options.opacity);
              path.setAttribute("stroke-width", options.weight);
              path.setAttribute("stroke-linecap", options.lineCap);
              path.setAttribute("stroke-linejoin", options.lineJoin);
              if (options.dashArray) {
                path.setAttribute("stroke-dasharray", options.dashArray);
              } else {
                path.removeAttribute("stroke-dasharray");
              }
              if (options.dashOffset) {
                path.setAttribute("stroke-dashoffset", options.dashOffset);
              } else {
                path.removeAttribute("stroke-dashoffset");
              }
            } else {
              path.setAttribute("stroke", "none");
            }
            if (options.fill) {
              path.setAttribute("fill", options.fillColor || options.color);
              path.setAttribute("fill-opacity", options.fillOpacity);
              path.setAttribute("fill-rule", options.fillRule || "evenodd");
            } else {
              path.setAttribute("fill", "none");
            }
          },
          _updatePoly: function(layer, closed) {
            this._setPath(layer, pointsToPath(layer._parts, closed));
          },
          _updateCircle: function(layer) {
            var p = layer._point, r = Math.max(Math.round(layer._radius), 1), r2 = Math.max(Math.round(layer._radiusY), 1) || r, arc = "a" + r + "," + r2 + " 0 1,0 ";
            var d = layer._empty() ? "M0 0" : "M" + (p.x - r) + "," + p.y + arc + r * 2 + ",0 " + arc + -r * 2 + ",0 ";
            this._setPath(layer, d);
          },
          _setPath: function(layer, path) {
            layer._path.setAttribute("d", path);
          },
          _bringToFront: function(layer) {
            toFront(layer._path);
          },
          _bringToBack: function(layer) {
            toBack(layer._path);
          }
        });
        if (vml) {
          SVG.include(vmlMixin);
        }
        function svg$1(options) {
          return svg || vml ? new SVG(options) : null;
        }
        Map2.include({
          getRenderer: function(layer) {
            var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
            if (!renderer) {
              renderer = this._renderer = this._createRenderer();
            }
            if (!this.hasLayer(renderer)) {
              this.addLayer(renderer);
            }
            return renderer;
          },
          _getPaneRenderer: function(name) {
            if (name === "overlayPane" || name === void 0) {
              return false;
            }
            var renderer = this._paneRenderers[name];
            if (renderer === void 0) {
              renderer = this._createRenderer({ pane: name });
              this._paneRenderers[name] = renderer;
            }
            return renderer;
          },
          _createRenderer: function(options) {
            return this.options.preferCanvas && canvas$1(options) || svg$1(options);
          }
        });
        var Rectangle = Polygon.extend({
          initialize: function(latLngBounds, options) {
            Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
          },
          setBounds: function(latLngBounds) {
            return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
          },
          _boundsToLatLngs: function(latLngBounds) {
            latLngBounds = toLatLngBounds(latLngBounds);
            return [
              latLngBounds.getSouthWest(),
              latLngBounds.getNorthWest(),
              latLngBounds.getNorthEast(),
              latLngBounds.getSouthEast()
            ];
          }
        });
        function rectangle(latLngBounds, options) {
          return new Rectangle(latLngBounds, options);
        }
        SVG.create = create$2;
        SVG.pointsToPath = pointsToPath;
        GeoJSON.geometryToLayer = geometryToLayer;
        GeoJSON.coordsToLatLng = coordsToLatLng;
        GeoJSON.coordsToLatLngs = coordsToLatLngs;
        GeoJSON.latLngToCoords = latLngToCoords;
        GeoJSON.latLngsToCoords = latLngsToCoords;
        GeoJSON.getFeature = getFeature;
        GeoJSON.asFeature = asFeature;
        Map2.mergeOptions({
          boxZoom: true
        });
        var BoxZoom = Handler.extend({
          initialize: function(map2) {
            this._map = map2;
            this._container = map2._container;
            this._pane = map2._panes.overlayPane;
            this._resetStateTimeout = 0;
            map2.on("unload", this._destroy, this);
          },
          addHooks: function() {
            on(this._container, "mousedown", this._onMouseDown, this);
          },
          removeHooks: function() {
            off(this._container, "mousedown", this._onMouseDown, this);
          },
          moved: function() {
            return this._moved;
          },
          _destroy: function() {
            remove(this._pane);
            delete this._pane;
          },
          _resetState: function() {
            this._resetStateTimeout = 0;
            this._moved = false;
          },
          _clearDeferredResetState: function() {
            if (this._resetStateTimeout !== 0) {
              clearTimeout(this._resetStateTimeout);
              this._resetStateTimeout = 0;
            }
          },
          _onMouseDown: function(e) {
            if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
              return false;
            }
            this._clearDeferredResetState();
            this._resetState();
            disableTextSelection();
            disableImageDrag();
            this._startPoint = this._map.mouseEventToContainerPoint(e);
            on(document, {
              contextmenu: stop,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseMove: function(e) {
            if (!this._moved) {
              this._moved = true;
              this._box = create$1("div", "leaflet-zoom-box", this._container);
              addClass(this._container, "leaflet-crosshair");
              this._map.fire("boxzoomstart");
            }
            this._point = this._map.mouseEventToContainerPoint(e);
            var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
            setPosition(this._box, bounds.min);
            this._box.style.width = size.x + "px";
            this._box.style.height = size.y + "px";
          },
          _finish: function() {
            if (this._moved) {
              remove(this._box);
              removeClass(this._container, "leaflet-crosshair");
            }
            enableTextSelection();
            enableImageDrag();
            off(document, {
              contextmenu: stop,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseUp: function(e) {
            if (e.which !== 1 && e.button !== 1) {
              return;
            }
            this._finish();
            if (!this._moved) {
              return;
            }
            this._clearDeferredResetState();
            this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
            var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));
            this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
          },
          _onKeyDown: function(e) {
            if (e.keyCode === 27) {
              this._finish();
            }
          }
        });
        Map2.addInitHook("addHandler", "boxZoom", BoxZoom);
        Map2.mergeOptions({
          doubleClickZoom: true
        });
        var DoubleClickZoom = Handler.extend({
          addHooks: function() {
            this._map.on("dblclick", this._onDoubleClick, this);
          },
          removeHooks: function() {
            this._map.off("dblclick", this._onDoubleClick, this);
          },
          _onDoubleClick: function(e) {
            var map2 = this._map, oldZoom = map2.getZoom(), delta = map2.options.zoomDelta, zoom2 = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
            if (map2.options.doubleClickZoom === "center") {
              map2.setZoom(zoom2);
            } else {
              map2.setZoomAround(e.containerPoint, zoom2);
            }
          }
        });
        Map2.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
        Map2.mergeOptions({
          dragging: true,
          inertia: !android23,
          inertiaDeceleration: 3400,
          inertiaMaxSpeed: Infinity,
          easeLinearity: 0.2,
          worldCopyJump: false,
          maxBoundsViscosity: 0
        });
        var Drag = Handler.extend({
          addHooks: function() {
            if (!this._draggable) {
              var map2 = this._map;
              this._draggable = new Draggable(map2._mapPane, map2._container);
              this._draggable.on({
                dragstart: this._onDragStart,
                drag: this._onDrag,
                dragend: this._onDragEnd
              }, this);
              this._draggable.on("predrag", this._onPreDragLimit, this);
              if (map2.options.worldCopyJump) {
                this._draggable.on("predrag", this._onPreDragWrap, this);
                map2.on("zoomend", this._onZoomEnd, this);
                map2.whenReady(this._onZoomEnd, this);
              }
            }
            addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
            this._draggable.enable();
            this._positions = [];
            this._times = [];
          },
          removeHooks: function() {
            removeClass(this._map._container, "leaflet-grab");
            removeClass(this._map._container, "leaflet-touch-drag");
            this._draggable.disable();
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          moving: function() {
            return this._draggable && this._draggable._moving;
          },
          _onDragStart: function() {
            var map2 = this._map;
            map2._stop();
            if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
              var bounds = toLatLngBounds(this._map.options.maxBounds);
              this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));
              this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
            } else {
              this._offsetLimit = null;
            }
            map2.fire("movestart").fire("dragstart");
            if (map2.options.inertia) {
              this._positions = [];
              this._times = [];
            }
          },
          _onDrag: function(e) {
            if (this._map.options.inertia) {
              var time = this._lastTime = +new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
              this._positions.push(pos);
              this._times.push(time);
              this._prunePositions(time);
            }
            this._map.fire("move", e).fire("drag", e);
          },
          _prunePositions: function(time) {
            while (this._positions.length > 1 && time - this._times[0] > 50) {
              this._positions.shift();
              this._times.shift();
            }
          },
          _onZoomEnd: function() {
            var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
            this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
            this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
          },
          _viscousLimit: function(value, threshold) {
            return value - (value - threshold) * this._viscosity;
          },
          _onPreDragLimit: function() {
            if (!this._viscosity || !this._offsetLimit) {
              return;
            }
            var offset = this._draggable._newPos.subtract(this._draggable._startPos);
            var limit = this._offsetLimit;
            if (offset.x < limit.min.x) {
              offset.x = this._viscousLimit(offset.x, limit.min.x);
            }
            if (offset.y < limit.min.y) {
              offset.y = this._viscousLimit(offset.y, limit.min.y);
            }
            if (offset.x > limit.max.x) {
              offset.x = this._viscousLimit(offset.x, limit.max.x);
            }
            if (offset.y > limit.max.y) {
              offset.y = this._viscousLimit(offset.y, limit.max.y);
            }
            this._draggable._newPos = this._draggable._startPos.add(offset);
          },
          _onPreDragWrap: function() {
            var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x2 = this._draggable._newPos.x, newX1 = (x2 - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x2 + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
            this._draggable._absPos = this._draggable._newPos.clone();
            this._draggable._newPos.x = newX;
          },
          _onDragEnd: function(e) {
            var map2 = this._map, options = map2.options, noInertia = !options.inertia || this._times.length < 2;
            map2.fire("dragend", e);
            if (noInertia) {
              map2.fire("moveend");
            } else {
              this._prunePositions(+new Date());
              var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
              if (!offset.x && !offset.y) {
                map2.fire("moveend");
              } else {
                offset = map2._limitOffset(offset, map2.options.maxBounds);
                requestAnimFrame(function() {
                  map2.panBy(offset, {
                    duration: decelerationDuration,
                    easeLinearity: ease,
                    noMoveStart: true,
                    animate: true
                  });
                });
              }
            }
          }
        });
        Map2.addInitHook("addHandler", "dragging", Drag);
        Map2.mergeOptions({
          keyboard: true,
          keyboardPanDelta: 80
        });
        var Keyboard = Handler.extend({
          keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61, 171],
            zoomOut: [189, 109, 54, 173]
          },
          initialize: function(map2) {
            this._map = map2;
            this._setPanDelta(map2.options.keyboardPanDelta);
            this._setZoomDelta(map2.options.zoomDelta);
          },
          addHooks: function() {
            var container = this._map._container;
            if (container.tabIndex <= 0) {
              container.tabIndex = "0";
            }
            on(container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this);
            this._map.on({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          removeHooks: function() {
            this._removeHooks();
            off(this._map._container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this);
            this._map.off({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          _onMouseDown: function() {
            if (this._focused) {
              return;
            }
            var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
            this._map._container.focus();
            window.scrollTo(left, top);
          },
          _onFocus: function() {
            this._focused = true;
            this._map.fire("focus");
          },
          _onBlur: function() {
            this._focused = false;
            this._map.fire("blur");
          },
          _setPanDelta: function(panDelta) {
            var keys = this._panKeys = {}, codes = this.keyCodes, i, len;
            for (i = 0, len = codes.left.length; i < len; i++) {
              keys[codes.left[i]] = [-1 * panDelta, 0];
            }
            for (i = 0, len = codes.right.length; i < len; i++) {
              keys[codes.right[i]] = [panDelta, 0];
            }
            for (i = 0, len = codes.down.length; i < len; i++) {
              keys[codes.down[i]] = [0, panDelta];
            }
            for (i = 0, len = codes.up.length; i < len; i++) {
              keys[codes.up[i]] = [0, -1 * panDelta];
            }
          },
          _setZoomDelta: function(zoomDelta) {
            var keys = this._zoomKeys = {}, codes = this.keyCodes, i, len;
            for (i = 0, len = codes.zoomIn.length; i < len; i++) {
              keys[codes.zoomIn[i]] = zoomDelta;
            }
            for (i = 0, len = codes.zoomOut.length; i < len; i++) {
              keys[codes.zoomOut[i]] = -zoomDelta;
            }
          },
          _addHooks: function() {
            on(document, "keydown", this._onKeyDown, this);
          },
          _removeHooks: function() {
            off(document, "keydown", this._onKeyDown, this);
          },
          _onKeyDown: function(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) {
              return;
            }
            var key = e.keyCode, map2 = this._map, offset;
            if (key in this._panKeys) {
              if (!map2._panAnim || !map2._panAnim._inProgress) {
                offset = this._panKeys[key];
                if (e.shiftKey) {
                  offset = toPoint(offset).multiplyBy(3);
                }
                map2.panBy(offset);
                if (map2.options.maxBounds) {
                  map2.panInsideBounds(map2.options.maxBounds);
                }
              }
            } else if (key in this._zoomKeys) {
              map2.setZoom(map2.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
            } else if (key === 27 && map2._popup && map2._popup.options.closeOnEscapeKey) {
              map2.closePopup();
            } else {
              return;
            }
            stop(e);
          }
        });
        Map2.addInitHook("addHandler", "keyboard", Keyboard);
        Map2.mergeOptions({
          scrollWheelZoom: true,
          wheelDebounceTime: 40,
          wheelPxPerZoomLevel: 60
        });
        var ScrollWheelZoom = Handler.extend({
          addHooks: function() {
            on(this._map._container, "wheel", this._onWheelScroll, this);
            this._delta = 0;
          },
          removeHooks: function() {
            off(this._map._container, "wheel", this._onWheelScroll, this);
          },
          _onWheelScroll: function(e) {
            var delta = getWheelDelta(e);
            var debounce = this._map.options.wheelDebounceTime;
            this._delta += delta;
            this._lastMousePos = this._map.mouseEventToContainerPoint(e);
            if (!this._startTime) {
              this._startTime = +new Date();
            }
            var left = Math.max(debounce - (+new Date() - this._startTime), 0);
            clearTimeout(this._timer);
            this._timer = setTimeout(bind(this._performZoom, this), left);
            stop(e);
          },
          _performZoom: function() {
            var map2 = this._map, zoom2 = map2.getZoom(), snap = this._map.options.zoomSnap || 0;
            map2._stop();
            var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map2._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
            this._delta = 0;
            this._startTime = null;
            if (!delta) {
              return;
            }
            if (map2.options.scrollWheelZoom === "center") {
              map2.setZoom(zoom2 + delta);
            } else {
              map2.setZoomAround(this._lastMousePos, zoom2 + delta);
            }
          }
        });
        Map2.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
        Map2.mergeOptions({
          tap: true,
          tapTolerance: 15
        });
        var Tap = Handler.extend({
          addHooks: function() {
            on(this._map._container, "touchstart", this._onDown, this);
          },
          removeHooks: function() {
            off(this._map._container, "touchstart", this._onDown, this);
          },
          _onDown: function(e) {
            if (!e.touches) {
              return;
            }
            preventDefault(e);
            this._fireClick = true;
            if (e.touches.length > 1) {
              this._fireClick = false;
              clearTimeout(this._holdTimeout);
              return;
            }
            var first = e.touches[0], el = first.target;
            this._startPos = this._newPos = new Point(first.clientX, first.clientY);
            if (el.tagName && el.tagName.toLowerCase() === "a") {
              addClass(el, "leaflet-active");
            }
            this._holdTimeout = setTimeout(bind(function() {
              if (this._isTapValid()) {
                this._fireClick = false;
                this._onUp();
                this._simulateEvent("contextmenu", first);
              }
            }, this), 1e3);
            this._simulateEvent("mousedown", first);
            on(document, {
              touchmove: this._onMove,
              touchend: this._onUp
            }, this);
          },
          _onUp: function(e) {
            clearTimeout(this._holdTimeout);
            off(document, {
              touchmove: this._onMove,
              touchend: this._onUp
            }, this);
            if (this._fireClick && e && e.changedTouches) {
              var first = e.changedTouches[0], el = first.target;
              if (el && el.tagName && el.tagName.toLowerCase() === "a") {
                removeClass(el, "leaflet-active");
              }
              this._simulateEvent("mouseup", first);
              if (this._isTapValid()) {
                this._simulateEvent("click", first);
              }
            }
          },
          _isTapValid: function() {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
          },
          _onMove: function(e) {
            var first = e.touches[0];
            this._newPos = new Point(first.clientX, first.clientY);
            this._simulateEvent("mousemove", first);
          },
          _simulateEvent: function(type, e) {
            var simulatedEvent = document.createEvent("MouseEvents");
            simulatedEvent._simulated = true;
            e.target._simulatedClick = true;
            simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);
            e.target.dispatchEvent(simulatedEvent);
          }
        });
        if (touch && (!pointer || safari)) {
          Map2.addInitHook("addHandler", "tap", Tap);
        }
        Map2.mergeOptions({
          touchZoom: touch && !android23,
          bounceAtZoomLimits: true
        });
        var TouchZoom = Handler.extend({
          addHooks: function() {
            addClass(this._map._container, "leaflet-touch-zoom");
            on(this._map._container, "touchstart", this._onTouchStart, this);
          },
          removeHooks: function() {
            removeClass(this._map._container, "leaflet-touch-zoom");
            off(this._map._container, "touchstart", this._onTouchStart, this);
          },
          _onTouchStart: function(e) {
            var map2 = this._map;
            if (!e.touches || e.touches.length !== 2 || map2._animatingZoom || this._zooming) {
              return;
            }
            var p1 = map2.mouseEventToContainerPoint(e.touches[0]), p2 = map2.mouseEventToContainerPoint(e.touches[1]);
            this._centerPoint = map2.getSize()._divideBy(2);
            this._startLatLng = map2.containerPointToLatLng(this._centerPoint);
            if (map2.options.touchZoom !== "center") {
              this._pinchStartLatLng = map2.containerPointToLatLng(p1.add(p2)._divideBy(2));
            }
            this._startDist = p1.distanceTo(p2);
            this._startZoom = map2.getZoom();
            this._moved = false;
            this._zooming = true;
            map2._stop();
            on(document, "touchmove", this._onTouchMove, this);
            on(document, "touchend", this._onTouchEnd, this);
            preventDefault(e);
          },
          _onTouchMove: function(e) {
            if (!e.touches || e.touches.length !== 2 || !this._zooming) {
              return;
            }
            var map2 = this._map, p1 = map2.mouseEventToContainerPoint(e.touches[0]), p2 = map2.mouseEventToContainerPoint(e.touches[1]), scale2 = p1.distanceTo(p2) / this._startDist;
            this._zoom = map2.getScaleZoom(scale2, this._startZoom);
            if (!map2.options.bounceAtZoomLimits && (this._zoom < map2.getMinZoom() && scale2 < 1 || this._zoom > map2.getMaxZoom() && scale2 > 1)) {
              this._zoom = map2._limitZoom(this._zoom);
            }
            if (map2.options.touchZoom === "center") {
              this._center = this._startLatLng;
              if (scale2 === 1) {
                return;
              }
            } else {
              var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
              if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
                return;
              }
              this._center = map2.unproject(map2.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
            }
            if (!this._moved) {
              map2._moveStart(true, false);
              this._moved = true;
            }
            cancelAnimFrame(this._animRequest);
            var moveFn = bind(map2._move, map2, this._center, this._zoom, { pinch: true, round: false });
            this._animRequest = requestAnimFrame(moveFn, this, true);
            preventDefault(e);
          },
          _onTouchEnd: function() {
            if (!this._moved || !this._zooming) {
              this._zooming = false;
              return;
            }
            this._zooming = false;
            cancelAnimFrame(this._animRequest);
            off(document, "touchmove", this._onTouchMove, this);
            off(document, "touchend", this._onTouchEnd, this);
            if (this._map.options.zoomAnimation) {
              this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
            } else {
              this._map._resetView(this._center, this._map._limitZoom(this._zoom));
            }
          }
        });
        Map2.addInitHook("addHandler", "touchZoom", TouchZoom);
        Map2.BoxZoom = BoxZoom;
        Map2.DoubleClickZoom = DoubleClickZoom;
        Map2.Drag = Drag;
        Map2.Keyboard = Keyboard;
        Map2.ScrollWheelZoom = ScrollWheelZoom;
        Map2.Tap = Tap;
        Map2.TouchZoom = TouchZoom;
        exports2.version = version;
        exports2.Control = Control;
        exports2.control = control;
        exports2.Browser = Browser;
        exports2.Evented = Evented;
        exports2.Mixin = Mixin;
        exports2.Util = Util;
        exports2.Class = Class;
        exports2.Handler = Handler;
        exports2.extend = extend;
        exports2.bind = bind;
        exports2.stamp = stamp;
        exports2.setOptions = setOptions;
        exports2.DomEvent = DomEvent;
        exports2.DomUtil = DomUtil;
        exports2.PosAnimation = PosAnimation;
        exports2.Draggable = Draggable;
        exports2.LineUtil = LineUtil;
        exports2.PolyUtil = PolyUtil;
        exports2.Point = Point;
        exports2.point = toPoint;
        exports2.Bounds = Bounds;
        exports2.bounds = toBounds;
        exports2.Transformation = Transformation;
        exports2.transformation = toTransformation;
        exports2.Projection = index;
        exports2.LatLng = LatLng;
        exports2.latLng = toLatLng;
        exports2.LatLngBounds = LatLngBounds;
        exports2.latLngBounds = toLatLngBounds;
        exports2.CRS = CRS;
        exports2.GeoJSON = GeoJSON;
        exports2.geoJSON = geoJSON;
        exports2.geoJson = geoJson;
        exports2.Layer = Layer;
        exports2.LayerGroup = LayerGroup;
        exports2.layerGroup = layerGroup;
        exports2.FeatureGroup = FeatureGroup;
        exports2.featureGroup = featureGroup;
        exports2.ImageOverlay = ImageOverlay;
        exports2.imageOverlay = imageOverlay;
        exports2.VideoOverlay = VideoOverlay;
        exports2.videoOverlay = videoOverlay;
        exports2.SVGOverlay = SVGOverlay;
        exports2.svgOverlay = svgOverlay;
        exports2.DivOverlay = DivOverlay;
        exports2.Popup = Popup;
        exports2.popup = popup;
        exports2.Tooltip = Tooltip;
        exports2.tooltip = tooltip;
        exports2.Icon = Icon;
        exports2.icon = icon;
        exports2.DivIcon = DivIcon;
        exports2.divIcon = divIcon;
        exports2.Marker = Marker;
        exports2.marker = marker;
        exports2.TileLayer = TileLayer;
        exports2.tileLayer = tileLayer;
        exports2.GridLayer = GridLayer;
        exports2.gridLayer = gridLayer;
        exports2.SVG = SVG;
        exports2.svg = svg$1;
        exports2.Renderer = Renderer;
        exports2.Canvas = Canvas;
        exports2.canvas = canvas$1;
        exports2.Path = Path;
        exports2.CircleMarker = CircleMarker;
        exports2.circleMarker = circleMarker;
        exports2.Circle = Circle2;
        exports2.circle = circle2;
        exports2.Polyline = Polyline;
        exports2.polyline = polyline;
        exports2.Polygon = Polygon;
        exports2.polygon = polygon2;
        exports2.Rectangle = Rectangle;
        exports2.rectangle = rectangle;
        exports2.Map = Map2;
        exports2.map = createMap;
        var oldL = window.L;
        exports2.noConflict = function() {
          window.L = oldL;
          return this;
        };
        window.L = exports2;
      });
    }
  });

  // node_modules/@turf/helpers/dist/es/index.js
  var earthRadius = 63710088e-1;
  var factors = {
    centimeters: earthRadius * 100,
    centimetres: earthRadius * 100,
    degrees: earthRadius / 111325,
    feet: earthRadius * 3.28084,
    inches: earthRadius * 39.37,
    kilometers: earthRadius / 1e3,
    kilometres: earthRadius / 1e3,
    meters: earthRadius,
    metres: earthRadius,
    miles: earthRadius / 1609.344,
    millimeters: earthRadius * 1e3,
    millimetres: earthRadius * 1e3,
    nauticalmiles: earthRadius / 1852,
    radians: 1,
    yards: earthRadius * 1.0936
  };
  var unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.37,
    kilometers: 1 / 1e3,
    kilometres: 1 / 1e3,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1e3,
    millimetres: 1e3,
    nauticalmiles: 1 / 1852,
    radians: 1 / earthRadius,
    yards: 1.0936133
  };
  function feature(geom, properties, options) {
    if (options === void 0) {
      options = {};
    }
    var feat = { type: "Feature" };
    if (options.id === 0 || options.id) {
      feat.id = options.id;
    }
    if (options.bbox) {
      feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
  }
  function point(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    if (!coordinates) {
      throw new Error("coordinates is required");
    }
    if (!Array.isArray(coordinates)) {
      throw new Error("coordinates must be an Array");
    }
    if (coordinates.length < 2) {
      throw new Error("coordinates must be at least 2 numbers long");
    }
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
      throw new Error("coordinates must contain numbers");
    }
    var geom = {
      type: "Point",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function polygon(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
      var ring = coordinates_1[_i];
      if (ring.length < 4) {
        throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
      }
      for (var j = 0; j < ring[ring.length - 1].length; j++) {
        if (ring[ring.length - 1][j] !== ring[0][j]) {
          throw new Error("First and last Position are not equivalent.");
        }
      }
    }
    var geom = {
      type: "Polygon",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function lineString(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    if (coordinates.length < 2) {
      throw new Error("coordinates must be an array of two or more positions");
    }
    var geom = {
      type: "LineString",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function multiPoint(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    var geom = {
      type: "MultiPoint",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
  }

  // node_modules/@turf/meta/dist/es/index.js
  function coordEach(geojson, callback, excludeWrapCoord) {
    if (geojson === null)
      return;
    var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
        var multiFeatureIndex = 0;
        var geometryIndex = 0;
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
        if (geometry === null)
          continue;
        coords = geometry.coordinates;
        var geomType = geometry.type;
        wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
        switch (geomType) {
          case null:
            break;
          case "Point":
            if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)
              return false;
            coordIndex++;
            multiFeatureIndex++;
            break;
          case "LineString":
          case "MultiPoint":
            for (j = 0; j < coords.length; j++) {
              if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)
                return false;
              coordIndex++;
              if (geomType === "MultiPoint")
                multiFeatureIndex++;
            }
            if (geomType === "LineString")
              multiFeatureIndex++;
            break;
          case "Polygon":
          case "MultiLineString":
            for (j = 0; j < coords.length; j++) {
              for (k = 0; k < coords[j].length - wrapShrink; k++) {
                if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)
                  return false;
                coordIndex++;
              }
              if (geomType === "MultiLineString")
                multiFeatureIndex++;
              if (geomType === "Polygon")
                geometryIndex++;
            }
            if (geomType === "Polygon")
              multiFeatureIndex++;
            break;
          case "MultiPolygon":
            for (j = 0; j < coords.length; j++) {
              geometryIndex = 0;
              for (k = 0; k < coords[j].length; k++) {
                for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                  if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)
                    return false;
                  coordIndex++;
                }
                geometryIndex++;
              }
              multiFeatureIndex++;
            }
            break;
          case "GeometryCollection":
            for (j = 0; j < geometry.geometries.length; j++)
              if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)
                return false;
            break;
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
    }
  }
  function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
      if (coordIndex === 0 && initialValue === void 0)
        previousValue = currentCoord;
      else
        previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
    }, excludeWrapCoord);
    return previousValue;
  }
  function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (i = 0; i < stop; i++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
      featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
      featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
      featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (g = 0; g < stopG; g++) {
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
        if (geometry === null) {
          if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false)
            return false;
          continue;
        }
        switch (geometry.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon": {
            if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false)
              return false;
            break;
          }
          case "GeometryCollection": {
            for (j = 0; j < geometry.geometries.length; j++) {
              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false)
                return false;
            }
            break;
          }
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
      featureIndex++;
    }
  }
  function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
      if (featureIndex === 0 && initialValue === void 0)
        previousValue = currentGeometry;
      else
        previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
    });
    return previousValue;
  }
  function flattenEach(geojson, callback) {
    geomEach(geojson, function(geometry, featureIndex, properties, bbox2, id) {
      var type = geometry === null ? null : geometry.type;
      switch (type) {
        case null:
        case "Point":
        case "LineString":
        case "Polygon":
          if (callback(feature(geometry, properties, { bbox: bbox2, id }), featureIndex, 0) === false)
            return false;
          return;
      }
      var geomType;
      switch (type) {
        case "MultiPoint":
          geomType = "Point";
          break;
        case "MultiLineString":
          geomType = "LineString";
          break;
        case "MultiPolygon":
          geomType = "Polygon";
          break;
      }
      for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
        var coordinate = geometry.coordinates[multiFeatureIndex];
        var geom = {
          type: geomType,
          coordinates: coordinate
        };
        if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)
          return false;
      }
    });
  }

  // node_modules/@turf/bbox/dist/es/index.js
  function bbox(geojson) {
    var result = [Infinity, Infinity, -Infinity, -Infinity];
    coordEach(geojson, function(coord) {
      if (result[0] > coord[0]) {
        result[0] = coord[0];
      }
      if (result[1] > coord[1]) {
        result[1] = coord[1];
      }
      if (result[2] < coord[0]) {
        result[2] = coord[0];
      }
      if (result[3] < coord[1]) {
        result[3] = coord[1];
      }
    });
    return result;
  }
  bbox["default"] = bbox;
  var es_default = bbox;

  // node_modules/@turf/invariant/dist/es/index.js
  function getCoord(coord) {
    if (!coord) {
      throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
      if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
        return coord.geometry.coordinates;
      }
      if (coord.type === "Point") {
        return coord.coordinates;
      }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
      return coord;
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
  }
  function featureOf(feature2, type, name) {
    if (!feature2) {
      throw new Error("No feature passed");
    }
    if (!name) {
      throw new Error(".featureOf() requires a name");
    }
    if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
      throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature2.geometry || feature2.geometry.type !== type) {
      throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature2.geometry.type);
    }
  }
  function getGeom(geojson) {
    if (geojson.type === "Feature") {
      return geojson.geometry;
    }
    return geojson;
  }

  // node_modules/@turf/isolines/dist/es/index.js
  var import_object_assign = __toESM(require_object_assign(), 1);

  // node_modules/@turf/convex/dist/es/index.js
  var import_concaveman = __toESM(require_concaveman(), 1);

  // node_modules/@turf/boolean-point-in-polygon/dist/es/index.js
  function booleanPointInPolygon(point2, polygon2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!point2) {
      throw new Error("point is required");
    }
    if (!polygon2) {
      throw new Error("polygon is required");
    }
    var pt = getCoord(point2);
    var geom = getGeom(polygon2);
    var type = geom.type;
    var bbox2 = polygon2.bbox;
    var polys = geom.coordinates;
    if (bbox2 && inBBox(pt, bbox2) === false) {
      return false;
    }
    if (type === "Polygon") {
      polys = [polys];
    }
    var insidePoly = false;
    for (var i = 0; i < polys.length && !insidePoly; i++) {
      if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
        var inHole = false;
        var k = 1;
        while (k < polys[i].length && !inHole) {
          if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
            inHole = true;
          }
          k++;
        }
        if (!inHole) {
          insidePoly = true;
        }
      }
    }
    return insidePoly;
  }
  function inRing(pt, ring, ignoreBoundary) {
    var isInside = false;
    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {
      ring = ring.slice(0, ring.length - 1);
    }
    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
      var xi = ring[i][0];
      var yi = ring[i][1];
      var xj = ring[j][0];
      var yj = ring[j][1];
      var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;
      if (onBoundary) {
        return !ignoreBoundary;
      }
      var intersect2 = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;
      if (intersect2) {
        isInside = !isInside;
      }
    }
    return isInside;
  }
  function inBBox(pt, bbox2) {
    return bbox2[0] <= pt[0] && bbox2[1] <= pt[1] && bbox2[2] >= pt[0] && bbox2[3] >= pt[1];
  }

  // node_modules/@turf/tin/dist/es/index.js
  var Triangle = function() {
    function Triangle2(a, b, c) {
      this.a = a;
      this.b = b;
      this.c = c;
      var A = b.x - a.x;
      var B2 = b.y - a.y;
      var C = c.x - a.x;
      var D = c.y - a.y;
      var E = A * (a.x + b.x) + B2 * (a.y + b.y);
      var F = C * (a.x + c.x) + D * (a.y + c.y);
      var G = 2 * (A * (c.y - b.y) - B2 * (c.x - b.x));
      var dx;
      var dy;
      this.x = (D * E - B2 * F) / G;
      this.y = (A * F - C * E) / G;
      dx = this.x - a.x;
      dy = this.y - a.y;
      this.r = dx * dx + dy * dy;
    }
    return Triangle2;
  }();

  // node_modules/topojson-server/src/hash/point-hash.js
  var buffer = new ArrayBuffer(16);
  var floats = new Float64Array(buffer);
  var uints = new Uint32Array(buffer);

  // node_modules/@turf/collect/dist/es/index.js
  var import_rbush = __toESM(require_rbush(), 1);

  // node_modules/@turf/bezier-spline/dist/es/lib/spline.js
  var Spline = function() {
    function Spline2(options) {
      this.points = options.points || [];
      this.duration = options.duration || 1e4;
      this.sharpness = options.sharpness || 0.85;
      this.centers = [];
      this.controls = [];
      this.stepLength = options.stepLength || 60;
      this.length = this.points.length;
      this.delay = 0;
      for (var i = 0; i < this.length; i++) {
        this.points[i].z = this.points[i].z || 0;
      }
      for (var i = 0; i < this.length - 1; i++) {
        var p1 = this.points[i];
        var p2 = this.points[i + 1];
        this.centers.push({
          x: (p1.x + p2.x) / 2,
          y: (p1.y + p2.y) / 2,
          z: (p1.z + p2.z) / 2
        });
      }
      this.controls.push([this.points[0], this.points[0]]);
      for (var i = 0; i < this.centers.length - 1; i++) {
        var dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
        var dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
        var dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
        this.controls.push([
          {
            x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),
            y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),
            z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)
          },
          {
            x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),
            y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),
            z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)
          }
        ]);
      }
      this.controls.push([
        this.points[this.length - 1],
        this.points[this.length - 1]
      ]);
      this.steps = this.cacheSteps(this.stepLength);
      return this;
    }
    Spline2.prototype.cacheSteps = function(mindist) {
      var steps = [];
      var laststep = this.pos(0);
      steps.push(0);
      for (var t = 0; t < this.duration; t += 10) {
        var step = this.pos(t);
        var dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));
        if (dist > mindist) {
          steps.push(t);
          laststep = step;
        }
      }
      return steps;
    };
    Spline2.prototype.vector = function(t) {
      var p1 = this.pos(t + 10);
      var p2 = this.pos(t - 10);
      return {
        angle: 180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,
        speed: Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))
      };
    };
    Spline2.prototype.pos = function(time) {
      var t = time - this.delay;
      if (t < 0) {
        t = 0;
      }
      if (t > this.duration) {
        t = this.duration - 1;
      }
      var t2 = t / this.duration;
      if (t2 >= 1) {
        return this.points[this.length - 1];
      }
      var n = Math.floor((this.points.length - 1) * t2);
      var t1 = (this.length - 1) * t2 - n;
      return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);
    };
    return Spline2;
  }();
  function bezier(t, p1, c1, c2, p2) {
    var b = B(t);
    var pos = {
      x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
      y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
      z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]
    };
    return pos;
  }
  function B(t) {
    var t2 = t * t;
    var t3 = t2 * t;
    return [
      t3,
      3 * t2 * (1 - t),
      3 * t * (1 - t) * (1 - t),
      (1 - t) * (1 - t) * (1 - t)
    ];
  }

  // node_modules/@turf/bbox-polygon/dist/es/index.js
  function bboxPolygon(bbox2, options) {
    if (options === void 0) {
      options = {};
    }
    var west = Number(bbox2[0]);
    var south = Number(bbox2[1]);
    var east = Number(bbox2[2]);
    var north = Number(bbox2[3]);
    if (bbox2.length === 6) {
      throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
    }
    var lowLeft = [west, south];
    var topLeft = [west, north];
    var topRight = [east, north];
    var lowRight = [east, south];
    return polygon([[lowLeft, lowRight, topRight, topLeft, lowLeft]], options.properties, { bbox: bbox2, id: options.id });
  }

  // node_modules/@turf/envelope/dist/es/index.js
  function envelope(geojson) {
    return bboxPolygon(es_default(geojson));
  }
  var es_default5 = envelope;

  // node_modules/@turf/tesselate/dist/es/index.js
  var import_earcut = __toESM(require_earcut(), 1);

  // node_modules/@turf/line-intersect/dist/es/index.js
  var import_geojson_rbush = __toESM(require_geojson_rbush(), 1);

  // node_modules/@turf/nearest-point-to-line/dist/es/index.js
  var import_object_assign2 = __toESM(require_object_assign(), 1);

  // node_modules/@turf/area/dist/es/index.js
  var RADIUS = 6378137;
  function area(geojson) {
    return geomReduce(geojson, function(value, geom) {
      return value + calculateArea(geom);
    }, 0);
  }
  function calculateArea(geom) {
    var total = 0;
    var i;
    switch (geom.type) {
      case "Polygon":
        return polygonArea(geom.coordinates);
      case "MultiPolygon":
        for (i = 0; i < geom.coordinates.length; i++) {
          total += polygonArea(geom.coordinates[i]);
        }
        return total;
      case "Point":
      case "MultiPoint":
      case "LineString":
      case "MultiLineString":
        return 0;
    }
    return 0;
  }
  function polygonArea(coords) {
    var total = 0;
    if (coords && coords.length > 0) {
      total += Math.abs(ringArea(coords[0]));
      for (var i = 1; i < coords.length; i++) {
        total -= Math.abs(ringArea(coords[i]));
      }
    }
    return total;
  }
  function ringArea(coords) {
    var p1;
    var p2;
    var p3;
    var lowerIndex;
    var middleIndex;
    var upperIndex;
    var i;
    var total = 0;
    var coordsLength = coords.length;
    if (coordsLength > 2) {
      for (i = 0; i < coordsLength; i++) {
        if (i === coordsLength - 2) {
          lowerIndex = coordsLength - 2;
          middleIndex = coordsLength - 1;
          upperIndex = 0;
        } else if (i === coordsLength - 1) {
          lowerIndex = coordsLength - 1;
          middleIndex = 0;
          upperIndex = 1;
        } else {
          lowerIndex = i;
          middleIndex = i + 1;
          upperIndex = i + 2;
        }
        p1 = coords[lowerIndex];
        p2 = coords[middleIndex];
        p3 = coords[upperIndex];
        total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
      }
      total = total * RADIUS * RADIUS / 2;
    }
    return total;
  }
  function rad(num) {
    return num * Math.PI / 180;
  }

  // node_modules/@turf/unkink-polygon/dist/es/index.js
  var import_rbush2 = __toESM(require_rbush(), 1);

  // node_modules/@turf/great-circle/dist/es/index.js
  var D2R = Math.PI / 180;
  var R2D = 180 / Math.PI;
  var Coord = function(lon, lat) {
    this.lon = lon;
    this.lat = lat;
    this.x = D2R * lon;
    this.y = D2R * lat;
  };
  Coord.prototype.view = function() {
    return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4);
  };
  Coord.prototype.antipode = function() {
    var anti_lat = -1 * this.lat;
    var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
    return new Coord(anti_lon, anti_lat);
  };
  var LineString = function() {
    this.coords = [];
    this.length = 0;
  };
  LineString.prototype.move_to = function(coord) {
    this.length++;
    this.coords.push(coord);
  };
  var Arc = function(properties) {
    this.properties = properties || {};
    this.geometries = [];
  };
  Arc.prototype.json = function() {
    if (this.geometries.length <= 0) {
      return {
        geometry: { type: "LineString", coordinates: null },
        type: "Feature",
        properties: this.properties
      };
    } else if (this.geometries.length === 1) {
      return {
        geometry: { type: "LineString", coordinates: this.geometries[0].coords },
        type: "Feature",
        properties: this.properties
      };
    } else {
      var multiline = [];
      for (var i = 0; i < this.geometries.length; i++) {
        multiline.push(this.geometries[i].coords);
      }
      return {
        geometry: { type: "MultiLineString", coordinates: multiline },
        type: "Feature",
        properties: this.properties
      };
    }
  };
  Arc.prototype.wkt = function() {
    var wkt_string = "";
    var wkt = "LINESTRING(";
    var collect = function(c) {
      wkt += c[0] + " " + c[1] + ",";
    };
    for (var i = 0; i < this.geometries.length; i++) {
      if (this.geometries[i].coords.length === 0) {
        return "LINESTRING(empty)";
      } else {
        var coords = this.geometries[i].coords;
        coords.forEach(collect);
        wkt_string += wkt.substring(0, wkt.length - 1) + ")";
      }
    }
    return wkt_string;
  };
  var GreatCircle = function(start, end, properties) {
    if (!start || start.x === void 0 || start.y === void 0) {
      throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
    }
    if (!end || end.x === void 0 || end.y === void 0) {
      throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
    }
    this.start = new Coord(start.x, start.y);
    this.end = new Coord(end.x, end.y);
    this.properties = properties || {};
    var w = this.start.x - this.end.x;
    var h = this.start.y - this.end.y;
    var z = Math.pow(Math.sin(h / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(w / 2), 2);
    this.g = 2 * Math.asin(Math.sqrt(z));
    if (this.g === Math.PI) {
      throw new Error("it appears " + start.view() + " and " + end.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite");
    } else if (isNaN(this.g)) {
      throw new Error("could not calculate great circle between " + start + " and " + end);
    }
  };
  GreatCircle.prototype.interpolate = function(f) {
    var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);
    var B2 = Math.sin(f * this.g) / Math.sin(this.g);
    var x2 = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B2 * Math.cos(this.end.y) * Math.cos(this.end.x);
    var y2 = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B2 * Math.cos(this.end.y) * Math.sin(this.end.x);
    var z = A * Math.sin(this.start.y) + B2 * Math.sin(this.end.y);
    var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2)));
    var lon = R2D * Math.atan2(y2, x2);
    return [lon, lat];
  };
  GreatCircle.prototype.Arc = function(npoints, options) {
    var first_pass = [];
    if (!npoints || npoints <= 2) {
      first_pass.push([this.start.lon, this.start.lat]);
      first_pass.push([this.end.lon, this.end.lat]);
    } else {
      var delta = 1 / (npoints - 1);
      for (var i = 0; i < npoints; ++i) {
        var step = delta * i;
        var pair2 = this.interpolate(step);
        first_pass.push(pair2);
      }
    }
    var bHasBigDiff = false;
    var dfMaxSmallDiffLong = 0;
    var dfDateLineOffset = options && options.offset ? options.offset : 10;
    var dfLeftBorderX = 180 - dfDateLineOffset;
    var dfRightBorderX = -180 + dfDateLineOffset;
    var dfDiffSpace = 360 - dfDateLineOffset;
    for (var j = 1; j < first_pass.length; ++j) {
      var dfPrevX = first_pass[j - 1][0];
      var dfX = first_pass[j][0];
      var dfDiffLong = Math.abs(dfX - dfPrevX);
      if (dfDiffLong > dfDiffSpace && (dfX > dfLeftBorderX && dfPrevX < dfRightBorderX || dfPrevX > dfLeftBorderX && dfX < dfRightBorderX)) {
        bHasBigDiff = true;
      } else if (dfDiffLong > dfMaxSmallDiffLong) {
        dfMaxSmallDiffLong = dfDiffLong;
      }
    }
    var poMulti = [];
    if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {
      var poNewLS = [];
      poMulti.push(poNewLS);
      for (var k = 0; k < first_pass.length; ++k) {
        var dfX0 = parseFloat(first_pass[k][0]);
        if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {
          var dfX1 = parseFloat(first_pass[k - 1][0]);
          var dfY1 = parseFloat(first_pass[k - 1][1]);
          var dfX2 = parseFloat(first_pass[k][0]);
          var dfY2 = parseFloat(first_pass[k][1]);
          if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 === 180 && k + 1 < first_pass.length && first_pass[k - 1][0] > -180 && first_pass[k - 1][0] < dfRightBorderX) {
            poNewLS.push([-180, first_pass[k][1]]);
            k++;
            poNewLS.push([first_pass[k][0], first_pass[k][1]]);
            continue;
          } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 === -180 && k + 1 < first_pass.length && first_pass[k - 1][0] > dfLeftBorderX && first_pass[k - 1][0] < 180) {
            poNewLS.push([180, first_pass[k][1]]);
            k++;
            poNewLS.push([first_pass[k][0], first_pass[k][1]]);
            continue;
          }
          if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {
            var tmpX = dfX1;
            dfX1 = dfX2;
            dfX2 = tmpX;
            var tmpY = dfY1;
            dfY1 = dfY2;
            dfY2 = tmpY;
          }
          if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {
            dfX2 += 360;
          }
          if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {
            var dfRatio = (180 - dfX1) / (dfX2 - dfX1);
            var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;
            poNewLS.push([
              first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180,
              dfY
            ]);
            poNewLS = [];
            poNewLS.push([
              first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180,
              dfY
            ]);
            poMulti.push(poNewLS);
          } else {
            poNewLS = [];
            poMulti.push(poNewLS);
          }
          poNewLS.push([dfX0, first_pass[k][1]]);
        } else {
          poNewLS.push([first_pass[k][0], first_pass[k][1]]);
        }
      }
    } else {
      var poNewLS0 = [];
      poMulti.push(poNewLS0);
      for (var l = 0; l < first_pass.length; ++l) {
        poNewLS0.push([first_pass[l][0], first_pass[l][1]]);
      }
    }
    var arc = new Arc(this.properties);
    for (var m = 0; m < poMulti.length; ++m) {
      var line = new LineString();
      arc.geometries.push(line);
      var points = poMulti[m];
      for (var j0 = 0; j0 < points.length; ++j0) {
        line.move_to(points[j0]);
      }
    }
    return arc;
  };

  // node_modules/@turf/line-split/dist/es/index.js
  var import_geojson_rbush2 = __toESM(require_geojson_rbush(), 1);

  // node_modules/@turf/line-overlap/dist/es/index.js
  var import_geojson_rbush3 = __toESM(require_geojson_rbush(), 1);
  var import_deep_equal = __toESM(require_deep_equal(), 1);

  // node_modules/@turf/isobands/dist/es/index.js
  var import_object_assign3 = __toESM(require_object_assign(), 1);
  var isoBandNextXTL = [];
  var isoBandNextYTL = [];
  var isoBandNextOTL = [];
  var isoBandNextXTR = [];
  var isoBandNextYTR = [];
  var isoBandNextOTR = [];
  var isoBandNextXRT = [];
  var isoBandNextYRT = [];
  var isoBandNextORT = [];
  var isoBandNextXRB = [];
  var isoBandNextYRB = [];
  var isoBandNextORB = [];
  var isoBandNextXBL = [];
  var isoBandNextYBL = [];
  var isoBandNextOBL = [];
  var isoBandNextXBR = [];
  var isoBandNextYBR = [];
  var isoBandNextOBR = [];
  var isoBandNextXLT = [];
  var isoBandNextYLT = [];
  var isoBandNextOLT = [];
  var isoBandNextXLB = [];
  var isoBandNextYLB = [];
  var isoBandNextOLB = [];
  isoBandNextXRT[85] = isoBandNextXRB[85] = -1;
  isoBandNextYRT[85] = isoBandNextYRB[85] = 0;
  isoBandNextORT[85] = isoBandNextORB[85] = 1;
  isoBandNextXLT[85] = isoBandNextXLB[85] = 1;
  isoBandNextYLT[85] = isoBandNextYLB[85] = 0;
  isoBandNextOLT[85] = isoBandNextOLB[85] = 1;
  isoBandNextXTL[85] = isoBandNextXTR[85] = 0;
  isoBandNextYTL[85] = isoBandNextYTR[85] = -1;
  isoBandNextOTL[85] = isoBandNextOBL[85] = 0;
  isoBandNextXBR[85] = isoBandNextXBL[85] = 0;
  isoBandNextYBR[85] = isoBandNextYBL[85] = 1;
  isoBandNextOTR[85] = isoBandNextOBR[85] = 1;
  isoBandNextXLB[1] = isoBandNextXLB[169] = 0;
  isoBandNextYLB[1] = isoBandNextYLB[169] = -1;
  isoBandNextOLB[1] = isoBandNextOLB[169] = 0;
  isoBandNextXBL[1] = isoBandNextXBL[169] = -1;
  isoBandNextYBL[1] = isoBandNextYBL[169] = 0;
  isoBandNextOBL[1] = isoBandNextOBL[169] = 0;
  isoBandNextXRB[4] = isoBandNextXRB[166] = 0;
  isoBandNextYRB[4] = isoBandNextYRB[166] = -1;
  isoBandNextORB[4] = isoBandNextORB[166] = 1;
  isoBandNextXBR[4] = isoBandNextXBR[166] = 1;
  isoBandNextYBR[4] = isoBandNextYBR[166] = 0;
  isoBandNextOBR[4] = isoBandNextOBR[166] = 0;
  isoBandNextXRT[16] = isoBandNextXRT[154] = 0;
  isoBandNextYRT[16] = isoBandNextYRT[154] = 1;
  isoBandNextORT[16] = isoBandNextORT[154] = 1;
  isoBandNextXTR[16] = isoBandNextXTR[154] = 1;
  isoBandNextYTR[16] = isoBandNextYTR[154] = 0;
  isoBandNextOTR[16] = isoBandNextOTR[154] = 1;
  isoBandNextXLT[64] = isoBandNextXLT[106] = 0;
  isoBandNextYLT[64] = isoBandNextYLT[106] = 1;
  isoBandNextOLT[64] = isoBandNextOLT[106] = 0;
  isoBandNextXTL[64] = isoBandNextXTL[106] = -1;
  isoBandNextYTL[64] = isoBandNextYTL[106] = 0;
  isoBandNextOTL[64] = isoBandNextOTL[106] = 1;
  isoBandNextXLT[2] = isoBandNextXLT[168] = 0;
  isoBandNextYLT[2] = isoBandNextYLT[168] = -1;
  isoBandNextOLT[2] = isoBandNextOLT[168] = 1;
  isoBandNextXLB[2] = isoBandNextXLB[168] = 0;
  isoBandNextYLB[2] = isoBandNextYLB[168] = -1;
  isoBandNextOLB[2] = isoBandNextOLB[168] = 0;
  isoBandNextXBL[2] = isoBandNextXBL[168] = -1;
  isoBandNextYBL[2] = isoBandNextYBL[168] = 0;
  isoBandNextOBL[2] = isoBandNextOBL[168] = 0;
  isoBandNextXBR[2] = isoBandNextXBR[168] = -1;
  isoBandNextYBR[2] = isoBandNextYBR[168] = 0;
  isoBandNextOBR[2] = isoBandNextOBR[168] = 1;
  isoBandNextXRT[8] = isoBandNextXRT[162] = 0;
  isoBandNextYRT[8] = isoBandNextYRT[162] = -1;
  isoBandNextORT[8] = isoBandNextORT[162] = 0;
  isoBandNextXRB[8] = isoBandNextXRB[162] = 0;
  isoBandNextYRB[8] = isoBandNextYRB[162] = -1;
  isoBandNextORB[8] = isoBandNextORB[162] = 1;
  isoBandNextXBL[8] = isoBandNextXBL[162] = 1;
  isoBandNextYBL[8] = isoBandNextYBL[162] = 0;
  isoBandNextOBL[8] = isoBandNextOBL[162] = 1;
  isoBandNextXBR[8] = isoBandNextXBR[162] = 1;
  isoBandNextYBR[8] = isoBandNextYBR[162] = 0;
  isoBandNextOBR[8] = isoBandNextOBR[162] = 0;
  isoBandNextXRT[32] = isoBandNextXRT[138] = 0;
  isoBandNextYRT[32] = isoBandNextYRT[138] = 1;
  isoBandNextORT[32] = isoBandNextORT[138] = 1;
  isoBandNextXRB[32] = isoBandNextXRB[138] = 0;
  isoBandNextYRB[32] = isoBandNextYRB[138] = 1;
  isoBandNextORB[32] = isoBandNextORB[138] = 0;
  isoBandNextXTL[32] = isoBandNextXTL[138] = 1;
  isoBandNextYTL[32] = isoBandNextYTL[138] = 0;
  isoBandNextOTL[32] = isoBandNextOTL[138] = 0;
  isoBandNextXTR[32] = isoBandNextXTR[138] = 1;
  isoBandNextYTR[32] = isoBandNextYTR[138] = 0;
  isoBandNextOTR[32] = isoBandNextOTR[138] = 1;
  isoBandNextXLB[128] = isoBandNextXLB[42] = 0;
  isoBandNextYLB[128] = isoBandNextYLB[42] = 1;
  isoBandNextOLB[128] = isoBandNextOLB[42] = 1;
  isoBandNextXLT[128] = isoBandNextXLT[42] = 0;
  isoBandNextYLT[128] = isoBandNextYLT[42] = 1;
  isoBandNextOLT[128] = isoBandNextOLT[42] = 0;
  isoBandNextXTL[128] = isoBandNextXTL[42] = -1;
  isoBandNextYTL[128] = isoBandNextYTL[42] = 0;
  isoBandNextOTL[128] = isoBandNextOTL[42] = 1;
  isoBandNextXTR[128] = isoBandNextXTR[42] = -1;
  isoBandNextYTR[128] = isoBandNextYTR[42] = 0;
  isoBandNextOTR[128] = isoBandNextOTR[42] = 0;
  isoBandNextXRB[5] = isoBandNextXRB[165] = -1;
  isoBandNextYRB[5] = isoBandNextYRB[165] = 0;
  isoBandNextORB[5] = isoBandNextORB[165] = 0;
  isoBandNextXLB[5] = isoBandNextXLB[165] = 1;
  isoBandNextYLB[5] = isoBandNextYLB[165] = 0;
  isoBandNextOLB[5] = isoBandNextOLB[165] = 0;
  isoBandNextXBR[20] = isoBandNextXBR[150] = 0;
  isoBandNextYBR[20] = isoBandNextYBR[150] = 1;
  isoBandNextOBR[20] = isoBandNextOBR[150] = 1;
  isoBandNextXTR[20] = isoBandNextXTR[150] = 0;
  isoBandNextYTR[20] = isoBandNextYTR[150] = -1;
  isoBandNextOTR[20] = isoBandNextOTR[150] = 1;
  isoBandNextXRT[80] = isoBandNextXRT[90] = -1;
  isoBandNextYRT[80] = isoBandNextYRT[90] = 0;
  isoBandNextORT[80] = isoBandNextORT[90] = 1;
  isoBandNextXLT[80] = isoBandNextXLT[90] = 1;
  isoBandNextYLT[80] = isoBandNextYLT[90] = 0;
  isoBandNextOLT[80] = isoBandNextOLT[90] = 1;
  isoBandNextXBL[65] = isoBandNextXBL[105] = 0;
  isoBandNextYBL[65] = isoBandNextYBL[105] = 1;
  isoBandNextOBL[65] = isoBandNextOBL[105] = 0;
  isoBandNextXTL[65] = isoBandNextXTL[105] = 0;
  isoBandNextYTL[65] = isoBandNextYTL[105] = -1;
  isoBandNextOTL[65] = isoBandNextOTL[105] = 0;
  isoBandNextXRT[160] = isoBandNextXRT[10] = -1;
  isoBandNextYRT[160] = isoBandNextYRT[10] = 0;
  isoBandNextORT[160] = isoBandNextORT[10] = 1;
  isoBandNextXRB[160] = isoBandNextXRB[10] = -1;
  isoBandNextYRB[160] = isoBandNextYRB[10] = 0;
  isoBandNextORB[160] = isoBandNextORB[10] = 0;
  isoBandNextXLB[160] = isoBandNextXLB[10] = 1;
  isoBandNextYLB[160] = isoBandNextYLB[10] = 0;
  isoBandNextOLB[160] = isoBandNextOLB[10] = 0;
  isoBandNextXLT[160] = isoBandNextXLT[10] = 1;
  isoBandNextYLT[160] = isoBandNextYLT[10] = 0;
  isoBandNextOLT[160] = isoBandNextOLT[10] = 1;
  isoBandNextXBR[130] = isoBandNextXBR[40] = 0;
  isoBandNextYBR[130] = isoBandNextYBR[40] = 1;
  isoBandNextOBR[130] = isoBandNextOBR[40] = 1;
  isoBandNextXBL[130] = isoBandNextXBL[40] = 0;
  isoBandNextYBL[130] = isoBandNextYBL[40] = 1;
  isoBandNextOBL[130] = isoBandNextOBL[40] = 0;
  isoBandNextXTL[130] = isoBandNextXTL[40] = 0;
  isoBandNextYTL[130] = isoBandNextYTL[40] = -1;
  isoBandNextOTL[130] = isoBandNextOTL[40] = 0;
  isoBandNextXTR[130] = isoBandNextXTR[40] = 0;
  isoBandNextYTR[130] = isoBandNextYTR[40] = -1;
  isoBandNextOTR[130] = isoBandNextOTR[40] = 1;
  isoBandNextXRB[37] = isoBandNextXRB[133] = 0;
  isoBandNextYRB[37] = isoBandNextYRB[133] = 1;
  isoBandNextORB[37] = isoBandNextORB[133] = 1;
  isoBandNextXLB[37] = isoBandNextXLB[133] = 0;
  isoBandNextYLB[37] = isoBandNextYLB[133] = 1;
  isoBandNextOLB[37] = isoBandNextOLB[133] = 0;
  isoBandNextXTL[37] = isoBandNextXTL[133] = -1;
  isoBandNextYTL[37] = isoBandNextYTL[133] = 0;
  isoBandNextOTL[37] = isoBandNextOTL[133] = 0;
  isoBandNextXTR[37] = isoBandNextXTR[133] = 1;
  isoBandNextYTR[37] = isoBandNextYTR[133] = 0;
  isoBandNextOTR[37] = isoBandNextOTR[133] = 0;
  isoBandNextXBR[148] = isoBandNextXBR[22] = -1;
  isoBandNextYBR[148] = isoBandNextYBR[22] = 0;
  isoBandNextOBR[148] = isoBandNextOBR[22] = 0;
  isoBandNextXLB[148] = isoBandNextXLB[22] = 0;
  isoBandNextYLB[148] = isoBandNextYLB[22] = -1;
  isoBandNextOLB[148] = isoBandNextOLB[22] = 1;
  isoBandNextXLT[148] = isoBandNextXLT[22] = 0;
  isoBandNextYLT[148] = isoBandNextYLT[22] = 1;
  isoBandNextOLT[148] = isoBandNextOLT[22] = 1;
  isoBandNextXTR[148] = isoBandNextXTR[22] = -1;
  isoBandNextYTR[148] = isoBandNextYTR[22] = 0;
  isoBandNextOTR[148] = isoBandNextOTR[22] = 1;
  isoBandNextXRT[82] = isoBandNextXRT[88] = 0;
  isoBandNextYRT[82] = isoBandNextYRT[88] = -1;
  isoBandNextORT[82] = isoBandNextORT[88] = 1;
  isoBandNextXBR[82] = isoBandNextXBR[88] = 1;
  isoBandNextYBR[82] = isoBandNextYBR[88] = 0;
  isoBandNextOBR[82] = isoBandNextOBR[88] = 1;
  isoBandNextXBL[82] = isoBandNextXBL[88] = -1;
  isoBandNextYBL[82] = isoBandNextYBL[88] = 0;
  isoBandNextOBL[82] = isoBandNextOBL[88] = 1;
  isoBandNextXLT[82] = isoBandNextXLT[88] = 0;
  isoBandNextYLT[82] = isoBandNextYLT[88] = -1;
  isoBandNextOLT[82] = isoBandNextOLT[88] = 0;
  isoBandNextXRT[73] = isoBandNextXRT[97] = 0;
  isoBandNextYRT[73] = isoBandNextYRT[97] = 1;
  isoBandNextORT[73] = isoBandNextORT[97] = 0;
  isoBandNextXRB[73] = isoBandNextXRB[97] = 0;
  isoBandNextYRB[73] = isoBandNextYRB[97] = -1;
  isoBandNextORB[73] = isoBandNextORB[97] = 0;
  isoBandNextXBL[73] = isoBandNextXBL[97] = 1;
  isoBandNextYBL[73] = isoBandNextYBL[97] = 0;
  isoBandNextOBL[73] = isoBandNextOBL[97] = 0;
  isoBandNextXTL[73] = isoBandNextXTL[97] = 1;
  isoBandNextYTL[73] = isoBandNextYTL[97] = 0;
  isoBandNextOTL[73] = isoBandNextOTL[97] = 1;
  isoBandNextXRT[145] = isoBandNextXRT[25] = 0;
  isoBandNextYRT[145] = isoBandNextYRT[25] = -1;
  isoBandNextORT[145] = isoBandNextORT[25] = 0;
  isoBandNextXBL[145] = isoBandNextXBL[25] = 1;
  isoBandNextYBL[145] = isoBandNextYBL[25] = 0;
  isoBandNextOBL[145] = isoBandNextOBL[25] = 1;
  isoBandNextXLB[145] = isoBandNextXLB[25] = 0;
  isoBandNextYLB[145] = isoBandNextYLB[25] = 1;
  isoBandNextOLB[145] = isoBandNextOLB[25] = 1;
  isoBandNextXTR[145] = isoBandNextXTR[25] = -1;
  isoBandNextYTR[145] = isoBandNextYTR[25] = 0;
  isoBandNextOTR[145] = isoBandNextOTR[25] = 0;
  isoBandNextXRB[70] = isoBandNextXRB[100] = 0;
  isoBandNextYRB[70] = isoBandNextYRB[100] = 1;
  isoBandNextORB[70] = isoBandNextORB[100] = 0;
  isoBandNextXBR[70] = isoBandNextXBR[100] = -1;
  isoBandNextYBR[70] = isoBandNextYBR[100] = 0;
  isoBandNextOBR[70] = isoBandNextOBR[100] = 1;
  isoBandNextXLT[70] = isoBandNextXLT[100] = 0;
  isoBandNextYLT[70] = isoBandNextYLT[100] = -1;
  isoBandNextOLT[70] = isoBandNextOLT[100] = 1;
  isoBandNextXTL[70] = isoBandNextXTL[100] = 1;
  isoBandNextYTL[70] = isoBandNextYTL[100] = 0;
  isoBandNextOTL[70] = isoBandNextOTL[100] = 0;
  isoBandNextXRB[101] = isoBandNextXRB[69] = 0;
  isoBandNextYRB[101] = isoBandNextYRB[69] = 1;
  isoBandNextORB[101] = isoBandNextORB[69] = 0;
  isoBandNextXTL[101] = isoBandNextXTL[69] = 1;
  isoBandNextYTL[101] = isoBandNextYTL[69] = 0;
  isoBandNextOTL[101] = isoBandNextOTL[69] = 0;
  isoBandNextXLB[149] = isoBandNextXLB[21] = 0;
  isoBandNextYLB[149] = isoBandNextYLB[21] = 1;
  isoBandNextOLB[149] = isoBandNextOLB[21] = 1;
  isoBandNextXTR[149] = isoBandNextXTR[21] = -1;
  isoBandNextYTR[149] = isoBandNextYTR[21] = 0;
  isoBandNextOTR[149] = isoBandNextOTR[21] = 0;
  isoBandNextXBR[86] = isoBandNextXBR[84] = -1;
  isoBandNextYBR[86] = isoBandNextYBR[84] = 0;
  isoBandNextOBR[86] = isoBandNextOBR[84] = 1;
  isoBandNextXLT[86] = isoBandNextXLT[84] = 0;
  isoBandNextYLT[86] = isoBandNextYLT[84] = -1;
  isoBandNextOLT[86] = isoBandNextOLT[84] = 1;
  isoBandNextXRT[89] = isoBandNextXRT[81] = 0;
  isoBandNextYRT[89] = isoBandNextYRT[81] = -1;
  isoBandNextORT[89] = isoBandNextORT[81] = 0;
  isoBandNextXBL[89] = isoBandNextXBL[81] = 1;
  isoBandNextYBL[89] = isoBandNextYBL[81] = 0;
  isoBandNextOBL[89] = isoBandNextOBL[81] = 1;
  isoBandNextXRT[96] = isoBandNextXRT[74] = 0;
  isoBandNextYRT[96] = isoBandNextYRT[74] = 1;
  isoBandNextORT[96] = isoBandNextORT[74] = 0;
  isoBandNextXRB[96] = isoBandNextXRB[74] = -1;
  isoBandNextYRB[96] = isoBandNextYRB[74] = 0;
  isoBandNextORB[96] = isoBandNextORB[74] = 1;
  isoBandNextXLT[96] = isoBandNextXLT[74] = 1;
  isoBandNextYLT[96] = isoBandNextYLT[74] = 0;
  isoBandNextOLT[96] = isoBandNextOLT[74] = 0;
  isoBandNextXTL[96] = isoBandNextXTL[74] = 1;
  isoBandNextYTL[96] = isoBandNextYTL[74] = 0;
  isoBandNextOTL[96] = isoBandNextOTL[74] = 1;
  isoBandNextXRT[24] = isoBandNextXRT[146] = 0;
  isoBandNextYRT[24] = isoBandNextYRT[146] = -1;
  isoBandNextORT[24] = isoBandNextORT[146] = 1;
  isoBandNextXBR[24] = isoBandNextXBR[146] = 1;
  isoBandNextYBR[24] = isoBandNextYBR[146] = 0;
  isoBandNextOBR[24] = isoBandNextOBR[146] = 1;
  isoBandNextXBL[24] = isoBandNextXBL[146] = 0;
  isoBandNextYBL[24] = isoBandNextYBL[146] = 1;
  isoBandNextOBL[24] = isoBandNextOBL[146] = 1;
  isoBandNextXTR[24] = isoBandNextXTR[146] = 0;
  isoBandNextYTR[24] = isoBandNextYTR[146] = -1;
  isoBandNextOTR[24] = isoBandNextOTR[146] = 0;
  isoBandNextXRB[6] = isoBandNextXRB[164] = -1;
  isoBandNextYRB[6] = isoBandNextYRB[164] = 0;
  isoBandNextORB[6] = isoBandNextORB[164] = 1;
  isoBandNextXBR[6] = isoBandNextXBR[164] = -1;
  isoBandNextYBR[6] = isoBandNextYBR[164] = 0;
  isoBandNextOBR[6] = isoBandNextOBR[164] = 0;
  isoBandNextXLB[6] = isoBandNextXLB[164] = 0;
  isoBandNextYLB[6] = isoBandNextYLB[164] = -1;
  isoBandNextOLB[6] = isoBandNextOLB[164] = 1;
  isoBandNextXLT[6] = isoBandNextXLT[164] = 1;
  isoBandNextYLT[6] = isoBandNextYLT[164] = 0;
  isoBandNextOLT[6] = isoBandNextOLT[164] = 0;
  isoBandNextXBL[129] = isoBandNextXBL[41] = 0;
  isoBandNextYBL[129] = isoBandNextYBL[41] = 1;
  isoBandNextOBL[129] = isoBandNextOBL[41] = 1;
  isoBandNextXLB[129] = isoBandNextXLB[41] = 0;
  isoBandNextYLB[129] = isoBandNextYLB[41] = 1;
  isoBandNextOLB[129] = isoBandNextOLB[41] = 0;
  isoBandNextXTL[129] = isoBandNextXTL[41] = -1;
  isoBandNextYTL[129] = isoBandNextYTL[41] = 0;
  isoBandNextOTL[129] = isoBandNextOTL[41] = 0;
  isoBandNextXTR[129] = isoBandNextXTR[41] = 0;
  isoBandNextYTR[129] = isoBandNextYTR[41] = -1;
  isoBandNextOTR[129] = isoBandNextOTR[41] = 0;
  isoBandNextXBR[66] = isoBandNextXBR[104] = 0;
  isoBandNextYBR[66] = isoBandNextYBR[104] = 1;
  isoBandNextOBR[66] = isoBandNextOBR[104] = 0;
  isoBandNextXBL[66] = isoBandNextXBL[104] = -1;
  isoBandNextYBL[66] = isoBandNextYBL[104] = 0;
  isoBandNextOBL[66] = isoBandNextOBL[104] = 1;
  isoBandNextXLT[66] = isoBandNextXLT[104] = 0;
  isoBandNextYLT[66] = isoBandNextYLT[104] = -1;
  isoBandNextOLT[66] = isoBandNextOLT[104] = 0;
  isoBandNextXTL[66] = isoBandNextXTL[104] = 0;
  isoBandNextYTL[66] = isoBandNextYTL[104] = -1;
  isoBandNextOTL[66] = isoBandNextOTL[104] = 1;
  isoBandNextXRT[144] = isoBandNextXRT[26] = -1;
  isoBandNextYRT[144] = isoBandNextYRT[26] = 0;
  isoBandNextORT[144] = isoBandNextORT[26] = 0;
  isoBandNextXLB[144] = isoBandNextXLB[26] = 1;
  isoBandNextYLB[144] = isoBandNextYLB[26] = 0;
  isoBandNextOLB[144] = isoBandNextOLB[26] = 1;
  isoBandNextXLT[144] = isoBandNextXLT[26] = 0;
  isoBandNextYLT[144] = isoBandNextYLT[26] = 1;
  isoBandNextOLT[144] = isoBandNextOLT[26] = 1;
  isoBandNextXTR[144] = isoBandNextXTR[26] = -1;
  isoBandNextYTR[144] = isoBandNextYTR[26] = 0;
  isoBandNextOTR[144] = isoBandNextOTR[26] = 1;
  isoBandNextXRB[36] = isoBandNextXRB[134] = 0;
  isoBandNextYRB[36] = isoBandNextYRB[134] = 1;
  isoBandNextORB[36] = isoBandNextORB[134] = 1;
  isoBandNextXBR[36] = isoBandNextXBR[134] = 0;
  isoBandNextYBR[36] = isoBandNextYBR[134] = 1;
  isoBandNextOBR[36] = isoBandNextOBR[134] = 0;
  isoBandNextXTL[36] = isoBandNextXTL[134] = 0;
  isoBandNextYTL[36] = isoBandNextYTL[134] = -1;
  isoBandNextOTL[36] = isoBandNextOTL[134] = 1;
  isoBandNextXTR[36] = isoBandNextXTR[134] = 1;
  isoBandNextYTR[36] = isoBandNextYTR[134] = 0;
  isoBandNextOTR[36] = isoBandNextOTR[134] = 0;
  isoBandNextXRT[9] = isoBandNextXRT[161] = -1;
  isoBandNextYRT[9] = isoBandNextYRT[161] = 0;
  isoBandNextORT[9] = isoBandNextORT[161] = 0;
  isoBandNextXRB[9] = isoBandNextXRB[161] = 0;
  isoBandNextYRB[9] = isoBandNextYRB[161] = -1;
  isoBandNextORB[9] = isoBandNextORB[161] = 0;
  isoBandNextXBL[9] = isoBandNextXBL[161] = 1;
  isoBandNextYBL[9] = isoBandNextYBL[161] = 0;
  isoBandNextOBL[9] = isoBandNextOBL[161] = 0;
  isoBandNextXLB[9] = isoBandNextXLB[161] = 1;
  isoBandNextYLB[9] = isoBandNextYLB[161] = 0;
  isoBandNextOLB[9] = isoBandNextOLB[161] = 1;
  isoBandNextXRT[136] = 0;
  isoBandNextYRT[136] = 1;
  isoBandNextORT[136] = 1;
  isoBandNextXRB[136] = 0;
  isoBandNextYRB[136] = 1;
  isoBandNextORB[136] = 0;
  isoBandNextXBR[136] = -1;
  isoBandNextYBR[136] = 0;
  isoBandNextOBR[136] = 1;
  isoBandNextXBL[136] = -1;
  isoBandNextYBL[136] = 0;
  isoBandNextOBL[136] = 0;
  isoBandNextXLB[136] = 0;
  isoBandNextYLB[136] = -1;
  isoBandNextOLB[136] = 0;
  isoBandNextXLT[136] = 0;
  isoBandNextYLT[136] = -1;
  isoBandNextOLT[136] = 1;
  isoBandNextXTL[136] = 1;
  isoBandNextYTL[136] = 0;
  isoBandNextOTL[136] = 0;
  isoBandNextXTR[136] = 1;
  isoBandNextYTR[136] = 0;
  isoBandNextOTR[136] = 1;
  isoBandNextXRT[34] = 0;
  isoBandNextYRT[34] = -1;
  isoBandNextORT[34] = 0;
  isoBandNextXRB[34] = 0;
  isoBandNextYRB[34] = -1;
  isoBandNextORB[34] = 1;
  isoBandNextXBR[34] = 1;
  isoBandNextYBR[34] = 0;
  isoBandNextOBR[34] = 0;
  isoBandNextXBL[34] = 1;
  isoBandNextYBL[34] = 0;
  isoBandNextOBL[34] = 1;
  isoBandNextXLB[34] = 0;
  isoBandNextYLB[34] = 1;
  isoBandNextOLB[34] = 1;
  isoBandNextXLT[34] = 0;
  isoBandNextYLT[34] = 1;
  isoBandNextOLT[34] = 0;
  isoBandNextXTL[34] = -1;
  isoBandNextYTL[34] = 0;
  isoBandNextOTL[34] = 1;
  isoBandNextXTR[34] = -1;
  isoBandNextYTR[34] = 0;
  isoBandNextOTR[34] = 0;
  isoBandNextXRT[35] = 0;
  isoBandNextYRT[35] = 1;
  isoBandNextORT[35] = 1;
  isoBandNextXRB[35] = 0;
  isoBandNextYRB[35] = -1;
  isoBandNextORB[35] = 1;
  isoBandNextXBR[35] = 1;
  isoBandNextYBR[35] = 0;
  isoBandNextOBR[35] = 0;
  isoBandNextXBL[35] = -1;
  isoBandNextYBL[35] = 0;
  isoBandNextOBL[35] = 0;
  isoBandNextXLB[35] = 0;
  isoBandNextYLB[35] = -1;
  isoBandNextOLB[35] = 0;
  isoBandNextXLT[35] = 0;
  isoBandNextYLT[35] = 1;
  isoBandNextOLT[35] = 0;
  isoBandNextXTL[35] = -1;
  isoBandNextYTL[35] = 0;
  isoBandNextOTL[35] = 1;
  isoBandNextXTR[35] = 1;
  isoBandNextYTR[35] = 0;
  isoBandNextOTR[35] = 1;
  isoBandNextXRT[153] = 0;
  isoBandNextYRT[153] = 1;
  isoBandNextORT[153] = 1;
  isoBandNextXBL[153] = -1;
  isoBandNextYBL[153] = 0;
  isoBandNextOBL[153] = 0;
  isoBandNextXLB[153] = 0;
  isoBandNextYLB[153] = -1;
  isoBandNextOLB[153] = 0;
  isoBandNextXTR[153] = 1;
  isoBandNextYTR[153] = 0;
  isoBandNextOTR[153] = 1;
  isoBandNextXRB[102] = 0;
  isoBandNextYRB[102] = -1;
  isoBandNextORB[102] = 1;
  isoBandNextXBR[102] = 1;
  isoBandNextYBR[102] = 0;
  isoBandNextOBR[102] = 0;
  isoBandNextXLT[102] = 0;
  isoBandNextYLT[102] = 1;
  isoBandNextOLT[102] = 0;
  isoBandNextXTL[102] = -1;
  isoBandNextYTL[102] = 0;
  isoBandNextOTL[102] = 1;
  isoBandNextXRT[155] = 0;
  isoBandNextYRT[155] = -1;
  isoBandNextORT[155] = 0;
  isoBandNextXBL[155] = 1;
  isoBandNextYBL[155] = 0;
  isoBandNextOBL[155] = 1;
  isoBandNextXLB[155] = 0;
  isoBandNextYLB[155] = 1;
  isoBandNextOLB[155] = 1;
  isoBandNextXTR[155] = -1;
  isoBandNextYTR[155] = 0;
  isoBandNextOTR[155] = 0;
  isoBandNextXRB[103] = 0;
  isoBandNextYRB[103] = 1;
  isoBandNextORB[103] = 0;
  isoBandNextXBR[103] = -1;
  isoBandNextYBR[103] = 0;
  isoBandNextOBR[103] = 1;
  isoBandNextXLT[103] = 0;
  isoBandNextYLT[103] = -1;
  isoBandNextOLT[103] = 1;
  isoBandNextXTL[103] = 1;
  isoBandNextYTL[103] = 0;
  isoBandNextOTL[103] = 0;
  isoBandNextXRT[152] = 0;
  isoBandNextYRT[152] = 1;
  isoBandNextORT[152] = 1;
  isoBandNextXBR[152] = -1;
  isoBandNextYBR[152] = 0;
  isoBandNextOBR[152] = 1;
  isoBandNextXBL[152] = -1;
  isoBandNextYBL[152] = 0;
  isoBandNextOBL[152] = 0;
  isoBandNextXLB[152] = 0;
  isoBandNextYLB[152] = -1;
  isoBandNextOLB[152] = 0;
  isoBandNextXLT[152] = 0;
  isoBandNextYLT[152] = -1;
  isoBandNextOLT[152] = 1;
  isoBandNextXTR[152] = 1;
  isoBandNextYTR[152] = 0;
  isoBandNextOTR[152] = 1;
  isoBandNextXRT[156] = 0;
  isoBandNextYRT[156] = -1;
  isoBandNextORT[156] = 1;
  isoBandNextXBR[156] = 1;
  isoBandNextYBR[156] = 0;
  isoBandNextOBR[156] = 1;
  isoBandNextXBL[156] = -1;
  isoBandNextYBL[156] = 0;
  isoBandNextOBL[156] = 0;
  isoBandNextXLB[156] = 0;
  isoBandNextYLB[156] = -1;
  isoBandNextOLB[156] = 0;
  isoBandNextXLT[156] = 0;
  isoBandNextYLT[156] = 1;
  isoBandNextOLT[156] = 1;
  isoBandNextXTR[156] = -1;
  isoBandNextYTR[156] = 0;
  isoBandNextOTR[156] = 1;
  isoBandNextXRT[137] = 0;
  isoBandNextYRT[137] = 1;
  isoBandNextORT[137] = 1;
  isoBandNextXRB[137] = 0;
  isoBandNextYRB[137] = 1;
  isoBandNextORB[137] = 0;
  isoBandNextXBL[137] = -1;
  isoBandNextYBL[137] = 0;
  isoBandNextOBL[137] = 0;
  isoBandNextXLB[137] = 0;
  isoBandNextYLB[137] = -1;
  isoBandNextOLB[137] = 0;
  isoBandNextXTL[137] = 1;
  isoBandNextYTL[137] = 0;
  isoBandNextOTL[137] = 0;
  isoBandNextXTR[137] = 1;
  isoBandNextYTR[137] = 0;
  isoBandNextOTR[137] = 1;
  isoBandNextXRT[139] = 0;
  isoBandNextYRT[139] = 1;
  isoBandNextORT[139] = 1;
  isoBandNextXRB[139] = 0;
  isoBandNextYRB[139] = -1;
  isoBandNextORB[139] = 0;
  isoBandNextXBL[139] = 1;
  isoBandNextYBL[139] = 0;
  isoBandNextOBL[139] = 0;
  isoBandNextXLB[139] = 0;
  isoBandNextYLB[139] = 1;
  isoBandNextOLB[139] = 0;
  isoBandNextXTL[139] = -1;
  isoBandNextYTL[139] = 0;
  isoBandNextOTL[139] = 0;
  isoBandNextXTR[139] = 1;
  isoBandNextYTR[139] = 0;
  isoBandNextOTR[139] = 1;
  isoBandNextXRT[98] = 0;
  isoBandNextYRT[98] = -1;
  isoBandNextORT[98] = 0;
  isoBandNextXRB[98] = 0;
  isoBandNextYRB[98] = -1;
  isoBandNextORB[98] = 1;
  isoBandNextXBR[98] = 1;
  isoBandNextYBR[98] = 0;
  isoBandNextOBR[98] = 0;
  isoBandNextXBL[98] = 1;
  isoBandNextYBL[98] = 0;
  isoBandNextOBL[98] = 1;
  isoBandNextXLT[98] = 0;
  isoBandNextYLT[98] = 1;
  isoBandNextOLT[98] = 0;
  isoBandNextXTL[98] = -1;
  isoBandNextYTL[98] = 0;
  isoBandNextOTL[98] = 1;
  isoBandNextXRT[99] = 0;
  isoBandNextYRT[99] = 1;
  isoBandNextORT[99] = 0;
  isoBandNextXRB[99] = 0;
  isoBandNextYRB[99] = -1;
  isoBandNextORB[99] = 1;
  isoBandNextXBR[99] = 1;
  isoBandNextYBR[99] = 0;
  isoBandNextOBR[99] = 0;
  isoBandNextXBL[99] = -1;
  isoBandNextYBL[99] = 0;
  isoBandNextOBL[99] = 1;
  isoBandNextXLT[99] = 0;
  isoBandNextYLT[99] = -1;
  isoBandNextOLT[99] = 0;
  isoBandNextXTL[99] = 1;
  isoBandNextYTL[99] = 0;
  isoBandNextOTL[99] = 1;
  isoBandNextXRB[38] = 0;
  isoBandNextYRB[38] = -1;
  isoBandNextORB[38] = 1;
  isoBandNextXBR[38] = 1;
  isoBandNextYBR[38] = 0;
  isoBandNextOBR[38] = 0;
  isoBandNextXLB[38] = 0;
  isoBandNextYLB[38] = 1;
  isoBandNextOLB[38] = 1;
  isoBandNextXLT[38] = 0;
  isoBandNextYLT[38] = 1;
  isoBandNextOLT[38] = 0;
  isoBandNextXTL[38] = -1;
  isoBandNextYTL[38] = 0;
  isoBandNextOTL[38] = 1;
  isoBandNextXTR[38] = -1;
  isoBandNextYTR[38] = 0;
  isoBandNextOTR[38] = 0;
  isoBandNextXRB[39] = 0;
  isoBandNextYRB[39] = 1;
  isoBandNextORB[39] = 1;
  isoBandNextXBR[39] = -1;
  isoBandNextYBR[39] = 0;
  isoBandNextOBR[39] = 0;
  isoBandNextXLB[39] = 0;
  isoBandNextYLB[39] = -1;
  isoBandNextOLB[39] = 1;
  isoBandNextXLT[39] = 0;
  isoBandNextYLT[39] = 1;
  isoBandNextOLT[39] = 0;
  isoBandNextXTL[39] = -1;
  isoBandNextYTL[39] = 0;
  isoBandNextOTL[39] = 1;
  isoBandNextXTR[39] = 1;
  isoBandNextYTR[39] = 0;
  isoBandNextOTR[39] = 0;
  var p00 = function(cell) {
    return [
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom]
    ];
  };
  var p01 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0]
    ];
  };
  var p02 = function(cell) {
    return [
      [cell.topright, 1],
      [1, 1],
      [1, cell.righttop]
    ];
  };
  var p03 = function(cell) {
    return [
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p04 = function(cell) {
    return [
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop]
    ];
  };
  var p05 = function(cell) {
    return [
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [1, cell.righttop],
      [1, cell.rightbottom]
    ];
  };
  var p06 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p07 = function(cell) {
    return [
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p08 = function(cell) {
    return [
      [0, 0],
      [0, cell.leftbottom],
      [1, cell.rightbottom],
      [1, 0]
    ];
  };
  var p09 = function(cell) {
    return [
      [1, 0],
      [cell.bottomright, 0],
      [cell.topright, 1],
      [1, 1]
    ];
  };
  var p10 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [0, cell.lefttop],
      [0, 1]
    ];
  };
  var p11 = function(cell) {
    return [
      [cell.bottomleft, 0],
      [0, 0],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p12 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [0, cell.leftbottom],
      [0, cell.lefttop]
    ];
  };
  var p13 = function(cell) {
    return [
      [cell.topleft, 1],
      [cell.topright, 1],
      [cell.bottomright, 0],
      [cell.bottomleft, 0]
    ];
  };
  var p14 = function() {
    return [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0]
    ];
  };
  var p15 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [0, 0],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p16 = function(cell) {
    return [
      [cell.topright, 1],
      [1, 1],
      [1, 0],
      [0, 0],
      [0, cell.leftbottom]
    ];
  };
  var p17 = function(cell) {
    return [
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.lefttop],
      [0, 1],
      [1, 1]
    ];
  };
  var p18 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomleft, 0],
      [0, 0],
      [0, 1]
    ];
  };
  var p19 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p20 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [cell.topright, 1]
    ];
  };
  var p21 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop]
    ];
  };
  var p22 = function(cell) {
    return [
      [cell.topright, 1],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topleft, 1]
    ];
  };
  var p23 = function(cell) {
    return [
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p24 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topright, 1]
    ];
  };
  var p25 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p26 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom]
    ];
  };
  var p27 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p28 = function(cell) {
    return [
      [1, 1],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topright, 1]
    ];
  };
  var p29 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.lefttop],
      [0, 1]
    ];
  };
  var p30 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomleft, 0],
      [0, 0],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p31 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topright, 1]
    ];
  };
  var p32 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p33 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p34 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topright, 1]
    ];
  };
  var p35 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p36 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topright, 1]
    ];
  };
  var p37 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p38 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p39 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var isoBandEdgeRT = [];
  var isoBandEdgeRB = [];
  var isoBandEdgeBR = [];
  var isoBandEdgeBL = [];
  var isoBandEdgeLB = [];
  var isoBandEdgeLT = [];
  var isoBandEdgeTL = [];
  var isoBandEdgeTR = [];
  isoBandEdgeBL[1] = isoBandEdgeLB[1] = 18;
  isoBandEdgeBL[169] = isoBandEdgeLB[169] = 18;
  isoBandEdgeBR[4] = isoBandEdgeRB[4] = 12;
  isoBandEdgeBR[166] = isoBandEdgeRB[166] = 12;
  isoBandEdgeRT[16] = isoBandEdgeTR[16] = 4;
  isoBandEdgeRT[154] = isoBandEdgeTR[154] = 4;
  isoBandEdgeLT[64] = isoBandEdgeTL[64] = 22;
  isoBandEdgeLT[106] = isoBandEdgeTL[106] = 22;
  isoBandEdgeBR[2] = isoBandEdgeLT[2] = 17;
  isoBandEdgeBL[2] = isoBandEdgeLB[2] = 18;
  isoBandEdgeBR[168] = isoBandEdgeLT[168] = 17;
  isoBandEdgeBL[168] = isoBandEdgeLB[168] = 18;
  isoBandEdgeRT[8] = isoBandEdgeBL[8] = 9;
  isoBandEdgeRB[8] = isoBandEdgeBR[8] = 12;
  isoBandEdgeRT[162] = isoBandEdgeBL[162] = 9;
  isoBandEdgeRB[162] = isoBandEdgeBR[162] = 12;
  isoBandEdgeRT[32] = isoBandEdgeTR[32] = 4;
  isoBandEdgeRB[32] = isoBandEdgeTL[32] = 1;
  isoBandEdgeRT[138] = isoBandEdgeTR[138] = 4;
  isoBandEdgeRB[138] = isoBandEdgeTL[138] = 1;
  isoBandEdgeLB[128] = isoBandEdgeTR[128] = 21;
  isoBandEdgeLT[128] = isoBandEdgeTL[128] = 22;
  isoBandEdgeLB[42] = isoBandEdgeTR[42] = 21;
  isoBandEdgeLT[42] = isoBandEdgeTL[42] = 22;
  isoBandEdgeRB[5] = isoBandEdgeLB[5] = 14;
  isoBandEdgeRB[165] = isoBandEdgeLB[165] = 14;
  isoBandEdgeBR[20] = isoBandEdgeTR[20] = 6;
  isoBandEdgeBR[150] = isoBandEdgeTR[150] = 6;
  isoBandEdgeRT[80] = isoBandEdgeLT[80] = 11;
  isoBandEdgeRT[90] = isoBandEdgeLT[90] = 11;
  isoBandEdgeBL[65] = isoBandEdgeTL[65] = 3;
  isoBandEdgeBL[105] = isoBandEdgeTL[105] = 3;
  isoBandEdgeRT[160] = isoBandEdgeLT[160] = 11;
  isoBandEdgeRB[160] = isoBandEdgeLB[160] = 14;
  isoBandEdgeRT[10] = isoBandEdgeLT[10] = 11;
  isoBandEdgeRB[10] = isoBandEdgeLB[10] = 14;
  isoBandEdgeBR[130] = isoBandEdgeTR[130] = 6;
  isoBandEdgeBL[130] = isoBandEdgeTL[130] = 3;
  isoBandEdgeBR[40] = isoBandEdgeTR[40] = 6;
  isoBandEdgeBL[40] = isoBandEdgeTL[40] = 3;
  isoBandEdgeRB[101] = isoBandEdgeTL[101] = 1;
  isoBandEdgeRB[69] = isoBandEdgeTL[69] = 1;
  isoBandEdgeLB[149] = isoBandEdgeTR[149] = 21;
  isoBandEdgeLB[21] = isoBandEdgeTR[21] = 21;
  isoBandEdgeBR[86] = isoBandEdgeLT[86] = 17;
  isoBandEdgeBR[84] = isoBandEdgeLT[84] = 17;
  isoBandEdgeRT[89] = isoBandEdgeBL[89] = 9;
  isoBandEdgeRT[81] = isoBandEdgeBL[81] = 9;
  isoBandEdgeRT[96] = isoBandEdgeTL[96] = 0;
  isoBandEdgeRB[96] = isoBandEdgeLT[96] = 15;
  isoBandEdgeRT[74] = isoBandEdgeTL[74] = 0;
  isoBandEdgeRB[74] = isoBandEdgeLT[74] = 15;
  isoBandEdgeRT[24] = isoBandEdgeBR[24] = 8;
  isoBandEdgeBL[24] = isoBandEdgeTR[24] = 7;
  isoBandEdgeRT[146] = isoBandEdgeBR[146] = 8;
  isoBandEdgeBL[146] = isoBandEdgeTR[146] = 7;
  isoBandEdgeRB[6] = isoBandEdgeLT[6] = 15;
  isoBandEdgeBR[6] = isoBandEdgeLB[6] = 16;
  isoBandEdgeRB[164] = isoBandEdgeLT[164] = 15;
  isoBandEdgeBR[164] = isoBandEdgeLB[164] = 16;
  isoBandEdgeBL[129] = isoBandEdgeTR[129] = 7;
  isoBandEdgeLB[129] = isoBandEdgeTL[129] = 20;
  isoBandEdgeBL[41] = isoBandEdgeTR[41] = 7;
  isoBandEdgeLB[41] = isoBandEdgeTL[41] = 20;
  isoBandEdgeBR[66] = isoBandEdgeTL[66] = 2;
  isoBandEdgeBL[66] = isoBandEdgeLT[66] = 19;
  isoBandEdgeBR[104] = isoBandEdgeTL[104] = 2;
  isoBandEdgeBL[104] = isoBandEdgeLT[104] = 19;
  isoBandEdgeRT[144] = isoBandEdgeLB[144] = 10;
  isoBandEdgeLT[144] = isoBandEdgeTR[144] = 23;
  isoBandEdgeRT[26] = isoBandEdgeLB[26] = 10;
  isoBandEdgeLT[26] = isoBandEdgeTR[26] = 23;
  isoBandEdgeRB[36] = isoBandEdgeTR[36] = 5;
  isoBandEdgeBR[36] = isoBandEdgeTL[36] = 2;
  isoBandEdgeRB[134] = isoBandEdgeTR[134] = 5;
  isoBandEdgeBR[134] = isoBandEdgeTL[134] = 2;
  isoBandEdgeRT[9] = isoBandEdgeLB[9] = 10;
  isoBandEdgeRB[9] = isoBandEdgeBL[9] = 13;
  isoBandEdgeRT[161] = isoBandEdgeLB[161] = 10;
  isoBandEdgeRB[161] = isoBandEdgeBL[161] = 13;
  isoBandEdgeRB[37] = isoBandEdgeTR[37] = 5;
  isoBandEdgeLB[37] = isoBandEdgeTL[37] = 20;
  isoBandEdgeRB[133] = isoBandEdgeTR[133] = 5;
  isoBandEdgeLB[133] = isoBandEdgeTL[133] = 20;
  isoBandEdgeBR[148] = isoBandEdgeLB[148] = 16;
  isoBandEdgeLT[148] = isoBandEdgeTR[148] = 23;
  isoBandEdgeBR[22] = isoBandEdgeLB[22] = 16;
  isoBandEdgeLT[22] = isoBandEdgeTR[22] = 23;
  isoBandEdgeRT[82] = isoBandEdgeBR[82] = 8;
  isoBandEdgeBL[82] = isoBandEdgeLT[82] = 19;
  isoBandEdgeRT[88] = isoBandEdgeBR[88] = 8;
  isoBandEdgeBL[88] = isoBandEdgeLT[88] = 19;
  isoBandEdgeRT[73] = isoBandEdgeTL[73] = 0;
  isoBandEdgeRB[73] = isoBandEdgeBL[73] = 13;
  isoBandEdgeRT[97] = isoBandEdgeTL[97] = 0;
  isoBandEdgeRB[97] = isoBandEdgeBL[97] = 13;
  isoBandEdgeRT[145] = isoBandEdgeBL[145] = 9;
  isoBandEdgeLB[145] = isoBandEdgeTR[145] = 21;
  isoBandEdgeRT[25] = isoBandEdgeBL[25] = 9;
  isoBandEdgeLB[25] = isoBandEdgeTR[25] = 21;
  isoBandEdgeRB[70] = isoBandEdgeTL[70] = 1;
  isoBandEdgeBR[70] = isoBandEdgeLT[70] = 17;
  isoBandEdgeRB[100] = isoBandEdgeTL[100] = 1;
  isoBandEdgeBR[100] = isoBandEdgeLT[100] = 17;
  isoBandEdgeRT[34] = isoBandEdgeBL[34] = 9;
  isoBandEdgeRB[34] = isoBandEdgeBR[34] = 12;
  isoBandEdgeLB[34] = isoBandEdgeTR[34] = 21;
  isoBandEdgeLT[34] = isoBandEdgeTL[34] = 22;
  isoBandEdgeRT[136] = isoBandEdgeTR[136] = 4;
  isoBandEdgeRB[136] = isoBandEdgeTL[136] = 1;
  isoBandEdgeBR[136] = isoBandEdgeLT[136] = 17;
  isoBandEdgeBL[136] = isoBandEdgeLB[136] = 18;
  isoBandEdgeRT[35] = isoBandEdgeTR[35] = 4;
  isoBandEdgeRB[35] = isoBandEdgeBR[35] = 12;
  isoBandEdgeBL[35] = isoBandEdgeLB[35] = 18;
  isoBandEdgeLT[35] = isoBandEdgeTL[35] = 22;
  isoBandEdgeRT[153] = isoBandEdgeTR[153] = 4;
  isoBandEdgeBL[153] = isoBandEdgeLB[153] = 18;
  isoBandEdgeRB[102] = isoBandEdgeBR[102] = 12;
  isoBandEdgeLT[102] = isoBandEdgeTL[102] = 22;
  isoBandEdgeRT[155] = isoBandEdgeBL[155] = 9;
  isoBandEdgeLB[155] = isoBandEdgeTR[155] = 23;
  isoBandEdgeRB[103] = isoBandEdgeTL[103] = 1;
  isoBandEdgeBR[103] = isoBandEdgeLT[103] = 17;
  isoBandEdgeRT[152] = isoBandEdgeTR[152] = 4;
  isoBandEdgeBR[152] = isoBandEdgeLT[152] = 17;
  isoBandEdgeBL[152] = isoBandEdgeLB[152] = 18;
  isoBandEdgeRT[156] = isoBandEdgeBR[156] = 8;
  isoBandEdgeBL[156] = isoBandEdgeLB[156] = 18;
  isoBandEdgeLT[156] = isoBandEdgeTR[156] = 23;
  isoBandEdgeRT[137] = isoBandEdgeTR[137] = 4;
  isoBandEdgeRB[137] = isoBandEdgeTL[137] = 1;
  isoBandEdgeBL[137] = isoBandEdgeLB[137] = 18;
  isoBandEdgeRT[139] = isoBandEdgeTR[139] = 4;
  isoBandEdgeRB[139] = isoBandEdgeBL[139] = 13;
  isoBandEdgeLB[139] = isoBandEdgeTL[139] = 20;
  isoBandEdgeRT[98] = isoBandEdgeBL[98] = 9;
  isoBandEdgeRB[98] = isoBandEdgeBR[98] = 12;
  isoBandEdgeLT[98] = isoBandEdgeTL[98] = 22;
  isoBandEdgeRT[99] = isoBandEdgeTL[99] = 0;
  isoBandEdgeRB[99] = isoBandEdgeBR[99] = 12;
  isoBandEdgeBL[99] = isoBandEdgeLT[99] = 19;
  isoBandEdgeRB[38] = isoBandEdgeBR[38] = 12;
  isoBandEdgeLB[38] = isoBandEdgeTR[38] = 21;
  isoBandEdgeLT[38] = isoBandEdgeTL[38] = 22;
  isoBandEdgeRB[39] = isoBandEdgeTR[39] = 5;
  isoBandEdgeBR[39] = isoBandEdgeLB[39] = 16;
  isoBandEdgeLT[39] = isoBandEdgeTL[39] = 22;
  var polygon_table = [];
  polygon_table[1] = polygon_table[169] = p00;
  polygon_table[4] = polygon_table[166] = p01;
  polygon_table[16] = polygon_table[154] = p02;
  polygon_table[64] = polygon_table[106] = p03;
  polygon_table[168] = polygon_table[2] = p04;
  polygon_table[162] = polygon_table[8] = p05;
  polygon_table[138] = polygon_table[32] = p06;
  polygon_table[42] = polygon_table[128] = p07;
  polygon_table[5] = polygon_table[165] = p08;
  polygon_table[20] = polygon_table[150] = p09;
  polygon_table[80] = polygon_table[90] = p10;
  polygon_table[65] = polygon_table[105] = p11;
  polygon_table[160] = polygon_table[10] = p12;
  polygon_table[130] = polygon_table[40] = p13;
  polygon_table[85] = p14;
  polygon_table[101] = polygon_table[69] = p15;
  polygon_table[149] = polygon_table[21] = p16;
  polygon_table[86] = polygon_table[84] = p17;
  polygon_table[89] = polygon_table[81] = p18;
  polygon_table[96] = polygon_table[74] = p19;
  polygon_table[24] = polygon_table[146] = p20;
  polygon_table[6] = polygon_table[164] = p21;
  polygon_table[129] = polygon_table[41] = p22;
  polygon_table[66] = polygon_table[104] = p23;
  polygon_table[144] = polygon_table[26] = p24;
  polygon_table[36] = polygon_table[134] = p25;
  polygon_table[9] = polygon_table[161] = p26;
  polygon_table[37] = polygon_table[133] = p27;
  polygon_table[148] = polygon_table[22] = p28;
  polygon_table[82] = polygon_table[88] = p29;
  polygon_table[73] = polygon_table[97] = p30;
  polygon_table[145] = polygon_table[25] = p31;
  polygon_table[70] = polygon_table[100] = p32;
  polygon_table[34] = function(c) {
    return [p07(c), p05(c)];
  };
  polygon_table[35] = p33;
  polygon_table[136] = function(c) {
    return [p06(c), p04(c)];
  };
  polygon_table[153] = function(c) {
    return [p02(c), p00(c)];
  };
  polygon_table[102] = function(c) {
    return [p01(c), p03(c)];
  };
  polygon_table[155] = p34;
  polygon_table[103] = p35;
  polygon_table[152] = function(c) {
    return [p02(c), p04(c)];
  };
  polygon_table[156] = p36;
  polygon_table[137] = function(c) {
    return [p06(c), p00(c)];
  };
  polygon_table[139] = p37;
  polygon_table[98] = function(c) {
    return [p05(c), p03(c)];
  };
  polygon_table[99] = p38;
  polygon_table[38] = function(c) {
    return [p01(c), p07(c)];
  };
  polygon_table[39] = p39;

  // node_modules/@turf/polygonize/dist/es/lib/util.js
  function mathSign(x2) {
    return (x2 > 0) - (x2 < 0) || +x2;
  }
  function orientationIndex(p1, p2, q) {
    var dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1], dx2 = q[0] - p2[0], dy2 = q[1] - p2[1];
    return mathSign(dx1 * dy2 - dx2 * dy1);
  }
  function envelopeIsEqual(env1, env2) {
    var envX1 = env1.geometry.coordinates[0].map(function(c) {
      return c[0];
    }), envY1 = env1.geometry.coordinates[0].map(function(c) {
      return c[1];
    }), envX2 = env2.geometry.coordinates[0].map(function(c) {
      return c[0];
    }), envY2 = env2.geometry.coordinates[0].map(function(c) {
      return c[1];
    });
    return Math.max.apply(null, envX1) === Math.max.apply(null, envX2) && Math.max.apply(null, envY1) === Math.max.apply(null, envY2) && Math.min.apply(null, envX1) === Math.min.apply(null, envX2) && Math.min.apply(null, envY1) === Math.min.apply(null, envY2);
  }
  function envelopeContains(self2, env) {
    return env.geometry.coordinates[0].every(function(c) {
      return booleanPointInPolygon(point(c), self2);
    });
  }
  function coordinatesEqual(coord1, coord2) {
    return coord1[0] === coord2[0] && coord1[1] === coord2[1];
  }

  // node_modules/@turf/polygonize/dist/es/lib/Node.js
  var Node = function() {
    function Node2(coordinates) {
      this.id = Node2.buildId(coordinates);
      this.coordinates = coordinates;
      this.innerEdges = [];
      this.outerEdges = [];
      this.outerEdgesSorted = false;
    }
    Node2.buildId = function(coordinates) {
      return coordinates.join(",");
    };
    Node2.prototype.removeInnerEdge = function(edge) {
      this.innerEdges = this.innerEdges.filter(function(e) {
        return e.from.id !== edge.from.id;
      });
    };
    Node2.prototype.removeOuterEdge = function(edge) {
      this.outerEdges = this.outerEdges.filter(function(e) {
        return e.to.id !== edge.to.id;
      });
    };
    Node2.prototype.addOuterEdge = function(edge) {
      this.outerEdges.push(edge);
      this.outerEdgesSorted = false;
    };
    Node2.prototype.sortOuterEdges = function() {
      var _this = this;
      if (!this.outerEdgesSorted) {
        this.outerEdges.sort(function(a, b) {
          var aNode = a.to, bNode = b.to;
          if (aNode.coordinates[0] - _this.coordinates[0] >= 0 && bNode.coordinates[0] - _this.coordinates[0] < 0)
            return 1;
          if (aNode.coordinates[0] - _this.coordinates[0] < 0 && bNode.coordinates[0] - _this.coordinates[0] >= 0)
            return -1;
          if (aNode.coordinates[0] - _this.coordinates[0] === 0 && bNode.coordinates[0] - _this.coordinates[0] === 0) {
            if (aNode.coordinates[1] - _this.coordinates[1] >= 0 || bNode.coordinates[1] - _this.coordinates[1] >= 0)
              return aNode.coordinates[1] - bNode.coordinates[1];
            return bNode.coordinates[1] - aNode.coordinates[1];
          }
          var det = orientationIndex(_this.coordinates, aNode.coordinates, bNode.coordinates);
          if (det < 0)
            return 1;
          if (det > 0)
            return -1;
          var d1 = Math.pow(aNode.coordinates[0] - _this.coordinates[0], 2) + Math.pow(aNode.coordinates[1] - _this.coordinates[1], 2), d2 = Math.pow(bNode.coordinates[0] - _this.coordinates[0], 2) + Math.pow(bNode.coordinates[1] - _this.coordinates[1], 2);
          return d1 - d2;
        });
        this.outerEdgesSorted = true;
      }
    };
    Node2.prototype.getOuterEdges = function() {
      this.sortOuterEdges();
      return this.outerEdges;
    };
    Node2.prototype.getOuterEdge = function(i) {
      this.sortOuterEdges();
      return this.outerEdges[i];
    };
    Node2.prototype.addInnerEdge = function(edge) {
      this.innerEdges.push(edge);
    };
    return Node2;
  }();
  var Node_default = Node;

  // node_modules/@turf/polygonize/dist/es/lib/Edge.js
  var Edge = function() {
    function Edge2(from, to) {
      this.from = from;
      this.to = to;
      this.next = void 0;
      this.label = void 0;
      this.symetric = void 0;
      this.ring = void 0;
      this.from.addOuterEdge(this);
      this.to.addInnerEdge(this);
    }
    Edge2.prototype.getSymetric = function() {
      if (!this.symetric) {
        this.symetric = new Edge2(this.to, this.from);
        this.symetric.symetric = this;
      }
      return this.symetric;
    };
    Edge2.prototype.deleteEdge = function() {
      this.from.removeOuterEdge(this);
      this.to.removeInnerEdge(this);
    };
    Edge2.prototype.isEqual = function(edge) {
      return this.from.id === edge.from.id && this.to.id === edge.to.id;
    };
    Edge2.prototype.toString = function() {
      return "Edge { " + this.from.id + " -> " + this.to.id + " }";
    };
    Edge2.prototype.toLineString = function() {
      return lineString([this.from.coordinates, this.to.coordinates]);
    };
    Edge2.prototype.compareTo = function(edge) {
      return orientationIndex(edge.from.coordinates, edge.to.coordinates, this.to.coordinates);
    };
    return Edge2;
  }();
  var Edge_default = Edge;

  // node_modules/@turf/polygonize/dist/es/lib/EdgeRing.js
  var EdgeRing = function() {
    function EdgeRing2() {
      this.edges = [];
      this.polygon = void 0;
      this.envelope = void 0;
    }
    EdgeRing2.prototype.push = function(edge) {
      this.edges.push(edge);
      this.polygon = this.envelope = void 0;
    };
    EdgeRing2.prototype.get = function(i) {
      return this.edges[i];
    };
    Object.defineProperty(EdgeRing2.prototype, "length", {
      get: function() {
        return this.edges.length;
      },
      enumerable: true,
      configurable: true
    });
    EdgeRing2.prototype.forEach = function(f) {
      this.edges.forEach(f);
    };
    EdgeRing2.prototype.map = function(f) {
      return this.edges.map(f);
    };
    EdgeRing2.prototype.some = function(f) {
      return this.edges.some(f);
    };
    EdgeRing2.prototype.isValid = function() {
      return true;
    };
    EdgeRing2.prototype.isHole = function() {
      var _this = this;
      var hiIndex = this.edges.reduce(function(high, edge, i) {
        if (edge.from.coordinates[1] > _this.edges[high].from.coordinates[1])
          high = i;
        return high;
      }, 0), iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1, iNext = (hiIndex + 1) % this.length, disc = orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);
      if (disc === 0)
        return this.edges[iPrev].from.coordinates[0] > this.edges[iNext].from.coordinates[0];
      return disc > 0;
    };
    EdgeRing2.prototype.toMultiPoint = function() {
      return multiPoint(this.edges.map(function(edge) {
        return edge.from.coordinates;
      }));
    };
    EdgeRing2.prototype.toPolygon = function() {
      if (this.polygon)
        return this.polygon;
      var coordinates = this.edges.map(function(edge) {
        return edge.from.coordinates;
      });
      coordinates.push(this.edges[0].from.coordinates);
      return this.polygon = polygon([coordinates]);
    };
    EdgeRing2.prototype.getEnvelope = function() {
      if (this.envelope)
        return this.envelope;
      return this.envelope = es_default5(this.toPolygon());
    };
    EdgeRing2.findEdgeRingContaining = function(testEdgeRing, shellList) {
      var testEnvelope = testEdgeRing.getEnvelope();
      var minEnvelope, minShell;
      shellList.forEach(function(shell) {
        var tryEnvelope = shell.getEnvelope();
        if (minShell)
          minEnvelope = minShell.getEnvelope();
        if (envelopeIsEqual(tryEnvelope, testEnvelope))
          return;
        if (envelopeContains(tryEnvelope, testEnvelope)) {
          var testEdgeRingCoordinates = testEdgeRing.map(function(edge) {
            return edge.from.coordinates;
          });
          var testPoint = void 0;
          var _loop_1 = function(pt2) {
            if (!shell.some(function(edge) {
              return coordinatesEqual(pt2, edge.from.coordinates);
            })) {
              testPoint = pt2;
            }
          };
          for (var _i = 0, testEdgeRingCoordinates_1 = testEdgeRingCoordinates; _i < testEdgeRingCoordinates_1.length; _i++) {
            var pt = testEdgeRingCoordinates_1[_i];
            _loop_1(pt);
          }
          if (testPoint && shell.inside(point(testPoint))) {
            if (!minShell || envelopeContains(minEnvelope, tryEnvelope))
              minShell = shell;
          }
        }
      });
      return minShell;
    };
    EdgeRing2.prototype.inside = function(pt) {
      return booleanPointInPolygon(pt, this.toPolygon());
    };
    return EdgeRing2;
  }();
  var EdgeRing_default = EdgeRing;

  // node_modules/@turf/polygonize/dist/es/lib/Graph.js
  function validateGeoJson(geoJson) {
    if (!geoJson)
      throw new Error("No geojson passed");
    if (geoJson.type !== "FeatureCollection" && geoJson.type !== "GeometryCollection" && geoJson.type !== "MultiLineString" && geoJson.type !== "LineString" && geoJson.type !== "Feature")
      throw new Error("Invalid input type '" + geoJson.type + "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature");
  }
  var Graph = function() {
    function Graph3() {
      this.edges = [];
      this.nodes = {};
    }
    Graph3.fromGeoJson = function(geoJson) {
      validateGeoJson(geoJson);
      var graph = new Graph3();
      flattenEach(geoJson, function(feature2) {
        featureOf(feature2, "LineString", "Graph::fromGeoJson");
        coordReduce(feature2, function(prev, cur) {
          if (prev) {
            var start = graph.getNode(prev), end = graph.getNode(cur);
            graph.addEdge(start, end);
          }
          return cur;
        });
      });
      return graph;
    };
    Graph3.prototype.getNode = function(coordinates) {
      var id = Node_default.buildId(coordinates);
      var node = this.nodes[id];
      if (!node)
        node = this.nodes[id] = new Node_default(coordinates);
      return node;
    };
    Graph3.prototype.addEdge = function(from, to) {
      var edge = new Edge_default(from, to), symetricEdge = edge.getSymetric();
      this.edges.push(edge);
      this.edges.push(symetricEdge);
    };
    Graph3.prototype.deleteDangles = function() {
      var _this = this;
      Object.keys(this.nodes).map(function(id) {
        return _this.nodes[id];
      }).forEach(function(node) {
        return _this._removeIfDangle(node);
      });
    };
    Graph3.prototype._removeIfDangle = function(node) {
      var _this = this;
      if (node.innerEdges.length <= 1) {
        var outerNodes = node.getOuterEdges().map(function(e) {
          return e.to;
        });
        this.removeNode(node);
        outerNodes.forEach(function(n) {
          return _this._removeIfDangle(n);
        });
      }
    };
    Graph3.prototype.deleteCutEdges = function() {
      var _this = this;
      this._computeNextCWEdges();
      this._findLabeledEdgeRings();
      this.edges.forEach(function(edge) {
        if (edge.label === edge.symetric.label) {
          _this.removeEdge(edge.symetric);
          _this.removeEdge(edge);
        }
      });
    };
    Graph3.prototype._computeNextCWEdges = function(node) {
      var _this = this;
      if (typeof node === "undefined") {
        Object.keys(this.nodes).forEach(function(id) {
          return _this._computeNextCWEdges(_this.nodes[id]);
        });
      } else {
        node.getOuterEdges().forEach(function(edge, i) {
          node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;
        });
      }
    };
    Graph3.prototype._computeNextCCWEdges = function(node, label) {
      var edges2 = node.getOuterEdges();
      var firstOutDE, prevInDE;
      for (var i = edges2.length - 1; i >= 0; --i) {
        var de = edges2[i], sym = de.symetric, outDE = void 0, inDE = void 0;
        if (de.label === label)
          outDE = de;
        if (sym.label === label)
          inDE = sym;
        if (!outDE || !inDE)
          continue;
        if (inDE)
          prevInDE = inDE;
        if (outDE) {
          if (prevInDE) {
            prevInDE.next = outDE;
            prevInDE = void 0;
          }
          if (!firstOutDE)
            firstOutDE = outDE;
        }
      }
      if (prevInDE)
        prevInDE.next = firstOutDE;
    };
    Graph3.prototype._findLabeledEdgeRings = function() {
      var edgeRingStarts = [];
      var label = 0;
      this.edges.forEach(function(edge) {
        if (edge.label >= 0)
          return;
        edgeRingStarts.push(edge);
        var e = edge;
        do {
          e.label = label;
          e = e.next;
        } while (!edge.isEqual(e));
        label++;
      });
      return edgeRingStarts;
    };
    Graph3.prototype.getEdgeRings = function() {
      var _this = this;
      this._computeNextCWEdges();
      this.edges.forEach(function(edge) {
        edge.label = void 0;
      });
      this._findLabeledEdgeRings().forEach(function(edge) {
        _this._findIntersectionNodes(edge).forEach(function(node) {
          _this._computeNextCCWEdges(node, edge.label);
        });
      });
      var edgeRingList = [];
      this.edges.forEach(function(edge) {
        if (edge.ring)
          return;
        edgeRingList.push(_this._findEdgeRing(edge));
      });
      return edgeRingList;
    };
    Graph3.prototype._findIntersectionNodes = function(startEdge) {
      var intersectionNodes = [];
      var edge = startEdge;
      var _loop_1 = function() {
        var degree = 0;
        edge.from.getOuterEdges().forEach(function(e) {
          if (e.label === startEdge.label)
            ++degree;
        });
        if (degree > 1)
          intersectionNodes.push(edge.from);
        edge = edge.next;
      };
      do {
        _loop_1();
      } while (!startEdge.isEqual(edge));
      return intersectionNodes;
    };
    Graph3.prototype._findEdgeRing = function(startEdge) {
      var edge = startEdge;
      var edgeRing = new EdgeRing_default();
      do {
        edgeRing.push(edge);
        edge.ring = edgeRing;
        edge = edge.next;
      } while (!startEdge.isEqual(edge));
      return edgeRing;
    };
    Graph3.prototype.removeNode = function(node) {
      var _this = this;
      node.getOuterEdges().forEach(function(edge) {
        return _this.removeEdge(edge);
      });
      node.innerEdges.forEach(function(edge) {
        return _this.removeEdge(edge);
      });
      delete this.nodes[node.id];
    };
    Graph3.prototype.removeEdge = function(edge) {
      this.edges = this.edges.filter(function(e) {
        return !e.isEqual(edge);
      });
      edge.deleteEdge();
    };
    return Graph3;
  }();

  // node_modules/@turf/boolean-overlap/dist/es/index.js
  var import_geojson_equality = __toESM(require_geojson_equality(), 1);

  // node_modules/@turf/boolean-equal/dist/es/index.js
  var import_geojson_equality2 = __toESM(require_geojson_equality(), 1);

  // node_modules/@turf/clusters-dbscan/dist/es/index.js
  var import_density_clustering = __toESM(require_lib(), 1);

  // node_modules/@turf/clusters-kmeans/dist/es/index.js
  var import_skmeans = __toESM(require_main(), 1);

  // node_modules/@turf/shortest-path/dist/es/index.js
  function pathTo(node) {
    var curr = node, path = [];
    while (curr.parent) {
      path.unshift(curr);
      curr = curr.parent;
    }
    return path;
  }
  function getHeap() {
    return new BinaryHeap(function(node) {
      return node.f;
    });
  }
  var astar = {
    search: function(graph, start, end, options) {
      graph.cleanDirty();
      options = options || {};
      var heuristic = options.heuristic || astar.heuristics.manhattan, closest = options.closest || false;
      var openHeap = getHeap(), closestNode = start;
      start.h = heuristic(start, end);
      openHeap.push(start);
      while (openHeap.size() > 0) {
        var currentNode = openHeap.pop();
        if (currentNode === end) {
          return pathTo(currentNode);
        }
        currentNode.closed = true;
        var neighbors = graph.neighbors(currentNode);
        for (var i = 0, il = neighbors.length; i < il; ++i) {
          var neighbor = neighbors[i];
          if (neighbor.closed || neighbor.isWall()) {
            continue;
          }
          var gScore = currentNode.g + neighbor.getCost(currentNode), beenVisited = neighbor.visited;
          if (!beenVisited || gScore < neighbor.g) {
            neighbor.visited = true;
            neighbor.parent = currentNode;
            neighbor.h = neighbor.h || heuristic(neighbor, end);
            neighbor.g = gScore;
            neighbor.f = neighbor.g + neighbor.h;
            graph.markDirty(neighbor);
            if (closest) {
              if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {
                closestNode = neighbor;
              }
            }
            if (!beenVisited) {
              openHeap.push(neighbor);
            } else {
              openHeap.rescoreElement(neighbor);
            }
          }
        }
      }
      if (closest) {
        return pathTo(closestNode);
      }
      return [];
    },
    heuristics: {
      manhattan: function(pos0, pos1) {
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return d1 + d2;
      },
      diagonal: function(pos0, pos1) {
        var D = 1;
        var D2 = Math.sqrt(2);
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
      }
    },
    cleanNode: function(node) {
      node.f = 0;
      node.g = 0;
      node.h = 0;
      node.visited = false;
      node.closed = false;
      node.parent = null;
    }
  };
  function Graph2(gridIn, options) {
    options = options || {};
    this.nodes = [];
    this.diagonal = !!options.diagonal;
    this.grid = [];
    for (var x2 = 0; x2 < gridIn.length; x2++) {
      this.grid[x2] = [];
      for (var y2 = 0, row = gridIn[x2]; y2 < row.length; y2++) {
        var node = new GridNode(x2, y2, row[y2]);
        this.grid[x2][y2] = node;
        this.nodes.push(node);
      }
    }
    this.init();
  }
  Graph2.prototype.init = function() {
    this.dirtyNodes = [];
    for (var i = 0; i < this.nodes.length; i++) {
      astar.cleanNode(this.nodes[i]);
    }
  };
  Graph2.prototype.cleanDirty = function() {
    for (var i = 0; i < this.dirtyNodes.length; i++) {
      astar.cleanNode(this.dirtyNodes[i]);
    }
    this.dirtyNodes = [];
  };
  Graph2.prototype.markDirty = function(node) {
    this.dirtyNodes.push(node);
  };
  Graph2.prototype.neighbors = function(node) {
    var ret = [], x2 = node.x, y2 = node.y, grid = this.grid;
    if (grid[x2 - 1] && grid[x2 - 1][y2]) {
      ret.push(grid[x2 - 1][y2]);
    }
    if (grid[x2 + 1] && grid[x2 + 1][y2]) {
      ret.push(grid[x2 + 1][y2]);
    }
    if (grid[x2] && grid[x2][y2 - 1]) {
      ret.push(grid[x2][y2 - 1]);
    }
    if (grid[x2] && grid[x2][y2 + 1]) {
      ret.push(grid[x2][y2 + 1]);
    }
    if (this.diagonal) {
      if (grid[x2 - 1] && grid[x2 - 1][y2 - 1]) {
        ret.push(grid[x2 - 1][y2 - 1]);
      }
      if (grid[x2 + 1] && grid[x2 + 1][y2 - 1]) {
        ret.push(grid[x2 + 1][y2 - 1]);
      }
      if (grid[x2 - 1] && grid[x2 - 1][y2 + 1]) {
        ret.push(grid[x2 - 1][y2 + 1]);
      }
      if (grid[x2 + 1] && grid[x2 + 1][y2 + 1]) {
        ret.push(grid[x2 + 1][y2 + 1]);
      }
    }
    return ret;
  };
  Graph2.prototype.toString = function() {
    var graphString = [], nodes = this.grid, rowDebug, row, y2, l;
    for (var x2 = 0, len = nodes.length; x2 < len; x2++) {
      rowDebug = [];
      row = nodes[x2];
      for (y2 = 0, l = row.length; y2 < l; y2++) {
        rowDebug.push(row[y2].weight);
      }
      graphString.push(rowDebug.join(" "));
    }
    return graphString.join("\n");
  };
  function GridNode(x2, y2, weight) {
    this.x = x2;
    this.y = y2;
    this.weight = weight;
  }
  GridNode.prototype.toString = function() {
    return "[" + this.x + " " + this.y + "]";
  };
  GridNode.prototype.getCost = function(fromNeighbor) {
    if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
      return this.weight * 1.41421;
    }
    return this.weight;
  };
  GridNode.prototype.isWall = function() {
    return this.weight === 0;
  };
  function BinaryHeap(scoreFunction) {
    this.content = [];
    this.scoreFunction = scoreFunction;
  }
  BinaryHeap.prototype = {
    push: function(element) {
      this.content.push(element);
      this.sinkDown(this.content.length - 1);
    },
    pop: function() {
      var result = this.content[0];
      var end = this.content.pop();
      if (this.content.length > 0) {
        this.content[0] = end;
        this.bubbleUp(0);
      }
      return result;
    },
    remove: function(node) {
      var i = this.content.indexOf(node);
      var end = this.content.pop();
      if (i !== this.content.length - 1) {
        this.content[i] = end;
        if (this.scoreFunction(end) < this.scoreFunction(node)) {
          this.sinkDown(i);
        } else {
          this.bubbleUp(i);
        }
      }
    },
    size: function() {
      return this.content.length;
    },
    rescoreElement: function(node) {
      this.sinkDown(this.content.indexOf(node));
    },
    sinkDown: function(n) {
      var element = this.content[n];
      while (n > 0) {
        var parentN = (n + 1 >> 1) - 1, parent = this.content[parentN];
        if (this.scoreFunction(element) < this.scoreFunction(parent)) {
          this.content[parentN] = element;
          this.content[n] = parent;
          n = parentN;
        } else {
          break;
        }
      }
    },
    bubbleUp: function(n) {
      var length2 = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);
      while (true) {
        var child2N = n + 1 << 1, child1N = child2N - 1;
        var swap = null, child1Score;
        if (child1N < length2) {
          var child1 = this.content[child1N];
          child1Score = this.scoreFunction(child1);
          if (child1Score < elemScore) {
            swap = child1N;
          }
        }
        if (child2N < length2) {
          var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);
          if (child2Score < (swap === null ? elemScore : child1Score)) {
            swap = child2N;
          }
        }
        if (swap !== null) {
          this.content[n] = this.content[swap];
          this.content[swap] = element;
          n = swap;
        } else {
          break;
        }
      }
    }
  };

  // node_modules/d3-voronoi/src/RedBlackTree.js
  function RedBlackTree() {
    this._ = null;
  }
  function RedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  RedBlackTree.prototype = {
    constructor: RedBlackTree,
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N)
          after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L)
            after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = RedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              RedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            RedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              RedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            RedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N)
        node.N.P = node.P;
      if (node.P)
        node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left)
        next = right;
      else if (!right)
        next = left;
      else
        next = RedBlackFirst(right);
      if (parent) {
        if (parent.L === node)
          parent.L = next;
        else
          parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node)
        node.U = parent;
      if (red)
        return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._)
          break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            RedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              RedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            RedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            RedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              RedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            RedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node)
        node.C = false;
    }
  };
  function RedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p)
        parent.L = q;
      else
        parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R)
      p.R.U = p;
    q.L = p;
  }
  function RedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p)
        parent.L = q;
      else
        parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L)
      p.L.U = p;
    q.R = p;
  }
  function RedBlackFirst(node) {
    while (node.L)
      node = node.L;
    return node;
  }
  var RedBlackTree_default = RedBlackTree;

  // node_modules/d3-voronoi/src/Edge.js
  function createEdge(left, right, v0, v1) {
    var edge = [null, null], index = edges.push(edge) - 1;
    edge.left = left;
    edge.right = right;
    if (v0)
      setEdgeEnd(edge, left, right, v0);
    if (v1)
      setEdgeEnd(edge, right, left, v1);
    cells[left.index].halfedges.push(index);
    cells[right.index].halfedges.push(index);
    return edge;
  }
  function createBorderEdge(left, v0, v1) {
    var edge = [v0, v1];
    edge.left = left;
    return edge;
  }
  function setEdgeEnd(edge, left, right, vertex) {
    if (!edge[0] && !edge[1]) {
      edge[0] = vertex;
      edge.left = left;
      edge.right = right;
    } else if (edge.left === right) {
      edge[1] = vertex;
    } else {
      edge[0] = vertex;
    }
  }
  function clipEdge(edge, x02, y0, x12, y1) {
    var a = edge[0], b = edge[1], ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
    r = x02 - ax;
    if (!dx && r > 0)
      return;
    r /= dx;
    if (dx < 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    } else if (dx > 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    }
    r = x12 - ax;
    if (!dx && r < 0)
      return;
    r /= dx;
    if (dx < 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    } else if (dx > 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    }
    r = y0 - ay;
    if (!dy && r > 0)
      return;
    r /= dy;
    if (dy < 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    } else if (dy > 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    }
    r = y1 - ay;
    if (!dy && r < 0)
      return;
    r /= dy;
    if (dy < 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    } else if (dy > 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    }
    if (!(t0 > 0) && !(t1 < 1))
      return true;
    if (t0 > 0)
      edge[0] = [ax + t0 * dx, ay + t0 * dy];
    if (t1 < 1)
      edge[1] = [ax + t1 * dx, ay + t1 * dy];
    return true;
  }
  function connectEdge(edge, x02, y0, x12, y1) {
    var v1 = edge[1];
    if (v1)
      return true;
    var v0 = edge[0], left = edge.left, right = edge.right, lx = left[0], ly = left[1], rx = right[0], ry = right[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x02 || fx >= x12)
        return;
      if (lx > rx) {
        if (!v0)
          v0 = [fx, y0];
        else if (v0[1] >= y1)
          return;
        v1 = [fx, y1];
      } else {
        if (!v0)
          v0 = [fx, y1];
        else if (v0[1] < y0)
          return;
        v1 = [fx, y0];
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!v0)
            v0 = [(y0 - fb) / fm, y0];
          else if (v0[1] >= y1)
            return;
          v1 = [(y1 - fb) / fm, y1];
        } else {
          if (!v0)
            v0 = [(y1 - fb) / fm, y1];
          else if (v0[1] < y0)
            return;
          v1 = [(y0 - fb) / fm, y0];
        }
      } else {
        if (ly < ry) {
          if (!v0)
            v0 = [x02, fm * x02 + fb];
          else if (v0[0] >= x12)
            return;
          v1 = [x12, fm * x12 + fb];
        } else {
          if (!v0)
            v0 = [x12, fm * x12 + fb];
          else if (v0[0] < x02)
            return;
          v1 = [x02, fm * x02 + fb];
        }
      }
    }
    edge[0] = v0;
    edge[1] = v1;
    return true;
  }
  function clipEdges(x02, y0, x12, y1) {
    var i = edges.length, edge;
    while (i--) {
      if (!connectEdge(edge = edges[i], x02, y0, x12, y1) || !clipEdge(edge, x02, y0, x12, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
        delete edges[i];
      }
    }
  }

  // node_modules/d3-voronoi/src/Cell.js
  function createCell(site) {
    return cells[site.index] = {
      site,
      halfedges: []
    };
  }
  function cellHalfedgeAngle(cell, edge) {
    var site = cell.site, va = edge.left, vb = edge.right;
    if (site === vb)
      vb = va, va = site;
    if (vb)
      return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
    if (site === va)
      va = edge[1], vb = edge[0];
    else
      va = edge[0], vb = edge[1];
    return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
  }
  function cellHalfedgeStart(cell, edge) {
    return edge[+(edge.left !== cell.site)];
  }
  function cellHalfedgeEnd(cell, edge) {
    return edge[+(edge.left === cell.site)];
  }
  function sortCellHalfedges() {
    for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
      if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
        var index = new Array(m), array2 = new Array(m);
        for (j = 0; j < m; ++j)
          index[j] = j, array2[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
        index.sort(function(i2, j2) {
          return array2[j2] - array2[i2];
        });
        for (j = 0; j < m; ++j)
          array2[j] = halfedges[index[j]];
        for (j = 0; j < m; ++j)
          halfedges[j] = array2[j];
      }
    }
  }
  function clipCells(x02, y0, x12, y1) {
    var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;
    for (iCell = 0; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        halfedges = cell.halfedges;
        iHalfedge = halfedges.length;
        while (iHalfedge--) {
          if (!edges[halfedges[iHalfedge]]) {
            halfedges.splice(iHalfedge, 1);
          }
        }
        iHalfedge = 0, nHalfedges = halfedges.length;
        while (iHalfedge < nHalfedges) {
          end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
          start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
          if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
            halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end, Math.abs(endX - x02) < epsilon && y1 - endY > epsilon ? [x02, Math.abs(startX - x02) < epsilon ? startY : y1] : Math.abs(endY - y1) < epsilon && x12 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x12, y1] : Math.abs(endX - x12) < epsilon && endY - y0 > epsilon ? [x12, Math.abs(startX - x12) < epsilon ? startY : y0] : Math.abs(endY - y0) < epsilon && endX - x02 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x02, y0] : null)) - 1);
            ++nHalfedges;
          }
        }
        if (nHalfedges)
          cover = false;
      }
    }
    if (cover) {
      var dx, dy, d2, dc = Infinity;
      for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
        if (cell = cells[iCell]) {
          site = cell.site;
          dx = site[0] - x02;
          dy = site[1] - y0;
          d2 = dx * dx + dy * dy;
          if (d2 < dc)
            dc = d2, cover = cell;
        }
      }
      if (cover) {
        var v00 = [x02, y0], v01 = [x02, y1], v11 = [x12, y1], v10 = [x12, y0];
        cover.halfedges.push(edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1, edges.push(createBorderEdge(site, v01, v11)) - 1, edges.push(createBorderEdge(site, v11, v10)) - 1, edges.push(createBorderEdge(site, v10, v00)) - 1);
      }
    }
    for (iCell = 0; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        if (!cell.halfedges.length) {
          delete cells[iCell];
        }
      }
    }
  }

  // node_modules/d3-voronoi/src/Circle.js
  var circlePool = [];
  var firstCircle;
  function Circle() {
    RedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function attachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc)
      return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite)
      return;
    var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -epsilon2)
      return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x2 = (cy * ha - ay * hc) / d, y2 = (ax * hc - cx * ha) / d;
    var circle2 = circlePool.pop() || new Circle();
    circle2.arc = arc;
    circle2.site = cSite;
    circle2.x = x2 + bx;
    circle2.y = (circle2.cy = y2 + by) + Math.sqrt(x2 * x2 + y2 * y2);
    arc.circle = circle2;
    var before = null, node = circles._;
    while (node) {
      if (circle2.y < node.y || circle2.y === node.y && circle2.x <= node.x) {
        if (node.L)
          node = node.L;
        else {
          before = node.P;
          break;
        }
      } else {
        if (node.R)
          node = node.R;
        else {
          before = node;
          break;
        }
      }
    }
    circles.insert(before, circle2);
    if (!before)
      firstCircle = circle2;
  }
  function detachCircle(arc) {
    var circle2 = arc.circle;
    if (circle2) {
      if (!circle2.P)
        firstCircle = circle2.N;
      circles.remove(circle2);
      circlePool.push(circle2);
      RedBlackNode(circle2);
      arc.circle = null;
    }
  }

  // node_modules/d3-voronoi/src/Beach.js
  var beachPool = [];
  function Beach() {
    RedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function createBeach(site) {
    var beach = beachPool.pop() || new Beach();
    beach.site = site;
    return beach;
  }
  function detachBeach(beach) {
    detachCircle(beach);
    beaches.remove(beach);
    beachPool.push(beach);
    RedBlackNode(beach);
  }
  function removeBeach(beach) {
    var circle2 = beach.circle, x2 = circle2.x, y2 = circle2.cy, vertex = [x2, y2], previous = beach.P, next = beach.N, disappearing = [beach];
    detachBeach(beach);
    var lArc = previous;
    while (lArc.circle && Math.abs(x2 - lArc.circle.x) < epsilon && Math.abs(y2 - lArc.circle.cy) < epsilon) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      detachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    detachCircle(lArc);
    var rArc = next;
    while (rArc.circle && Math.abs(x2 - rArc.circle.x) < epsilon && Math.abs(y2 - rArc.circle.cy) < epsilon) {
      next = rArc.N;
      disappearing.push(rArc);
      detachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    detachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
    attachCircle(lArc);
    attachCircle(rArc);
  }
  function addBeach(site) {
    var x2 = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = beaches._;
    while (node) {
      dxl = leftBreakPoint(node, directrix) - x2;
      if (dxl > epsilon)
        node = node.L;
      else {
        dxr = x2 - rightBreakPoint(node, directrix);
        if (dxr > epsilon) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -epsilon) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -epsilon) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    createCell(site);
    var newArc = createBeach(site);
    beaches.insert(lArc, newArc);
    if (!lArc && !rArc)
      return;
    if (lArc === rArc) {
      detachCircle(lArc);
      rArc = createBeach(lArc.site);
      beaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
      attachCircle(lArc);
      attachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = createEdge(lArc.site, newArc.site);
      return;
    }
    detachCircle(lArc);
    detachCircle(rArc);
    var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
    setEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = createEdge(lSite, site, null, vertex);
    rArc.edge = createEdge(site, rSite, null, vertex);
    attachCircle(lArc);
    attachCircle(rArc);
  }
  function leftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
    if (!pby2)
      return rfocx;
    var lArc = arc.P;
    if (!lArc)
      return -Infinity;
    site = lArc.site;
    var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
    if (!plby2)
      return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2)
      return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function rightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc)
      return leftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site[1] === directrix ? site[0] : Infinity;
  }

  // node_modules/d3-voronoi/src/Diagram.js
  var epsilon = 1e-6;
  var epsilon2 = 1e-12;
  var beaches;
  var cells;
  var circles;
  var edges;
  function triangleArea(a, b, c) {
    return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
  }
  function lexicographic(a, b) {
    return b[1] - a[1] || b[0] - a[0];
  }
  function Diagram(sites, extent) {
    var site = sites.sort(lexicographic).pop(), x2, y2, circle2;
    edges = [];
    cells = new Array(sites.length);
    beaches = new RedBlackTree_default();
    circles = new RedBlackTree_default();
    while (true) {
      circle2 = firstCircle;
      if (site && (!circle2 || site[1] < circle2.y || site[1] === circle2.y && site[0] < circle2.x)) {
        if (site[0] !== x2 || site[1] !== y2) {
          addBeach(site);
          x2 = site[0], y2 = site[1];
        }
        site = sites.pop();
      } else if (circle2) {
        removeBeach(circle2.arc);
      } else {
        break;
      }
    }
    sortCellHalfedges();
    if (extent) {
      var x02 = +extent[0][0], y0 = +extent[0][1], x12 = +extent[1][0], y1 = +extent[1][1];
      clipEdges(x02, y0, x12, y1);
      clipCells(x02, y0, x12, y1);
    }
    this.edges = edges;
    this.cells = cells;
    beaches = circles = edges = cells = null;
  }
  Diagram.prototype = {
    constructor: Diagram,
    polygons: function() {
      var edges2 = this.edges;
      return this.cells.map(function(cell) {
        var polygon2 = cell.halfedges.map(function(i) {
          return cellHalfedgeStart(cell, edges2[i]);
        });
        polygon2.data = cell.site.data;
        return polygon2;
      });
    },
    triangles: function() {
      var triangles = [], edges2 = this.edges;
      this.cells.forEach(function(cell, i) {
        if (!(m = (halfedges = cell.halfedges).length))
          return;
        var site = cell.site, halfedges, j = -1, m, s0, e1 = edges2[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;
        while (++j < m) {
          s0 = s1;
          e1 = edges2[halfedges[j]];
          s1 = e1.left === site ? e1.right : e1.left;
          if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
            triangles.push([site.data, s0.data, s1.data]);
          }
        }
      });
      return triangles;
    },
    links: function() {
      return this.edges.filter(function(edge) {
        return edge.right;
      }).map(function(edge) {
        return {
          source: edge.left.data,
          target: edge.right.data
        };
      });
    },
    find: function(x2, y2, radius) {
      var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
      while (!(cell = that.cells[i1]))
        if (++i1 >= n)
          return null;
      var dx = x2 - cell.site[0], dy = y2 - cell.site[1], d2 = dx * dx + dy * dy;
      do {
        cell = that.cells[i0 = i1], i1 = null;
        cell.halfedges.forEach(function(e) {
          var edge = that.edges[e], v = edge.left;
          if ((v === cell.site || !v) && !(v = edge.right))
            return;
          var vx = x2 - v[0], vy = y2 - v[1], v2 = vx * vx + vy * vy;
          if (v2 < d2)
            d2 = v2, i1 = v.index;
        });
      } while (i1 !== null);
      that._found = i0;
      return radius == null || d2 <= radius * radius ? cell.site : null;
    }
  };

  // node_modules/@turf/difference/dist/es/index.js
  var import_polygon_clipping = __toESM(require_polygon_clipping_umd(), 1);

  // node_modules/@turf/buffer/dist/es/index.js
  var import_turf_jsts = __toESM(require_jsts_min(), 1);

  // node_modules/d3-geo/src/adder.js
  function adder_default() {
    return new Adder();
  }
  function Adder() {
    this.reset();
  }
  Adder.prototype = {
    constructor: Adder,
    reset: function() {
      this.s = this.t = 0;
    },
    add: function(y2) {
      add(temp, y2, this.t);
      add(this, temp.s, this.s);
      if (this.s)
        this.t += temp.t;
      else
        this.s = temp.t;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var temp = new Adder();
  function add(adder, a, b) {
    var x2 = adder.s = a + b, bv = x2 - a, av = x2 - bv;
    adder.t = a - av + (b - bv);
  }

  // node_modules/d3-geo/src/math.js
  var epsilon3 = 1e-6;
  var pi = Math.PI;
  var halfPi = pi / 2;
  var quarterPi = pi / 4;
  var tau = pi * 2;
  var degrees = 180 / pi;
  var radians = pi / 180;
  var abs = Math.abs;
  var atan = Math.atan;
  var atan2 = Math.atan2;
  var cos = Math.cos;
  var exp = Math.exp;
  var log = Math.log;
  var sin = Math.sin;
  var sqrt = Math.sqrt;
  var tan = Math.tan;
  function acos(x2) {
    return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
  }
  function asin(x2) {
    return x2 > 1 ? halfPi : x2 < -1 ? -halfPi : Math.asin(x2);
  }

  // node_modules/d3-geo/src/noop.js
  function noop() {
  }

  // node_modules/d3-geo/src/area.js
  var areaRingSum = adder_default();
  var areaSum = adder_default();

  // node_modules/d3-geo/src/cartesian.js
  function cartesian(spherical2) {
    var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
    return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
  }
  function cartesianCross(a, b) {
    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
  }
  function cartesianNormalizeInPlace(d) {
    var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l, d[1] /= l, d[2] /= l;
  }

  // node_modules/d3-geo/src/bounds.js
  var deltaSum = adder_default();

  // node_modules/d3-geo/src/rotation.js
  function rotationIdentity(lambda, phi) {
    return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
  }
  rotationIdentity.invert = rotationIdentity;

  // node_modules/d3-geo/src/clip/buffer.js
  function buffer_default() {
    var lines = [], line;
    return {
      point: function(x2, y2) {
        line.push([x2, y2]);
      },
      lineStart: function() {
        lines.push(line = []);
      },
      lineEnd: noop,
      rejoin: function() {
        if (lines.length > 1)
          lines.push(lines.pop().concat(lines.shift()));
      },
      result: function() {
        var result = lines;
        lines = [];
        line = null;
        return result;
      }
    };
  }

  // node_modules/d3-geo/src/pointEqual.js
  function pointEqual_default(a, b) {
    return abs(a[0] - b[0]) < epsilon3 && abs(a[1] - b[1]) < epsilon3;
  }

  // node_modules/d3-geo/src/clip/polygon.js
  function Intersection(point2, points, other, entry) {
    this.x = point2;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function polygon_default(segments, compareIntersection2, startInside, interpolate, stream) {
    var subject = [], clip = [], i, n;
    segments.forEach(function(segment) {
      if ((n2 = segment.length - 1) <= 0)
        return;
      var n2, p0 = segment[0], p1 = segment[n2], x2;
      if (pointEqual_default(p0, p1)) {
        stream.lineStart();
        for (i = 0; i < n2; ++i)
          stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      subject.push(x2 = new Intersection(p0, segment, null, true));
      clip.push(x2.o = new Intersection(p0, null, x2, false));
      subject.push(x2 = new Intersection(p1, segment, null, false));
      clip.push(x2.o = new Intersection(p1, null, x2, true));
    });
    if (!subject.length)
      return;
    clip.sort(compareIntersection2);
    link(subject);
    link(clip);
    for (i = 0, n = clip.length; i < n; ++i) {
      clip[i].e = startInside = !startInside;
    }
    var start = subject[0], points, point2;
    while (1) {
      var current = start, isSubject = true;
      while (current.v)
        if ((current = current.n) === start)
          return;
      points = current.z;
      stream.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (i = 0, n = points.length; i < n; ++i)
              stream.point((point2 = points[i])[0], point2[1]);
          } else {
            interpolate(current.x, current.n.x, 1, stream);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (i = points.length - 1; i >= 0; --i)
              stream.point((point2 = points[i])[0], point2[1]);
          } else {
            interpolate(current.x, current.p.x, -1, stream);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      stream.lineEnd();
    }
  }
  function link(array2) {
    if (!(n = array2.length))
      return;
    var n, i = 0, a = array2[0], b;
    while (++i < n) {
      a.n = b = array2[i];
      b.p = a;
      a = b;
    }
    a.n = b = array2[0];
    b.p = a;
  }

  // node_modules/d3-array/src/ascending.js
  function ascending_default(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // node_modules/d3-array/src/bisector.js
  function bisector_default(compare) {
    if (compare.length === 1)
      compare = ascendingComparator(compare);
    return {
      left: function(a, x2, lo, hi) {
        if (lo == null)
          lo = 0;
        if (hi == null)
          hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x2) < 0)
            lo = mid + 1;
          else
            hi = mid;
        }
        return lo;
      },
      right: function(a, x2, lo, hi) {
        if (lo == null)
          lo = 0;
        if (hi == null)
          hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x2) > 0)
            hi = mid;
          else
            lo = mid + 1;
        }
        return lo;
      }
    };
  }
  function ascendingComparator(f) {
    return function(d, x2) {
      return ascending_default(f(d), x2);
    };
  }

  // node_modules/d3-array/src/bisect.js
  var ascendingBisect = bisector_default(ascending_default);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;

  // node_modules/d3-array/src/array.js
  var array = Array.prototype;
  var slice = array.slice;
  var map = array.map;

  // node_modules/d3-array/src/ticks.js
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);

  // node_modules/d3-array/src/merge.js
  function merge_default2(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array2;
    while (++i < n)
      j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array2 = arrays[n];
      m = array2.length;
      while (--m >= 0) {
        merged[--j] = array2[m];
      }
    }
    return merged;
  }

  // node_modules/d3-geo/src/clip/extent.js
  var clipMax = 1e9;
  var clipMin = -clipMax;

  // node_modules/d3-geo/src/polygonContains.js
  var sum = adder_default();
  function polygonContains_default(polygon2, point2) {
    var lambda = point2[0], phi = point2[1], normal = [sin(lambda), -cos(lambda), 0], angle = 0, winding = 0;
    sum.reset();
    for (var i = 0, n = polygon2.length; i < n; ++i) {
      if (!(m = (ring = polygon2[i]).length))
        continue;
      var ring, m, point0 = ring[m - 1], lambda0 = point0[0], phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);
      for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
        var point1 = ring[j], lambda1 = point1[0], phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta = lambda1 - lambda0, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi, k = sinPhi0 * sinPhi1;
        sum.add(atan2(k * sign2 * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
        angle += antimeridian ? delta + sign2 * tau : delta;
        if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
          var arc = cartesianCross(cartesian(point0), cartesian(point1));
          cartesianNormalizeInPlace(arc);
          var intersection = cartesianCross(normal, arc);
          cartesianNormalizeInPlace(intersection);
          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
          if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
            winding += antimeridian ^ delta >= 0 ? 1 : -1;
          }
        }
      }
    }
    return (angle < -epsilon3 || angle < epsilon3 && sum < -epsilon3) ^ winding & 1;
  }

  // node_modules/d3-geo/src/length.js
  var lengthSum = adder_default();

  // node_modules/d3-geo/src/path/area.js
  var areaSum2 = adder_default();
  var areaRingSum2 = adder_default();

  // node_modules/d3-geo/src/path/bounds.js
  var x0 = Infinity;
  var x1 = -x0;

  // node_modules/d3-geo/src/path/context.js
  function PathContext(context) {
    this._context = context;
  }
  PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function(_) {
      return this._radius = _, this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0)
        this._context.closePath();
      this._point = NaN;
    },
    point: function(x2, y2) {
      switch (this._point) {
        case 0: {
          this._context.moveTo(x2, y2);
          this._point = 1;
          break;
        }
        case 1: {
          this._context.lineTo(x2, y2);
          break;
        }
        default: {
          this._context.moveTo(x2 + this._radius, y2);
          this._context.arc(x2, y2, this._radius, 0, tau);
          break;
        }
      }
    },
    result: noop
  };

  // node_modules/d3-geo/src/path/measure.js
  var lengthSum2 = adder_default();

  // node_modules/d3-geo/src/path/string.js
  function PathString() {
    this._string = [];
  }
  PathString.prototype = {
    _radius: 4.5,
    _circle: circle(4.5),
    pointRadius: function(_) {
      if ((_ = +_) !== this._radius)
        this._radius = _, this._circle = null;
      return this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0)
        this._string.push("Z");
      this._point = NaN;
    },
    point: function(x2, y2) {
      switch (this._point) {
        case 0: {
          this._string.push("M", x2, ",", y2);
          this._point = 1;
          break;
        }
        case 1: {
          this._string.push("L", x2, ",", y2);
          break;
        }
        default: {
          if (this._circle == null)
            this._circle = circle(this._radius);
          this._string.push("M", x2, ",", y2, this._circle);
          break;
        }
      }
    },
    result: function() {
      if (this._string.length) {
        var result = this._string.join("");
        this._string = [];
        return result;
      } else {
        return null;
      }
    }
  };
  function circle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }

  // node_modules/d3-geo/src/clip/index.js
  function clip_default(pointVisible, clipLine, interpolate, start) {
    return function(rotate, sink) {
      var line = clipLine(sink), rotatedStart = rotate.invert(start[0], start[1]), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon2, segments, ring;
      var clip = {
        point: point2,
        lineStart,
        lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon2 = [];
        },
        polygonEnd: function() {
          clip.point = point2;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = merge_default2(segments);
          var startInside = polygonContains_default(polygon2, rotatedStart);
          if (segments.length) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            polygon_default(segments, compareIntersection, startInside, interpolate, sink);
          } else if (startInside) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
          }
          if (polygonStarted)
            sink.polygonEnd(), polygonStarted = false;
          segments = polygon2 = null;
        },
        sphere: function() {
          sink.polygonStart();
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
          sink.polygonEnd();
        }
      };
      function point2(lambda, phi) {
        var point3 = rotate(lambda, phi);
        if (pointVisible(lambda = point3[0], phi = point3[1]))
          sink.point(lambda, phi);
      }
      function pointLine(lambda, phi) {
        var point3 = rotate(lambda, phi);
        line.point(point3[0], point3[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point2;
        line.lineEnd();
      }
      function pointRing(lambda, phi) {
        ring.push([lambda, phi]);
        var point3 = rotate(lambda, phi);
        ringSink.point(point3[0], point3[1]);
      }
      function ringStart() {
        ringSink.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringSink.lineEnd();
        var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point3;
        ring.pop();
        polygon2.push(ring);
        ring = null;
        if (!n)
          return;
        if (clean & 1) {
          segment = ringSegments[0];
          if ((m = segment.length - 1) > 0) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            for (i = 0; i < m; ++i)
              sink.point((point3 = segment[i])[0], point3[1]);
            sink.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2)
          ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(validSegment));
      }
      return clip;
    };
  }
  function validSegment(segment) {
    return segment.length > 1;
  }
  function compareIntersection(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon3 : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon3 : halfPi - b[1]);
  }

  // node_modules/d3-geo/src/clip/antimeridian.js
  var antimeridian_default = clip_default(function() {
    return true;
  }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi, -halfPi]);
  function clipAntimeridianLine(stream) {
    var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
    return {
      lineStart: function() {
        stream.lineStart();
        clean = 1;
      },
      point: function(lambda1, phi1) {
        var sign1 = lambda1 > 0 ? pi : -pi, delta = abs(lambda1 - lambda0);
        if (abs(delta - pi) < epsilon3) {
          stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          stream.point(lambda1, phi0);
          clean = 0;
        } else if (sign0 !== sign1 && delta >= pi) {
          if (abs(lambda0 - sign0) < epsilon3)
            lambda0 -= sign0 * epsilon3;
          if (abs(lambda1 - sign1) < epsilon3)
            lambda1 -= sign1 * epsilon3;
          phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          clean = 0;
        }
        stream.point(lambda0 = lambda1, phi0 = phi1);
        sign0 = sign1;
      },
      lineEnd: function() {
        stream.lineEnd();
        lambda0 = phi0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
    var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);
    return abs(sinLambda0Lambda1) > epsilon3 ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
  }
  function clipAntimeridianInterpolate(from, to, direction, stream) {
    var phi;
    if (from == null) {
      phi = direction * halfPi;
      stream.point(-pi, phi);
      stream.point(0, phi);
      stream.point(pi, phi);
      stream.point(pi, 0);
      stream.point(pi, -phi);
      stream.point(0, -phi);
      stream.point(-pi, -phi);
      stream.point(-pi, 0);
      stream.point(-pi, phi);
    } else if (abs(from[0] - to[0]) > epsilon3) {
      var lambda = from[0] < to[0] ? pi : -pi;
      phi = direction * lambda / 2;
      stream.point(-lambda, phi);
      stream.point(0, phi);
      stream.point(lambda, phi);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  // node_modules/d3-geo/src/transform.js
  function transformer(methods) {
    return function(stream) {
      var s = new TransformStream();
      for (var key in methods)
        s[key] = methods[key];
      s.stream = stream;
      return s;
    };
  }
  function TransformStream() {
  }
  TransformStream.prototype = {
    constructor: TransformStream,
    point: function(x2, y2) {
      this.stream.point(x2, y2);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };

  // node_modules/d3-geo/src/projection/resample.js
  var cosMinDistance = cos(30 * radians);

  // node_modules/d3-geo/src/projection/index.js
  var transformRadians = transformer({
    point: function(x2, y2) {
      this.stream.point(x2 * radians, y2 * radians);
    }
  });

  // node_modules/d3-geo/src/projection/azimuthal.js
  function azimuthalRaw(scale) {
    return function(x2, y2) {
      var cx = cos(x2), cy = cos(y2), k = scale(cx * cy);
      return [
        k * cy * sin(x2),
        k * sin(y2)
      ];
    };
  }
  function azimuthalInvert(angle) {
    return function(x2, y2) {
      var z = sqrt(x2 * x2 + y2 * y2), c = angle(z), sc = sin(c), cc = cos(c);
      return [
        atan2(x2 * sc, z * cc),
        asin(z && y2 * sc / z)
      ];
    };
  }

  // node_modules/d3-geo/src/projection/azimuthalEqualArea.js
  var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
    return sqrt(2 / (1 + cxcy));
  });
  azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
    return 2 * asin(z / 2);
  });

  // node_modules/d3-geo/src/projection/azimuthalEquidistant.js
  var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
    return (c = acos(c)) && c / sin(c);
  });
  azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
    return z;
  });

  // node_modules/d3-geo/src/projection/mercator.js
  function mercatorRaw(lambda, phi) {
    return [lambda, log(tan((halfPi + phi) / 2))];
  }
  mercatorRaw.invert = function(x2, y2) {
    return [x2, 2 * atan(exp(y2)) - halfPi];
  };

  // node_modules/d3-geo/src/projection/equirectangular.js
  function equirectangularRaw(lambda, phi) {
    return [lambda, phi];
  }
  equirectangularRaw.invert = equirectangularRaw;

  // node_modules/d3-geo/src/projection/gnomonic.js
  function gnomonicRaw(x2, y2) {
    var cy = cos(y2), k = cos(x2) * cy;
    return [cy * sin(x2) / k, sin(y2) / k];
  }
  gnomonicRaw.invert = azimuthalInvert(atan);

  // node_modules/d3-geo/src/projection/naturalEarth1.js
  function naturalEarth1Raw(lambda, phi) {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    return [
      lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
      phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
    ];
  }
  naturalEarth1Raw.invert = function(x2, y2) {
    var phi = y2, i = 25, delta;
    do {
      var phi2 = phi * phi, phi4 = phi2 * phi2;
      phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y2) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
    } while (abs(delta) > epsilon3 && --i > 0);
    return [
      x2 / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
      phi
    ];
  };

  // node_modules/d3-geo/src/projection/orthographic.js
  function orthographicRaw(x2, y2) {
    return [cos(y2) * sin(x2), sin(y2)];
  }
  orthographicRaw.invert = azimuthalInvert(asin);

  // node_modules/d3-geo/src/projection/stereographic.js
  function stereographicRaw(x2, y2) {
    var cy = cos(y2), k = 1 + cos(x2) * cy;
    return [cy * sin(x2) / k, sin(y2) / k];
  }
  stereographicRaw.invert = azimuthalInvert(function(z) {
    return 2 * atan(z);
  });

  // node_modules/d3-geo/src/projection/transverseMercator.js
  function transverseMercatorRaw(lambda, phi) {
    return [log(tan((halfPi + phi) / 2)), -lambda];
  }
  transverseMercatorRaw.invert = function(x2, y2) {
    return [-y2, 2 * atan(exp(x2)) - halfPi];
  };

  // node_modules/@turf/union/dist/es/index.js
  var import_polygon_clipping2 = __toESM(require_polygon_clipping_umd(), 1);

  // node_modules/@turf/intersect/dist/es/index.js
  var import_polygon_clipping3 = __toESM(require_polygon_clipping_umd(), 1);

  // node_modules/@turf/dissolve/dist/es/index.js
  var import_polygon_clipping4 = __toESM(require_polygon_clipping_umd(), 1);

  // node_modules/@turf/mask/dist/es/index.js
  var import_polygon_clipping5 = __toESM(require_polygon_clipping_umd(), 1);

  // src/main.ts
  var import_leaflet = __toESM(require_leaflet_src());
  function getIcon(allegiance) {
    const allegianceMap = {
      "K.D.": "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png",
      "K.L.": "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png",
      "Sabbat": "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-black.png",
      "Thinbloods": "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-yellow.png",
      "default": "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-grey.png"
    };
    return new import_leaflet.default.Icon({
      iconUrl: allegianceMap[allegiance] || allegianceMap["default"],
      shadowUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png",
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });
  }
  async function downloadGeoJSON() {
    const index = await (await fetch("/static/index.json")).json();
    const kyivData = {
      "type": "FeatureCollection",
      "features": []
    };
    for (const file of index.filenames) {
      const data = await (await fetch(`/static/${file}`)).json();
      kyivData.features = [
        ...kyivData.features,
        ...data.features
      ];
    }
    return kyivData;
  }
  function initMap() {
    const map2 = import_leaflet.default.map("map").setView([50.447, 30.4865], 11.5);
    import_leaflet.default.tileLayer("https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=sk.eyJ1Ijoia25pZGFya25lc3MiLCJhIjoiY2t6b2FjYnhvMDl3azJycGUyNGhkZHZndSJ9.kXUOPY3a4H0APG7MiDNVXA", {
      attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Imagery \xA9 <a href="https://www.mapbox.com/">Mapbox</a>',
      maxZoom: 18,
      id: "mapbox/streets-v11",
      tileSize: 512,
      zoomOffset: -1,
      accessToken: "sk.eyJ1Ijoia25pZGFya25lc3MiLCJhIjoiY2t6b2FjYnhvMDl3azJycGUyNGhkZHZndSJ9.kXUOPY3a4H0APG7MiDNVXA"
    }).addTo(map2);
    return map2;
  }
  function calculateArea2(domain) {
    domain.features.forEach((f) => {
      f.properties.area = f.geometry.type !== "Polygon" ? 0 : area(polygon(f.geometry.coordinates));
    });
  }
  function drawMap(map2, domain) {
    import_leaflet.default.geoJSON(domain, {
      style: (f) => {
        return {
          color: f.properties.color || "blue"
        };
      },
      pointToLayer: function(feature2, latlng) {
        return import_leaflet.default.marker(latlng, {
          icon: getIcon(feature2.properties.allegiance)
        });
      },
      onEachFeature: (f, layer) => {
        if (f.properties.name) {
          layer.bindPopup(f.properties.name + "<br> \u0421\u0442\u043E\u0440\u043E\u043D\u0430: " + f.properties.allegiance);
        }
      }
    }).addTo(map2);
  }
  function getLegend() {
    const legend = new import_leaflet.default.Control({ position: "bottomleft" });
    legend.onAdd = (map2) => {
      const div = import_leaflet.default.DomUtil.create("div", "legend-block"), labels = ["K.D", "K.L", "Thinbloods", "Sabbat"];
      for (const item of labels) {
        div.innerHTML += `<div class="legend-row"><i class=${item.replace(".", "")}></i>${item}<br></div>`;
      }
      return div;
    };
    return legend;
  }
  async function loaded() {
    const map2 = initMap();
    const domain = await downloadGeoJSON();
    calculateArea2(domain);
    domain.features = domain.features.sort((a, b) => {
      return a.properties.area > b.properties.area ? -1 : 1;
    });
    drawMap(map2, domain);
    getLegend().addTo(map2);
  }
  window.onload = loaded;
})();
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* @preserve
 * Leaflet 1.7.1, a JS library for interactive maps. http://leafletjs.com
 * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
/*!
 * @license GNU Affero General Public License.
 * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
 * v. 1.2.0
 * https://github.com/RaumZeit/MarchingSquares.js
 *
 * MarchingSquaresJS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MarchingSquaresJS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * As additional permission under GNU Affero General Public License version 3
 * section 7, third-party projects (personal or commercial) may distribute,
 * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
 * requirement that said third-party project for that reason alone becomes
 * subject to any requirement of the GNU Affero General Public License version 3.
 * Any modifications to MarchingSquaresJS, however, must be shared with the public
 * and made available.
 *
 * In summary this:
 * - allows you to use MarchingSquaresJS at no cost
 * - allows you to use MarchingSquaresJS for both personal and commercial purposes
 * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
 *   license as long as this license notice is included
 * - enables you to keep the source code of your program that uses MarchingSquaresJS
 *   undisclosed
 * - forces you to share any modifications you have made to MarchingSquaresJS,
 *   e.g. bug-fixes
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * @license GNU Affero General Public License.
 * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
 * v. 1.2.0
 * https://github.com/RaumZeit/MarchingSquares.js
 *
 * MarchingSquaresJS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MarchingSquaresJS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * As additional permission under GNU Affero General Public License version 3
 * section 7, third-party projects (personal or commercial) may distribute,
 * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
 * requirement that said third-party project for that reason alone becomes
 * subject to any requirement of the GNU Affero General Public License version 3.
 * Any modifications to MarchingSquaresJS, however, must be shared with the public
 * and made available.
 *
 * In summary this:
 * - allows you to use MarchingSquaresJS at no cost
 * - allows you to use MarchingSquaresJS for both personal and commercial purposes
 * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
 *   license as long as this license notice is included
 * - enables you to keep the source code of your program that uses MarchingSquaresJS
 *   undisclosed
 * - forces you to share any modifications you have made to MarchingSquaresJS,
 *   e.g. bug-fixes
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * splaytree v3.1.0
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 */
